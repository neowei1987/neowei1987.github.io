<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.fpthinker.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
<meta property="og:type" content="website">
<meta property="og:title" content="Neo&#39;s Blog">
<meta property="og:url" content="https://www.fpthinker.com/page/8/index.html">
<meta property="og:site_name" content="Neo&#39;s Blog">
<meta property="og:description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
<meta property="og:locale">
<meta property="article:author" content="NeoWei">
<meta property="article:tag" content="后端开发知识体系,知识体系构建,刷题技巧,本质思考">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.fpthinker.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>Neo's Blog - 不抽象就无法深入思考<br>不还原就看不到本来面目!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Neo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不抽象就无法深入思考<br>不还原就看不到本来面目!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

		<div id="container">
		  <div class="content index posts-expand">
		    
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/server/timer/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/server/timer/index.html" class="post-title-link" itemprop="url">高性能服务器设计-定时器</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 15:01:03" itemprop="dateCreated datePublished" datetime="2022-02-25T15:01:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 22:44:41" itemprop="dateModified" datetime="2022-03-01T22:44:41+08:00">2022-03-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/server/timer/index.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/server/timer/index.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计目标：</p>
<ol>
<li>高性能，更快的找到下一个超时的Task</li>
<li>高分辨率，例如毫秒定时器</li>
</ol>
<p>实现方式：</p>
<ul>
<li>时间轮、多级时间轮</li>
<li>堆</li>
<li>基于排序链表 O(N)</li>
<li>红黑树</li>
</ul>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/server/concurrency_limiter/little_raw.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/server/concurrency_limiter/little_raw.html" class="post-title-link" itemprop="url">高性能服务器设计-littile's raw定律</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 13:40:03" itemprop="dateCreated datePublished" datetime="2022-02-25T13:40:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-30 18:32:37" itemprop="dateModified" datetime="2022-10-30T18:32:37+08:00">2022-10-30</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/server/concurrency_limiter/little_raw.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/server/concurrency_limiter/little_raw.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>并发 = rt * qps</p>
<h4 id="N-X-R"><a href="#N-X-R" class="headerlink" title="N = X * R"></a>N = X * R</h4><p>N表示系统中同时活动的用户，包括正在处理中和队列中的；X表示用户相继到达系统的速率，在平衡状态时即为系统吞吐量（到达=离开）；R表示每个用户在系统中平均的驻留时间</p>
<p>eg. 一个请求在系统中的停留时间，1s; 一秒钟平均过来100个请求（当然一秒钟也会离开100个请求）那么系统同时处理的请求数是多少？</p>
<p>应该是1s * 100 (个/s) = 100个。</p>
<h4 id="Eric的估算公式-C-L-n-T"><a href="#Eric的估算公式-C-L-n-T" class="headerlink" title="Eric的估算公式 C = L * n / T"></a>Eric的估算公式 C = L * n / T</h4><p>n表示同时在线；L表示平均停留时间；T表示高峰期持续时间；C为并发用户数量。</p>
<p>eg. 一个用户在系统中的停留时间，30分钟；晚高峰5～7点，有500在线；问系统的并发用户是多少？</p>
<p>假设系统后端维护session，那么这个session的长度即为30分钟，L=30minutes；用户活跃时长已经得知是从5点到7点共2个小时，T=2 hours；那么并发用户数C=n<em>L/T=500</em>30/(5*60)=50</p>
<h4 id="等价性说明"><a href="#等价性说明" class="headerlink" title="等价性说明"></a>等价性说明</h4><p>我们再来从另外的角度分解Eric的估算公式：</p>
<p>C=n<em>L/T  可以表示为  C=(n/T)</em>L</p>
<p>n/T 是不是和我们刚才在上面Little中第一步一样，是计算到达率X的。</p>
<p>而L（session时长）不就是R（驻留时间）吗？都等同于session时间长度。</p>
<p>也就是说C=(n/T)<em>L=X</em>R=N</p>
<p>结论：由以上得知，Eric’s 估算公式跟Little定律是等价的.</p>
<p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/hundredsofyears/p/3360305.html">https://www.cnblogs.com/hundredsofyears/p/3360305.html</a></p>
<p>并发  = 到达率X * 停留时间R</p>
<p>并发 = （同时在线人数c  / 高峰期持续时长T） * 平均停留时间L</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/server/concurrency_limiter/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/server/concurrency_limiter/index.html" class="post-title-link" itemprop="url">高性能服务器设计-限流模型</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 13:30:03" itemprop="dateCreated datePublished" datetime="2022-02-25T13:30:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-03 20:08:45" itemprop="dateModified" datetime="2022-11-03T20:08:45+08:00">2022-11-03</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/server/concurrency_limiter/index.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/server/concurrency_limiter/index.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务的处理能力是有客观上限的。当请求速度超过服务的处理速度时，服务就会过载。</p>
<p>如果服务持续过载，会导致越来越多的请求积压，最终所有的请求都必须等待较长时间才能被处理，从而使整个服务处于瘫痪状态。</p>
<p>与之相对的，如果直接拒绝掉一部分请求，反而能够让服务能够”及时”处理更多的请求。 我们称这种做法为限流。限流是过载保护的手段之一，目的在于保护系统不被超过服务吞吐能力的流量（或突发）打死。</p>
<p>常见的限流手段有固定窗口、滑动窗口、令牌桶、漏桶、BBR、brpc自适应限流等。</p>
<p>下面挨个介绍每一种限流算法的原理以及优缺点。</p>
<h3 id="传统的基于配置的单机限流算法"><a href="#传统的基于配置的单机限流算法" class="headerlink" title="传统的基于配置的单机限流算法"></a>传统的基于配置的单机限流算法</h3><h4 id="第一，固定窗口"><a href="#第一，固定窗口" class="headerlink" title="第一，固定窗口"></a>第一，固定窗口</h4><p>原理：维护一个窗口的两个信息：窗口开始时间、经过窗口的请求数。如果窗口内超出限制数则拒绝。如果已经进入新的窗口，则reset计数。</p>
<p>不足：存在临界点（窗口reset前后的瞬时）的qps会飙高，从而打死系统。</p>
<h4 id="第二，滑动窗口"><a href="#第二，滑动窗口" class="headerlink" title="第二，滑动窗口"></a>第二，滑动窗口</h4><p>原理：将总的时间窗口划分为N个小格，并单独维护每一个小格的计数。通过这种方式，可以把过去一段时间内的计数信息也用上，从而让限流的统计更精确一些。</p>
<p>不足：窗口不可能无限划分</p>
<h4 id="第三，漏桶"><a href="#第三，漏桶" class="headerlink" title="第三，漏桶"></a>第三，漏桶</h4><p>原理：漏桶具有固定容量，出水速率是固定常量（流出请求）如果桶是空的，则不需流出水滴。可以以任意速率流入水滴到漏桶（流入请求）如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）</p>
<p>不足：无法应对突发流量</p>
<p><img src="http://cdn.b5mang.com/20201222223148.png" alt="20201222223148"></p>
<h4 id="第四，令牌桶"><a href="#第四，令牌桶" class="headerlink" title="第四，令牌桶"></a>第四，令牌桶</h4><p>原理：假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中。假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃。当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络。如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外。</p>
<p>算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。</p>
<p><img src="http://cdn.b5mang.com/20201222223820.png" alt="20201222223820"></p>
<h3 id="自适应限流"><a href="#自适应限流" class="headerlink" title="自适应限流"></a>自适应限流</h3><p>上面的几种算法，一定程度上确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。具体有如下几个弊端：</p>
<ol>
<li>集群增加机器或者减少机器限流阈值是否要重新设置?</li>
<li>设置限流阈值的依据是什么?</li>
<li>人力运维成本是否过高?</li>
<li>只针对局部服务端的限流，无法掌控全局资源，</li>
<li>当调用方反馈限流错误时, 这个时候重新设置限流, 其实流量高峰已经过了。重新评估限流是否有意义？</li>
</ol>
<h4 id="第五，B站BBR限流"><a href="#第五，B站BBR限流" class="headerlink" title="第五，B站BBR限流"></a>第五，B站BBR限流</h4><p>底层原理：并发 = qps * latency</p>
<p>自适应限流能动态调整服务的最大并发，在保证服务不过载的前提下，让服务尽可能多的处理请求。</p>
<p>具体逻辑：如果cpu &gt; 800 &amp;&amp; inflight &gt;  rt * max_qps，则启用限流</p>
<p>为什么要用 CPU\IOPS 作为启发值呢？</p>
<p>因为自适应限流与 TCP 拥塞控制还存在不同之处，TCP 中客户端可以控制发送率，从而探测到 maxPass，但是 RPC <strong>线上无法控制流量的速率</strong>，所以必须以 CPU 作为标准，当 CPU 快满载的时候再开启，这时我们认为之前探测到的 maxPass 已经接近了系统的瓶颈，乘以 minRtt 就可以得到 InFlight</p>
<h4 id="第六，BRPC自适应限流"><a href="#第六，BRPC自适应限流" class="headerlink" title="第六，BRPC自适应限流"></a>第六，BRPC自适应限流</h4><ul>
<li>peek_qps 峰值qps</li>
<li>nodelay_latency 系统无负载或者低负载的响应时间，理论值无法计算</li>
<li>Min_latency 用来替代nodelay_latency</li>
<li>max_cocurrent  = max_qps * ((2+alpha) * min_latency - latency)</li>
</ul>
<p>服务的noload_latency并非是一成不变的，自适应限流必须能够正确的探测noload_latency的变化。当noload_latency下降时，是很容感知到的，因为这个时候latency也会下降。难点在于当latency上涨时，需要能够正确的辨别到底是服务过载了，还是noload_latency上涨了。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.mianshigee.com/tutorial/incubator-brpc/1778a50865eb3518.md">BRPC开发手册</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://xueqiu.com/9217191040/139169952">B站在微服务治理中如何探索与实践</a></p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/mq/kafka.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/mq/kafka.html" class="post-title-link" itemprop="url">消息队列-Kafka</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 13:06:03" itemprop="dateCreated datePublished" datetime="2022-02-25T13:06:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-26 22:26:13" itemprop="dateModified" datetime="2022-11-26T22:26:13+08:00">2022-11-26</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/mq/kafka.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/mq/kafka.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img-blog.csdn.net/20180317011215184?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="设计思想"></p>
<h4 id="cosume-group"><a href="#cosume-group" class="headerlink" title="cosume group"></a>cosume group</h4><p>通过cosume group，巧妙的解决了广播问题。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>SendFile、zero copy</p>
<h4 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h4><p>Kafka为了卸载MQ本身的复杂性，为了其<strong>真正无状态</strong>的设计，它将状态维护机制这口锅完全甩给了消费者，因此取消息的问题就转化成了<strong>消费者拿着一个offset索引来Kafka存储器里取消息</strong>的问题，这就涉及到了性能。But 如何能查的更快？How？</p>
<p><img src="https://img-blog.csdn.net/20180317015646335?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫描partition文件"></p>
<p>但实际上，</p>
<p><img src="https://img-blog.csdn.net/20180317020648952?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="partition"></p>
<ol>
<li>partition并不是一根文件，而是一个目录</li>
<li>目录下面存了很多逻辑上的segment，每一个segment物理上包括两个文件：索引文件、日志文件（每次都append)</li>
</ol>
<p>文件的命名相当于查找的稀疏索引，省去索引文件</p>
<p>每个segment索引又是一个稀疏索引减少索引文件的大小</p>
<h4 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h4><p>2.1 消息备份</p>
<p>Kafka允许同个Partition存在多个消息副本(Replica)，每个Partition的副本通常由1个Leader及0个以上的Follower组成，产者将消息直接发往对应Partition的Leader，Follower会周期地向Leader发送同步请求，Kafka的Leader机制在保障数据致性地同时降低了消息备份的复杂度。同Partition的Replica应存储在同一个Broker上，因为一旦该Broker宕机，对应Partition的所有Replica都无法作，这就达不到高可用的效果。为做好负载均衡并提容错能，Kafka会尽将所有的Partition以及各Partition的副本均匀地分配到整个集群上。举个例，当集群中部署3台Broker，TopicA共有4个Partition，每个Partition均有3个Replica时下图就是种合理的分布方式。</p>
<p><img src="https://pics4.baidu.com/feed/d833c895d143ad4b76bc3f8833f912a7a60f06ef.jpeg" alt=""></p>
<p>ISR:In-Sync Replicas 副本同步队列</p>
<p>ISR(In-Sync Replicas)指的是个Partition中与Leader“保持同步”的Replica列表(实际存储的是副本所在Broker的BrokerId)，这的 保持同步是指与Leader数据保持完全一致，只需在replica.lag.time.max.ms时间内与Leader保持有效连接，官方解释如下If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr,( default value =10000 )Follower周期性地向Leader发送FetchRequest请求(数据结构见下)，发送时间间隔配置在replica.fetch.wait.max.ms中，默认值为 500。</p>
<p>AR:Assigned Replicas 所有副本</p>
<p>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。</p>
<p>ISR数据同步、ACK选项（全部ack、只有一个ack）</p>
<p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p>
<p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 </p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/dog250/article/details/79588437">https://blog.csdn.net/dog250/article/details/79588437</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_28900249/article/details/90346599">https://blog.csdn.net/qq_28900249/article/details/90346599</a></p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/mq/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/mq/index.html" class="post-title-link" itemprop="url">消息队列-概览</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 13:03:03" itemprop="dateCreated datePublished" datetime="2022-02-25T13:03:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 22:40:57" itemprop="dateModified" datetime="2022-03-01T22:40:57+08:00">2022-03-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/mq/index.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/mq/index.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>可能的一些作用：</p>
<ol>
<li>非核心逻辑异步化，追求高性能</li>
<li>解除耦合</li>
<li>实现广播</li>
<li>削峰填谷</li>
</ol>
<hr>
<p>具体可以用于：</p>
<ol>
<li>分布式事务，单方生产，多个消费业务逻辑</li>
<li>数据复制：通过消息队列，将数据复制到多个目的地（多维度数据表、ES、Hadoop、搜索等）</li>
<li>日志同步：多个app生产日志并放入队列，然后消费队列完成日志的离线与实时处理</li>
<li>延迟队列：可靠的延迟队列，分布式环境定时器</li>
<li>广播通知：Cache失效通知</li>
</ol>
<hr>
<p>分布式消息队列的评价指标</p>
<h5 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h5><p>分布式消息队列提供更好的可靠性，主要体现在：</p>
<ol>
<li>消息会被持久化到分布式存储中。这样避免了单台机器存储的消息由于机器问题导致消息的丢失；</li>
<li>不佳的网络环境中，保证只有当消息的接收者确实收到消息时才从队列中删除消息。</li>
</ol>
<h5 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h5><p>可扩展性体现在访问量和数据量两个方面：</p>
<p>访问量：分布式消息队列服务，会随着访问量的增减而自动增减逻辑处理服务器；</p>
<p>数据量：当数据量扩大时，后端分布式存储会自动扩容。</p>
<h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><p>安全体现在以下两个方面：</p>
<ol>
<li><p>同时使用消息队列的业务之间不会互相干扰。如果有多个业务同时在使用消息队列，对于单机的消息队列服务，一个业务的消息操作可能会影响其他业务的正常运行。比如，一个业务的消息操作特别频繁，占据了消息队列的绝大部分服务时间，也占据了这台服务器的绝大部分网络IO，导致其他业务无法正常地与消息队列通信。而且甚至可能由于服务控制不当，导致机器崩溃，服务停止，业务也跟着停止。分布式消息队列则不会出现这个问题：<br>（1）监控措施完善，系统性能指数会控制在一定范围之内，而且有任何异常也会报警；<br>（2）当访问量和数据量增大时，分布式消息队列服务可以自动扩展。</p>
</li>
<li><p>各业务的消息内容是安全存储的，其他业务不能访问到非自身业务的数据。<br>一方面是业务需要密钥来访问消息队列；另一方面，消息是被加密存储的。</p>
</li>
</ol>
<h5 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h5><p>简单实用体现在：</p>
<ol>
<li>透明：接收者和发送者无需知道具体的消息队列的服务器地址，服务器的增减对接收者和发送者透明。</li>
<li>实用：对于两个服务之间不能通信的网络情况，消息队列为他们提供了恰到好处的桥梁。</li>
</ol>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/micro_service/discovery.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/micro_service/discovery.html" class="post-title-link" itemprop="url">微服务系列-服务注册与发现</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 12:03:03" itemprop="dateCreated datePublished" datetime="2022-02-25T12:03:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 22:40:41" itemprop="dateModified" datetime="2022-03-01T22:40:41+08:00">2022-03-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/micro_service/discovery.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/micro_service/discovery.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>集成：在服务提供端或者调用端，如何集成注册中心？应用内 OR 应用外</p>
<p>测活：服务注册之后，如何对服务进行测活以保证服务的可用性</p>
<p>负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？</p>
<p>运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？</p>
<p>可用性：如何保证注册中心本身的可用性，特别是消除单点故障？</p>
<p>状态获取：（1）主动探测（2）心跳上报</p>
<p>一些可能问题：</p>
<ul>
<li>保护机制：如果短时间内摘除的节点数量超过集群的40%，则停止摘除节点</li>
<li>通知风暴问题（准备更多的注册中心节点；精简通知内容）</li>
</ul>
<p>目前比较流行的解决方案包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比维度</th>
<th>euraka</th>
<th>consul</th>
<th>ZK</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现思路</td>
<td>去中心化，通过复制来同步数据，但不保证一致性。只要有一个节点可用，系统整体就可用。</td>
<td>内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案</td>
<td>使用ZK节点临时节点来维护服务器列表,ZK支持watch节点变更通知机制</td>
</tr>
<tr>
<td>测活</td>
<td>客户端心跳</td>
<td>TCP/HTTP/gRPC/Cmd</td>
<td>自研-客户端心跳</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Ribbon</td>
<td>Fabio</td>
<td>自研-负载均衡</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>有，灾难态进入自我保护模式</td>
<td>无</td>
<td>自研</td>
</tr>
<tr>
<td>自动注销实例</td>
<td>支持</td>
<td>支持</td>
<td>进程不可用，临时节点自动销毁</td>
</tr>
<tr>
<td>访问协议</td>
<td>HTTP</td>
<td>HTTP/DNS</td>
<td>自研</td>
</tr>
<tr>
<td>监听支持</td>
<td>支持</td>
<td>支持</td>
<td>WATCH NODE变更</td>
</tr>
<tr>
<td>多数据中心</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>跨注册中心同步</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>框架集成</td>
<td>SpingCloud继承</td>
<td>Spring、k8s集成</td>
<td>无</td>
</tr>
<tr>
<td>优点</td>
<td>去中心化，高可用</td>
<td>功能相对完善</td>
<td>简单容易实现，适用于初创期</td>
</tr>
<tr>
<td>不足</td>
<td>一致性差</td>
<td>可用性无保证</td>
<td>服务可用性无保障<br>ZK跨机房集群支持不佳</td>
</tr>
<tr>
<td>CAP</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>一致性协议</td>
<td>仅复制，非强一致</td>
<td>raft</td>
<td>zab，一种类paxos协议</td>
</tr>
</tbody>
</table>
</div>
<p><img src="http://cdn.b5mang.com/20201222213947.png" alt="20201222213947"></p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/micro_service/micro_service.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/micro_service/micro_service.html" class="post-title-link" itemprop="url">微服务系列-概览</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 12:01:03" itemprop="dateCreated datePublished" datetime="2022-02-25T12:01:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-01 22:17:47" itemprop="dateModified" datetime="2022-11-01T22:17:47+08:00">2022-11-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/micro_service/micro_service.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/micro_service/micro_service.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="单体到微服务"><a href="#单体到微服务" class="headerlink" title="单体到微服务"></a>单体到微服务</h4><p>为什么要转向微服务架构（收益）</p>
<ol>
<li>系统扩展性不足（例如，因为DB连接问题导致无法持续扩容）</li>
<li>迭代效率低。如果是预估到业务在飞速增长，那就别犹豫，一定要提前考虑微服务的拆分。</li>
<li>系统编译、部署成本高</li>
<li>如果在设计架构的时候，发现需要很多异构的技术栈，那也要考虑下微服务。</li>
</ol>
<p>转向微服务架构需要克服什么困难（成本）</p>
<ol>
<li>技术基础设施要求比较高（如果公司技术基础设施非常完备，对应的业务起初就设计的非常复杂，那么也别犹豫，起手就上微服务。）</li>
<li>工程拆分挑战比较大，实现时容易为了拆分而拆分。</li>
</ol>
<h4 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h4><p>从单体到微服务，也许可以有一个过度：工程的拆分</p>
<p>微服务拆分的大原则</p>
<ol>
<li>单一服务内的高内聚、低耦合，单一职责</li>
<li>拆分粒度：先粗拆，后细拆（伴随业务复杂度的变多，或者对业务的理解程度加深）</li>
<li>拆分过程中，要避免影响业务的日常功能迭代—按照依赖顺序，挨个拆分</li>
<li>确保服务接口定义有可扩展性</li>
<li>避免环形依赖问题（通过分层，例如业务层、数据访问层）</li>
</ol>
<p>业务优先，组织结构，质量维度</p>
<p>SRP Single Responsibilty 单一指责原则<br>CCP Common Closure Principle 共同闭包原则，包中包含的所有类应该是同类的变化的一个集合，也就是说，如果对包作出修改，需要调整的类应该都在这个包之内。</p>
<p>你的团队成员结构是什么样的，你的架构就会长成啥样。</p>
<p>团队按照业务边界来拆分；确保团队不要太大</p>
<p>因为微服务就是为了减少研发成本，而包括沟通成本。</p>
<p>服务拆分带来的问题</p>
<ol>
<li>接口调用耗时增加</li>
<li>如何知道调用哪个服务？服务注册中心</li>
<li>服务治理体系：熔断、限流、降级、超时控制等</li>
<li>问题排查困难（分布式链路追踪）</li>
</ol>
<h4 id="微服务组件"><a href="#微服务组件" class="headerlink" title="微服务组件"></a>微服务组件</h4><h5 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h5><p>入口网关：隔离客户端与微服务，协议转换、安全策略、认证、限流、熔断等</p>
<p>出口网关：调用外部API，统一认证，授权、授权、访问控制等</p>
<p>性能：IO多路复用、异步非阻塞、线程池</p>
<p>设计要点：性能、扩展性（责任链模式）</p>
<p>隔离性：针对接口对线程池进行分类</p>
<h5 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h5><p>zookeeper, consul, euraker</p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>RoundRobin, Hash, Weight</p>
<h5 id="熔断、限流"><a href="#熔断、限流" class="headerlink" title="熔断、限流"></a>熔断、限流</h5><h5 id="配置实时下发"><a href="#配置实时下发" class="headerlink" title="配置实时下发"></a>配置实时下发</h5><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>配置项的读取-变更推送如何实现：</p>
<ol>
<li>轮询 + 摘要 （简单，实时性略差）</li>
<li>长轮询 + 版本号（复杂，实时性好一些）</li>
</ol>
<p>client的高性能实现逻辑：</p>
<ol>
<li>DoubleBufferedData， 数据分前台和后台</li>
<li>读拿到自己所在线程的thread-local读写锁，执行查询逻辑后释放锁。</li>
<li>同时只有一个写：修改后台数据，切换前后台，挨个获得所有thread-local锁并立刻释放，结束后再改一遍新后台（老前台）。</li>
</ol>
<p>一个小原则：配置系统的旁路化，不要因为配置系统挂了，你的程序启动不了；<br>可以做两层缓存：内存缓存、文件保存</p>
<h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><p>不同的配置类型：节点类型 》机房类型 》 全局配置</p>
<p>配置项的存储-配置系统的高可用</p>
<p>核心指标在于可用性！！！5个9？</p>
<h5 id="对接调用链追踪-（Jager"><a href="#对接调用链追踪-（Jager" class="headerlink" title="对接调用链追踪 （Jager)"></a>对接调用链追踪 （Jager)</h5><p>trace_id + span_id来标识链路的调用关系。</p>
<p>对trace_id采样，而不要随机采样。</p>
<p>span 基本工作单元，一次链路调用（可以是RPC，DB等没有特定的限制）创建一个span，通过一个64位ID标识它，uuid较为方便，span中还有其他的数据，例如描述信息，时间戳，key-value对的（Annotation）tag信息，<strong>parent_id</strong>(基于parent_span_id来维护树形结构）等,其中parent-id可以表示span调用链路来源。</p>
<p>trace_id 类似于 树结构的Span集合，表示一次完整的跟踪，从请求到服务器开始，服务器返回response结束，跟踪每次rpc调用的耗时，存在唯一标识trace_id。比如：你运行的分布式大数据存储一次Trace就由你的一次请求组成。</p>
<p>Annotation 注解，用来记录请求特定事件相关信息（例如时间），一个span中会有多个annotation注解描述。通常包含四个注解信息：</p>
<h5 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h5><p><img src="http://cdn.b5mang.com/2021320212041.png" alt="监控哪些内容"></p>
<p><img src="http://cdn.b5mang.com/2021320212155.png" alt="监控系统架构"></p>
<p>方案：普罗米修斯、Graphna</p>
<p>APM：端到端的监控体系</p>
<p>如何防止消息被篡改：对消息体 + 消息头 进行加密，生成一个签名<br>如何对数据进行加密：</p>
<p>使用非对称加密的公钥对 “对称加密的私钥-OriginPrivate“ 进行加密，得到SecretPrivate<br>然后服务端利用非对称加密的私钥，对 SecretPrivate进行解密，得到OriginPrivate</p>
<p>然后再使用OriginPrivate对加密之后的消息体（SecretContext)进行解密，得到Contenxt</p>
<p>监控哪些东西：网络卡顿率、做某件事情的失败率等</p>
<p>考虑暂存 + retry来应对网络状况不佳的情况</p>
<h5 id="自动化全链路压测系统"><a href="#自动化全链路压测系统" class="headerlink" title="自动化全链路压测系统"></a>自动化全链路压测系统</h5><p>压测的原则-尽量模拟真实情况；压测的注意点：<br>（1）使用线上数据与线上数据<br>（2）使用线上流量（流量拷贝）<br>（3）流量应该从尽量靠近用户的CDN发起</p>
<p>如何搭建：<br>（1）流量的隔离（区分压测流量与正式流量）<br>（2）风险控制（尽量避免压测对正常用户的影响）</p>
<p><img src="http://cdn.b5mang.com/2021320214129.png" alt="自动化全链路压测系统"></p>
<p>压测数据的产生：<br>  拷贝真实流量（可以从访问日志、可以抓取某个端口的数据等）<br>  打上压测标签<br>  放在合适的机房（尽量接近用户）<br>数据隔离：<br>  针对读请求，针对某些不能压测（例如推荐、数据分析等）的组件进行mock<br>  对于写请求，把流量产生的数据写入影子库（数据库-拷贝一份库表和数据；缓存-加压测前缀；ES-多搞一份索引）<br>压力测试的实施<br>  持续放大，做好系统过载的识别（例如超时率、resp time等）</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/server/breaker/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/server/breaker/index.html" class="post-title-link" itemprop="url">高性能服务器设计-熔断模型</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 11:56:03" itemprop="dateCreated datePublished" datetime="2022-02-25T11:56:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 22:43:15" itemprop="dateModified" datetime="2022-03-01T22:43:15+08:00">2022-03-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/server/breaker/index.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/server/breaker/index.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="熔断简单说明"><a href="#熔断简单说明" class="headerlink" title="熔断简单说明"></a>熔断简单说明</h2><p>在分布式系统中，一次完整的请求可能需要经过多个服务模块的调用，请求在多个服务中传递，服务对服务的调用会产生新的请求，这些请求共同组成了这次请求的调用链。当调用链中的某个环节，特别是下游服务不可用时，将会导致上游服务调用方不可用，最终将这种不可用的影响扩大到整个系统，导致整个分布式的不可用，引起服务雪崩现象。</p>
<p>为了避免这种情况，在下游服务不可用时，保护上游服务的可用性显得极其重要。对此我们可以通过熔断的方式，通过及时熔断服务调用方和服务提供方的调用链，保护服务调用方资源，防止服务雪崩现象的出现。</p>
<p>使用服务熔断，能够有效地保护服务调用方的稳定性，它能够避免服务调用者频繁调用可能失败的服务提供者，防止服务调用者浪费cpu、线程和IO资源等，提高服务整体的可用性。</p>
<p>所以，熔断设计的目的是在服务提供方不可用时保护服务调用方的资源，减少服务调用中无用的远程调用。</p>
<h2 id="常见熔断策略"><a href="#常见熔断策略" class="headerlink" title="常见熔断策略"></a>常见熔断策略</h2><h3 id="google-SRE-自适应熔断"><a href="#google-SRE-自适应熔断" class="headerlink" title="google SRE 自适应熔断"></a>google SRE 自适应熔断</h3><p>基于失败率</p>
<p>drop_ratio = $max(0, （requests - K * accepts） / (requests + 1))$</p>
<p>算法参数：</p>
<ul>
<li>requests：窗口时间内的请求总数</li>
<li>accepts：正常请求数量</li>
<li>K：敏感度，K 越小越容易丢请求，一般推荐 1.5-2 之间</li>
</ul>
<p>算法解释：</p>
<ul>
<li>正常情况下 requests=accepts，所以概率是 0。</li>
<li>随着正常请求数量减少，当达到 requests == K* accepts 继续请求时，概率 P 会逐渐比 0 大开始按照概率逐渐丢弃一些请求，如果故障严重则丢包会越来越多，假如窗口时间内 accepts==0 则完全熔断。</li>
<li>当应用逐渐恢复正常时，accepts、requests 同时都在增加，但是 K*accepts 会比 requests 增加的更快，所以概率很快就会归 0，关闭熔断。</li>
</ul>
<h3 id="brpc熔断策略"><a href="#brpc熔断策略" class="headerlink" title="brpc熔断策略"></a>brpc熔断策略</h3><p>在开启了熔断之后，CircuitBreaker会记录每一个请求的处理结果，并维护一个累计出错时长，记为acc_error_cost，当acc_error_cost &gt; max_error_cost时，熔断该节点。</p>
<p>两个小技巧：</p>
<ol>
<li>利用EMA（移动平均值）策略计算接口的平均响应时间</li>
<li>利用双时间窗口统计来平衡短期抖动与长期错误率过高；</li>
</ol>
<p>具体见：<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/circuit_breaker.md">CircuitBreaker</a></p>
<h3 id="netflix-断路器"><a href="#netflix-断路器" class="headerlink" title="netflix 断路器"></a>netflix 断路器</h3><p><img src="https://img-blog.csdnimg.cn/20201201181047280.png" alt="熔断器策略"></p>
<p>三种断路器状态：关闭、打开、半开</p>
<p>最近一段时间内的错误率 = 错误数 / 总数</p>
<p>最近一段时间内的错误数与总数，通过<strong>滑动窗口</strong>来实现，而滑动窗口又通过<strong>环形队列</strong>来实现。</p>
<p>错误率超过多少，则进入打开状态，持续一段时间。</p>
<p>持续一段时间后，进入半开状态，允许定量的请求通过，如果成功的比例足够大，则进入关闭状态，否则重新加入打开状态。</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/parallel/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/parallel/index.html" class="post-title-link" itemprop="url">并行算法 - 概览</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 11:31:03" itemprop="dateCreated datePublished" datetime="2022-02-25T11:31:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 22:42:17" itemprop="dateModified" datetime="2022-03-01T22:42:17+08:00">2022-03-01</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/parallel/index.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/parallel/index.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>并行排序（并行归并排序、并行快速排序）</p>
<p>并行查找（并行的散列表，随机分为K份）</p>
<p>并行字符串匹配（任何算法都可以，只是分割后，需要补上2m个char）</p>
<p>并行搜索（对于BFS，使用两个队列，循环使用）</p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.fpthinker.com/backend_knowledge_architecture/os/sync.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="NeoWei">
      <meta itemprop="description" content="我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <#meta itemprop="name" content="Neo's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/backend_knowledge_architecture/os/sync.html" class="post-title-link" itemprop="url">操作系统 - 线程同步</a>
        </h2>

        <div class="post-meta">

	
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 11:12:03" itemprop="dateCreated datePublished" datetime="2022-02-25T11:12:03+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-30 21:10:19" itemprop="dateModified" datetime="2022-10-30T21:10:19+08:00">2022-10-30</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/backend_knowledge_architecture/os/sync.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/backend_knowledge_architecture/os/sync.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多线程问题的本质：有序性，可见性，原子性</p>
<p>我们处理线程安全可以有几个层次：</p>
<ol>
<li>能否做成无状态的不变对象。无状态是最安全的。</li>
<li>能否线程封闭<br>（1）栈封闭，多采用局部变量<br>（2）线程局部存储（用空间换性能）<br>（3）程序控制线程封闭（Hash，将同一hash val的的请求丢给同一个线程去处理）</li>
<li>采用何种同步技术</li>
</ol>
<h4 id="多线程同步的方式"><a href="#多线程同步的方式" class="headerlink" title="多线程同步的方式"></a>多线程同步的方式</h4><p>线程同步</p>
<p>多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就是在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒;<br>（在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。）</p>
<p>(1) 信号量 semphore</p>
<p>(2) 共享内存 shared_memory</p>
<p>(3) 读写锁 rw_lock</p>
<p>(4) 条件变量 condition</p>
<p>线程间存在依赖</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/edb8f67325ff3f693d58f635eeff9650.jpeg" alt="条件变量的使用"></p>
<p>(5) 互斥量 mutex</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。</p>
<ol>
<li>临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</li>
<li>互斥量：为协调共同对一个共享资源的单独访问而设计的。</li>
<li>信号量：为控制一个具有有限数量用户资源而设计。</li>
<li>读写锁</li>
</ol>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。如果等待的时间比较短，适合使用自旋锁，占用大量的CPU资源</p>
<h4 id="锁的实现机制"><a href="#锁的实现机制" class="headerlink" title="锁的实现机制"></a>锁的实现机制</h4><p>在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制。</p>
<h4 id="禁中断"><a href="#禁中断" class="headerlink" title="禁中断"></a>禁中断</h4><p>既然只有中断才能把上锁过程打断，造成多线程操作失败。我先关中断不就得了，在加锁操作完成后再开中断。</p>
<h4 id="普通的原子指令"><a href="#普通的原子指令" class="headerlink" title="普通的原子指令"></a>普通的原子指令</h4><p>上面这个手段太笨重了，能不能硬件做一种加锁的原子操作呢？能，大名鼎鼎的“test and set”指令就是做这个事情的。</p>
<h5 id="锁内存总线-原子指令"><a href="#锁内存总线-原子指令" class="headerlink" title="锁内存总线 + 原子指令"></a>锁内存总线 + 原子指令</h5><p>通过上面的手段，单核环境下，锁的实现问题得到了圆满的解决。</p>
<p>那么多核环境呢？简单嘛，还是“test and set”不就得了，这是一条指令，原子的，不会有问题的。</p>
<p>真的吗，单独一条指令能够保证该指令在单个核上执行过程中不会被中断打断，但是两个核同时执行这个指令呢？。。。</p>
<p>我再想想，硬件执行时还是得从内存中读取lock，判断并设置状态到内存，貌似这个过程也不是那么原子嘛。对，多个核执行确实会存在这个问题。怎么办呢？首先我们得明白这个地方的关键点，关键点是两个核会并行操作内存而且从操作内存这个调度来看“test and set”不是原子的，需要先读内存然后再写内存，如果我们保证这个内存操作是原子的，就能保证锁的正确性了。</p>
<p>确实，硬件提供了锁内存总线的机制，我们在锁内存总线的状态下执行test and set操作，就能保证同时只有一个核来test and set，从而避免了多核下发生的问题。</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><ol>
<li>无锁算法的底层实现 — CAS</li>
<li>借助内存访问WORD的原子性</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://jm.taobao.org/2011/12/07/1347/">http://jm.taobao.org/2011/12/07/1347/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/heiyeshuwu/article/details/9722443">https://blog.csdn.net/heiyeshuwu/article/details/9722443</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/jing99/p/11984966.html">https://www.cnblogs.com/jing99/p/11984966.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.qbitai.com/2019/12/9895.html">https://www.qbitai.com/2019/12/9895.html</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/d585b3938dea">https://www.jianshu.com/p/d585b3938dea</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/ITer_ZC/article/details/40392787">https://blog.csdn.net/ITer_ZC/article/details/40392787</a></p>

      
    </div>

    
    
    

    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



		  </div>
		  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

		  

		</div>
        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">NeoWei</p>
  <div class="site-description" itemprop="description">我是一名服务端程序员，热衷于第一性原理，会在该博客中不定期分享自己关于后端服务、计算机系统乃至世界本质的思考，望多多交流！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">343</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>



    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NeoWei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a>
  </div>

<br>
<a href="https://beian.miit.gov.cn/" rel="external nofollow noreferrer"  style="color:#f72b07" target="_blank">沪ICP备2020030798号-1</a>
<br>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1279618438&web_id=1279618438"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>

<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uE8T6jDhH4vW6BtH143y72nw-gzGzoHsz',
      appKey     : '3xulfIcqN5mLqRSxptxvnamK',
      placeholder: "Just go go",
      avatar     : 'identicon',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
