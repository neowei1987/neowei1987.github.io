[{"title":"协程","url":"/backend_knowledge_architecture/server/io_model/co.html","content":"\n## 0. 协程优缺点\n\n协程是使用同步的编程思想，达到异步的效率\n\n核心点：\n\n1.使用异步IO未就绪，就切换到已经准备就绪的IO去操作\n解决了异步代码逻辑复杂，同步效率低的问题，效率接近异步\n\n2.协程的栈可以设置比线程更小，使得更加容易\n\n解决了线程占用栈空间更大的问题，硬件的使用率更高，同异步的效率，硬件成本会更低\n\n3.线程的创建代价和调度代价相对比较高\n\n缺点 ：\n\n1. 缺点是无法利用多核资源，本质是单核的，它不能同时将单个CPU的多个核用上，协程需要和进程配合才能运行在多CPU上。\n2. 跨平台性挑战较大\n\n<!-- more -->\n\n有栈协程 与 无栈协程\n\n这篇文章可以看看\nhttps://www.zhihu.com/question/568012609/answer/2768851451\n\n参考：\n\nhttps://zhuanlan.zhihu.com/p/330606651\nhttps://blog.csdn.net/carlclouder/article/details/126048486","tags":["知识体系"]},{"title":"惊群现象","url":"/backend_knowledge_architecture/server/io_model/thundering.html","content":"\nA、accept 惊群\n以多进程为例，在主进程创建监听描述符listenfd后，fork()多个子进程，多个进程共享listenfd，accept是在每个子进程中，当一个新连接来的时候，会发生惊群。\n\n在内核2.6之前，所有进程accept都会惊醒，但只有一个可以accept成功，其他返回EGAIN。\n\n在内核2.6及之后，解决了惊群问题，办法是在内核中增加了一个互斥等待变量。一个互斥等待的行为与睡眠基本类似，主要的不同点在于：\na）当一个等待队列入口有 WQ_FLAG_EXCLUSEVE 标志置位, 它被添加到等待队列的尾部。若没有这个标志的入口项，则添加到队首。\n\nb）当wake up被在一个等待队列上调用时,它在唤醒第一个有 WQ_FLAG_EXCLUSIVE 标志的进程后停止。\n执行步骤：\n对于互斥等待的行为，比如对一个 listen 后的socket描述符，多线程阻塞 accept 时，系统内核只会唤醒所有正在等待此时间的队列的第一个，队列中的其他人则继续等待下一次事件的发生。这样就避免的多个线程同时监听同一个socket描述符时的惊群问题。\n\nB、epoll惊群\nepoll惊群分两种：\n\na)是在fork之前创建 epollfd，所有进程共用一个epoll。\n\nb)是在fork之后创建 epollfd，每个进程独用一个epoll。\n\na)fork之前创建epollfd(新版内核已解决)\n\n主进程创建 listenfd，创建epollfd;\n\n主进程 fork多个子进程;\n\n每个子进程把listenfd，加到epollfd 中。\n\n当一个连接进来时，会触发epoll惊群，多个子进程的epoll同时会触发。\n\n这里的epoll惊群跟 accept 惊群是类似的，共享一个 epollfd，加锁或标记解决，在新版本的epoll中已解决，但在内核2.6及之前是存在的。\n\nb)fork之后创建epollfd(内核未解决)\n\n主进程创建 listendfd;\n\n主进程创建多个子进程;\n\n每个子进程创建自已的epollfd;\n\n每个子进程把listenfd加入到epollfd中;\n\n当一个连接进来时，会触发epoll 惊群，多个子进程epoll同时会触发。\n\n因为每个子进程的epoll是不同的epoll, 虽然listenfd是同一个，但新连接过来时,accept会触发惊群。因为内核不知道该发给哪个监听进程，因为不是同一个epoll。所以这种惊群内核并没有处理，惊群还是会出现。\n————————————————\n版权声明：本文为CSDN博主「84岁带头冲锋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/L2111533547/article/details/125982204","tags":["知识体系"]},{"title":"成为一个出色的工程师，做到这几点就够了","url":"/pro_skill/better.html","content":"\n本文我们探讨如何成为一个出色的工程师？\n\n按照SKA模型，我的答案会分为三大块：\n\n- 第一，正确的态度(Attitude)或者思维方式。\n  当遇到问题时，你会用什么样的态度去应对处理它？当你尝试去解决一个问题时，你又是如何思考的？\n- 第二，尽可能娴熟的必要技能(Skill)。\n  当你知晓了如何去思考问题之后，我们需要借助很多技能去把问题解决。例如，沟通协作技能、编程能力、问题排查能力等。\n- 第三，尽可能完备的知识(Knowledge)体系。\n  很多时候有些人知道问题的答案或者解决方案,仅仅是由于他知道一块我们不知道的知识。\n\n<!-- more -->\n## 态度 & 思维方式\n\n### 清晰的价值观\n\n首先，你应该明晰你的价值观，确保与领导或者公司的价值观保持一致。尝试着回答以下这些问题：\n你的价值观如何？ 你如何看待你现在这份工作？或者说你如何看待这份工作打给你的价值？ 相对你付出的诸多成本（时间成本、各种机会成本），价值是不是足够大？\n\n我个人对工作的看法：\n\n- 于私，工作给我提供了足够多的机会，去打磨我的心智（例如工作中会遇到一些挫折，我们需要应对！），去强化我的技能（例如大型合作项目，需要去跟别人协作沟通），去完善自己的知识体系（通过对工作内容的反思、总结、分享，将经验内化为知识）\n- 与公，工作是一个媒介，我通过工作给公司创造价值。我给公司带来的业务价值的多少，直接决定了公司对我的价值定位，进而决定了自己的职位与薪酬。\n\n综上，你是否会呆在一个公司，直接取决于：公司带给我的收益 与 我付出的成本 的**平衡**\n\n- 公司能够带给我的收益：我的薪资收入（我给公司带来的价值；公司本身、行业甚至国家对公司的影响；公司管理者的员工价值观等）、无形收益（影响力、荣誉感）、工作带给我的能力提升\n\n- 我付出的成本：我付出的时间成本、我放弃的机会成本（新工作带给你的收益 - 跳槽的机会成本）\n\n综上，我们可以把价值观比喻为：\n\n- 定海神针（你明确了自己为什么在这，明确了公司可以带给你什么，才能够不轻易为外部所动）\n- 决策价值的标尺（做决策一定会涉及到价值的考量，价值观不同的人做出的决策一定是不同的）\n- 做事目标的指北针（以终为始，做事情一定得先有目标。价值观作为目标制定的指北针，确保目标与**真正有价值的目标**不背道而驰）\n\n### 强大的责任心\n\n在职场很多年，你肯定遇到下面这些场景，当时的你是怎么处理这些事情的呢？\n\n- 当你负责的服务有告警时\n- 当你们团队的服务有告警时\n- 当别人咨询了你一个并不是你负责的模块的问题时\n- 当客服群有人反馈你所负责的业务有bug时\n\n责任从哪里来，责任源于角色。你身处团队之中，你是团队的角色之一，所以你在你的团队中有责任。而你的责任心则直接决定了你如何看待你的责任，看待你的“份外之事”，看待超越你职责范围内的工作。\n\n自己可能负责哪些东西：\n\n- 老板分配给你，让你跟进的问题、让你owner的业务项\n\n  有始有终，借助PDCA循环把老板交代给你的问题做好。\n  \n- 你负责的业务模块\n\n  需要非常熟悉模块的内部细节、外部协作细节、后续迭代优化方向等；如果对自己负责的模块不是最熟悉的话，是严重不负责任的表现。\n  \n- 你负责的业务\n\n  除了完成PM交代给自己的业务需求外，我们还需要积极思考业务的本质、业务在公司的定位、公司在行业的定位等，主动为消费者负责、为社会负责、为业务负责，为公司负责。\n\n能力（技术能力）与责任心谁更重要呢？\n\n都重要。如果一个新人有培养的潜力，那么责任心就更重要。两个人，第一个技术能力很强，但责任心很差，对项目的事情也不上心；第二个能力差些，但责任心强，是自己的问题一定负责到底，即使自己不能解决也能主动询求帮助。我觉得前者对项目的危害更大，特别是项目紧要时期，因为能力强的人一般负责的是比较复杂、困难的功能，别人上手也需要时间，这个时候如果摞担子，bug也不修，那么就很为难了。\n\n不负责任的典型表现就是扯皮、甩锅：这不是我的bug、不关我的事。有协作的地方更容易出现问题，比如前端与后端、各个部门之间。\n一个有强大责任感的人，会主动承担灰色地带。如果不清楚到底是谁的问题，也会很主动的帮助排查、跟进。\n\n### 强烈的好奇心\n\n有知发现无知，无知求索真知。好奇心是“有知者”探索未知世界的原动力，是创造性人才的特质，是成为出色工程师的必要条件。\n\n当你调试代码跟踪到框架底层的时候，你是否有动力继续深入下去，看看框架是怎么实现的？\n\n当你听到协程有多牛B、多好用时，你是否想知道它到底应该如何实现？\n\n当你学习操作系统学习到虚拟内存、物理内存时，你是否想去深入了解Linux可能会如何管理内存，缺页中断是怎么回事？\n\n当你从PM那边接收到一个产品需求的时候，你会不会去思考这个需求的底层原理是什么？它是为了解决那些用户的什么问题？\n\n如果没有好奇心的驱使，你永远只是一个普通的程序员，永远只会是一个CRUD BOY。\n强烈的好奇心，会驱使你去了解事物的本质；在了解本质的路上，你有机会发现更多；了解更多的案例，获取更多的经验，归纳演绎出更多接近事物本质的知识。\n\n### 出色的工程师思维\n\n什么是工程师思维呢？在我看来，工程师思维是通过计算机来解决现实问题的一系列思维方式和方法的汇总：\n\n- 不安于现状，讨厌单调的重复工作\n\n  例如每天都要执行多次的诸多命令，考虑写一个批处理脚本？\n  \n- 经典的计算机与数据结构、算法思维\n\n  TradeOff思想、空间换时间思想、局部性原理、COW思想、二分思想、分治思想、回溯思想等\n  \n- 永远乐于去寻求问题的最优解\n\n  程序代码、服务架构的极至优化\n  \n- 从信息的角度去解决现实问题\n\n  首先尝试用常人的思维去剖析问题，尽量触及问题的本质；然后把问题的解决抽象为信息的传递与处理。\n  你的问题的了解越深入，得到的信息处理模型便更加接近“真理”，写出来的代码也更具扩展性。\n\n### 高效能人士的几种思维方式\n\n高效能人士应该有的几种思维方式：\n\n- 积极主动：\n- 以终为始\n- 要事第一\n- 双赢思维\n- 知彼解己\n- 统合综效\n- 不断更新\n\n### 用跨界思维重新审视问题\n\n通过前面提到的工程师思维，自然可以相对优雅地解决某一个既定问题。\n\n但是这个问题本身合理吗？这个问题的解决会给用户或者说给社会带来多少价值呢？\n\n要回答上面这两个问题，你就算有再出色的工程师思维都没有用，我们只有跳出某个既定的圈子（我们的工程师思维会给我们的思维圈上一个圈），从更高的层次去重新审视问题，才有可能给出比较理想的答案。\n\n![跨界思维](http://cdn.b5mang.com/202151015576.png)\n\n下面是一些我个人觉得比较重要的跨界思维，供参考：\n\n- 物理学思维\n\n  每一个封闭的知识系统的结论都是在一些基础假设的基础上通过逻辑推理演绎出来的。\n  我们将这个基础假设叫做这个系统的基石假设。将这种不断地刨根问题去问为什么的思考方式，称之为第一性原理思维。\n  \n- 系统动力学思维\n\n  “普通的人改变结果，优秀的人改变原因，顶级优秀的人改变模型。”\n  \n  洞察力：透过现象看本质、然后改变模型的能力。通过学习系统动力学，可大幅提升自己对事物的洞察力。\n  \n  在系统论中，系统 = 关键要素（又叫变量） + 要素之间的连接（又叫关系）\n  \n  变量：增量改变存量，存量改变世界\n  \n  连接：关键因果链、正反馈回路、负反馈回路、滞后效应\n  \n- 复杂性系统思维\n\n  熵增定律：热力学第二定律，从有序到无序。\n  \n  耗散系统：开放系统，通过与外界交换来对抗熵增。\n  \n  自组织系统：涌现\n  \n  分型系统：自相似\n  \n- 哲学思维\n  亚里士多德四因说 - 质料因：为什么事物在运动中持存；形式因：为什么事物运动具有特定的方式；动力因：为什么事物开始运动；目的因：为什么事物要运动。\n  \n  整体论 VS 还原论（组合创新的思维起点）\n  \n  归纳与演绎\n  \n  批判性思维\n  \n- 心理学思维\n\n  马洛斯需求模型\n  \n  诸多偏见、不理性\n  \n- 数学思维(数学带给我们的一些启发)  \n\n  公理化思维，欧氏几何，基于5大公理，演绎出整个几何大厦\n  \n  抽象思维，从具体的数字到抽象的函数\n  \n  从特例到普遍，从标量到向量再到更具有普适性的矩阵\n  \n  本质思维，函数的本质是什么？ 矩阵的本质是什么？\n  \n  极限思维，从有限到无限，从无穷大到无穷小，从最初量的变化到最终质的变化\n  \n  变化延迟效应，从加速度（距离的二阶导数）到速度（距离的一阶导数）再到距离，变化的延迟发生，事情造成影响的滞后性\n  \n  博弈思维，从零和博弈到非零和博弈，从双赢到双输\n  \n  概率思维，某种程度上概率的反直觉性；常见的概率分布模型：二项分布、正态分布、泊松分布等\n  \n- 互联网思维\n\n  互联网的本质：从本质上看，其实互联网并不产生实质上的经济，而它做的只是让信息更快、更便捷地流通，从而帮助实体的资源更快、更便捷地流通和兑换，减少了成本和加速资金流动。\n  \n  互联网产品的本质：核心能力是资源整合，寻找事物存在的优化空间 VS 实体产品\n  \n- 产品思维（想象自己是一个PM）\n\n  思考做产品要解决的根本问题：从更人性化的角度去帮助用户识别和解决问题，从而给用户创造价值。\n  \n  整合现有市场的资源（或者寻找需求）根据产品定位做好相应配套和流程优化\n  \n- 运营思维（想象自己是一个互联网运营）\n\n  产品运营的核心目标：告诉所有人（或目标人群）产品的价值；\n  \n  优化宣传渠道，尽量减少对用户的骚扰，在用户最需要你产品的时候看到你，想到你；\n  \n  提升产品利润和用户流量及产品的转化率；\n  \n  优化运营管理，让用户能即时反馈问题；\n  \n  减少宣传销售成本；\n  \n  了解用户使用产品中的难题，帮助提成产品的体验和品质。\n  \n  思考做运营要解决的根本问题：如何花更少的钱去做更多的事情\n  \n- 经济学思维（想象自己是一个理性经济人）\n\n  成本与收益思维，ROI投产比\n  \n  成本思维，考虑成本时考虑要额外考虑时间成本、机会成本\n  \n  如何看待效率与公平\n  \n  优势与分工\n  \n- 金融思维（想象自己是一个银行家或者投资人）\n\n  借债产生利息，导致破产轻松 VS 技术债导致维护成本，导致重构\n  \n  储蓄产生资本积累，导致增长 VS 定期进行重要的技术重构\n  \n- 商业思维（想象自己是一个企业家）\n\n  企业的护城河 VS 个体或者团队的不可替代性\n\n## 技能\n\n这里我把技能分为两大类：通用技能、专业技能\n\n先说工程师的专业技能\n\n- 需求的理解与编码实现能力\n\n  1. 深入理解需求，梳理出需求涉及到的存储与外部交互方\n  2. 输出数据流图，搞清楚数据流与信息流的流向\n  3. 以存储为中心，对系统进行模块划分，如有必要引入缓存、分库分表、异步等性能优化手段\n  4. 编码实现\n\n- 问题排查能力：当自己的负责的业务出现问题（用户反馈，或者有监控告警）时，有能力尽快对问题进行止损、排查定位、修复\n\n  1. 掌握必要的知识：操作系统提供了哪些工具，这些工具分别可以用来定位哪一类问题？\n  2. 掌握必要的知识：问题根本原因的分类：代码逻辑bug、IO异常（容量不足、硬件故障？）\n  3. 优先考虑回滚止损（是否新发布了代码、上游流量是否有增加、下游依赖吞吐量是否发生变化等）\n  4. 借助日志、抓包等工具，对问题的发生范围进行二分定位（上游、服务本身、下游）\n  5. 重复步骤4），直到定位到问题的根因，然后问题修复（扩容、修复逻辑bug、更换硬件等）\n  6. 事后问题复盘\n\n- 优秀的编码能力&编码习惯：高性能、可扩展好、可维护性强\n\n  1. 带着工程师思维去编码（代码的本质在于：它对信息进行加工，这里的加工包括：反序列化、追加额外的信息、信息格式转换、删除额外的信息、把信息通过容器管理起来、序列化）\n  2. 建立公司、团队统一的编码规范\n  3. 掌握必要的知识：设计模式、面向对象编程、表格式编程等\n  4. 结对编程，用更高的标准去互相review，相互提高\n  5. 两点认知：一般情况下，代码越少，便越容易理解。当代码可理解性与代码性能有冲突时，一般情况下，选择可理解性；底层高频代码除外。\n\n- 架构设计能力\n\n  1. 微观上，去学习一些底层系统的设计思路，例如操作系统、数据库、Redis、MC、Nginx等\n  2. 宏观上，去了解更多的分布式海量系统设计思路，例如搜索、Feed、Hadoop、分布式存储、评论系统、ID生成器等\n  3. 借助项目给予自己的机会去练习、实践上面学到的设计技巧\n\n然后再说说普通工程师的通用技能\n\n- 沟通表达能力\n\n  沟通的本质：建立你与待沟通对象的沟通**通道**，把需要沟通的**内容**传递给对方（并影响对方），从而达到自己的沟通的**目的**\n  \n- 团队协作能力\n\n  对于普通个体而言，团队协作的能力一般表现为与团队内其他个体的沟通表达能力\n  \n  区分事实与观点\n  \n- 快速学习能力\n\n  库博学习圈：从行动归纳出经验，从经验升华为规律，用规律来指导行动。\n  \n- 时间管理能力\n\n  紧急重要四象限、收益影响四象限\n  \n- 事项管理能力\n\n  Get Things Done: 事务的收集、处理、回顾\n\n最后说说核心/骨干工程师需要的通用技能\n\n- 跨团队协作能力\n\n  同理心、影响力、双赢思维\n  \n- 谈判能力\n\n  在公司内部，更多的需要的是团队协作能力\n  \n- 目标管理能力\n\n  OKR对组织目标进行拆解、SMART原则、KPI量化指标\n  \n- 演讲能力，不是你在讲，而是他在听\n\n  1. 按照人的思考线索，而不是知识的树状结构来演讲\n  2. 无可否认的事实 + 无可辩驳的逻辑\n  3. 用幽默感，让认知的路上满是风景\n\n## 知识\n\n这里提到的知识，我们也分为两类：前人总结的知识、自己沉淀总结的知识\n\n- 前人总结的知识\n  \n  前人总结的知识，可以参考[个人博客](http://www.b5mang.com/knowledge.html)\n\n  为什么需要学习那么多的知识呢？知识变来变去，但万变不离其宗。系统设计时，确实是有很多套路可循的。这些套路就出自前人之手。\n\n- 自己沉淀总结的知识\n\n    1. 首先你需要有一种意识：我对之前那种低效的重复工作厌倦了，我想要提升效率。我相信其他人肯定也会有这种诉求。\n    2. 你需要准确的去描述你要去解决的问题（抽象问题本质的能力）\n    3. 借助搜索引擎去检索自己的问题\n    4. 总结，内化成自己的知识经验\n    5. 分享给大家\n"},{"title":"网络知识之NAT","url":"/backend_knowledge_architecture/network/devices.html","content":"\n## 0. NAT简介\n\nNAT(Network Address Translation ，网络地址转换) 是一种广泛应用的解决IP 短缺的有效方法， NAT 将内网地址转和端口号换成合法的公网地址和端口号，建立一个会话，与公网主机进行通信。\n\n<!-- more -->\n\n### 1. 路由器\n\n路由器（Router)工作在**第三层（即网络层）**，它比交换机还要“聪明”一些，它能理解数据中的IP地址，如果它接收到一个数据包，就检查其中的IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。\n\n与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。\n\n例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。当IP子网中的一台主机发送IP分组给同一IP子网的另一台主机时，它将直接把IP分组送到网络上，对方就能收到。而要送给不同IP于网上的主机时，它要选择一个能到达目的子网上的路由器，把IP分组送给该路由器，由路由器负责把IP分组送到目的地。\n\n如果没有找到这样的路由器，主机就把IP分组送给一个称为“缺省网关（default gateway）”的路由器上。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。\n\n网络中的设备用它们的网络地址（TCP／IP网络中为IP地址）互相通信。IP地址是与硬件地址无关的“逻辑”地址。目前TCP／IP网络，全部是通过路由器互连起来的，Internet就是成千上万个IP子网通过路由器互连起来的国际性网络。\n\n路由器用于连接多个逻辑上分开的网络，几个使用不同协议和体系结构的网络。路由器利用网络层定义的“逻辑”上的网络地址（即IP地址）来区别不同的网络，实现网络的互连和隔离，保持各个网络的独立性。\n\n当一个子网传输到另外一个子网时，可以用路由器完成。它具有判断网络地址和选择路径的功能，过滤和分隔网络信息流。一方面能够跨越不同的物理网络类型（DDN、FDDI、以太网等等），另一方面在逻辑上将整个互连网络分割成逻辑上独立的网络单位，使网络具有一定的逻辑结构。\n\n总结：路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。路由器的基本功能是，把数据（IP报文）传送到正确的网络。\n\n一般至少和两个网络相连，并根据它对所连接网络的状态决定每个数据包的传输路径。路由器生成并维护一张称为“路由信息表”的表格，这张表跟踪记录若相邻其他路由器的地址和状态信息。\n路由器使用路由信息表，并根据传输距离和通信费用等要素，通过优化算法来决定一个特定的数据包的最佳传输路径。正是这种特点决定了路由器的“智能性”，它能够根据相邻网络的实际运行状况自动选择和调整数据包的传输情况，尽最大的努力以最优的路线和最小的代价将数据包传递出去。\n路由器的最基本功能是数据包转发功能。\n根据其中所含的目的地址，决定转发到哪一个目的地(可能是路由器也可能就是最终目的点)，并决定从哪个网络接口转发出去，为了维护和使用路由器，路由器还需要有配置（控制)功能。\n\n### 中继器\n\n中继器(Repeater)是连接网络线路的一种装置,常用于两个网络节点之间物理信号的双向转发工作。中继器是最简单的网络互联设备,主要完成物理层的功能,负责在两个节点的物理层上按位传递信息,完成信号的复制、调整和放大功能,以此来延长网络的长度。它在OSI参考模型中的位置物理层。\n\n信号在双绞线中传输的过程中信号的功率会逐渐衰减，当信号衰减到一定程度时将造成信号失真，所以为了方便较远距离的两计算机进行通信，就在这两个计算机之间安装一个中继器，让信号能传的更远。\n\n中继器的作用就是整理已经衰减的信号，重新产生完整的信号再继续传送。中继器工作在物理层，只是起到了扩展传输距离的作用，对高层是透明的。\n\n### 集线器\n\n集线器实际上就是一种多端口的中继器，一般有4、8、16、24、32等数量的接口。\n\n集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。\n\n如一台集线器有8个接口，连接了8台计算机，那集线器就位于这8台计算机的“中心”，每台计算机想与其他计算机进行通信时，计算机首先要将数据包通过双绞线送到集线器上，而集线器是用广播的方式将包同时发给8个端口，8个端口的计算机收到广播信息（同时收到）后对信息进行检查，是发给自己的就接收，不是的话就不理睬。\n\n正是因为广播的这种机制，我们将我们自己的电脑连在集线器上，才能抓到ucm和话机等进行通信的数据包。同样，集线器也是工作在物理层。\n\n### 网桥\n\n网桥是早期的两端口的二层网络设备，网桥像是一个聪明的中继器，如前所说，中继器只是简单的连接了两个网络，任何数据都可以通过中继器发出，但网桥有所不同。网桥除了扩展网络的距离或范围，还能提高网络的性能和安全性。\n\n网桥(Bridge)是一个局域网与另一个局域网之间建立连接的桥梁。网桥是属于数据链路层的一种设备，它的作用是扩展网络和通信手段，在各种传输介质中转发数据信号，扩展网络的距离。\n\n网桥可以连接两个网络，网桥A端口连接A子网，B端口连接B子网。网桥中有一个信息表，我们可以把这个信息表看作两部分，一部分记录了A子网中设备的MAC地址，另一部分记录了B子网中的MAC地址，当Ａ发出一个包，网桥可以查看目的地址到底是Ａ中的还是B中的，若是Ａ中的就不进行转发，是B中的才进行转发。所以网桥与中继器不同的是隔离了两个子网，而不是任意的转发（根据），拥有了学习功能。\n\n### 2. 交换机\n\n交换机（Swich)工作在第二层（即数据链路层），它要比集线器智能一些，它能分辨出帧中的源MAC地址和目的MAC地址，因此可以在任意两个端口间建立联系，在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。\n\n交换机通过对信息进行重新生成，并经过内部处理后转发至指定端口，具备自动寻址能力和交换作用。但是 交换机并不懂得IP地址，它只知道MAC地址。\n交换机是使用硬件来完成以往网桥使用软件来完成过滤、学习和转发过程的任务。交换机速度比HUB快，这是由于HUB不知道目标地址在何处，发送数据到所有的端口。\n\n交换机中有一张MAC地址表，如果知道目标地址在何处，就把数据发送到指定地点，如果它不知道就发送到所有的端口。这样过滤可以帮助降低整个网络的数据传输量，提高效率。但是交换机的功能还不止如此，它可以把网络拆解成网络分支、分割网络数据流，隔离分支中发生的故障，这样就可以减少每个网络分支的数据信息流量而使每个网络更有效，提高整个网络效率。\n\n现代交换机是这样处理数据帧的：一旦目标头域（目标地址）已经进来了，尽管帧的其他部分还没有到达，则只要输出线路可以使用，交换机就开始转发该帧，而不需理会帧后面的内容，也即是说交换机并没有使用“存储—转发”交换方式。\n\n总结：交换机，可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：交换机常常用来连接**独立的计算机**，而**网桥连接的目标是LAN**，所以交换机的端口较网桥多。\n\n学习：以太网交换机了解每一端口相连设备的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中。\n\n转发/过滤：当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口(如该数据帧为广播/组播帧则转发至所有端口)。\n\n消除回路：当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后备路径。\n","tags":["网络"]},{"title":"计算机-主存储","url":"/backend_knowledge_architecture/hardware/memory.html","content":"\n## 0. 主存储\n\n### dpdk高性能\n\n#### 轮询机制\n\n在包处理时，采用轮询机制，而避免中断，有利于减少上下文切换的开销，规避不必要的内存拷贝和系统调用。\n\n#### 亲和性与独占\n\n特定任务可以被指定只在某个核上工作，避免线程在不同核间频繁切换，保证更多的cache命中\n\n设置CPU亲和性，让程序近运行在指定的核上，仅读取指定网卡的指定队列，从而避免数据竞争\n\n无锁循环队列\n\n并行指令，从而加速访问  \n\n<!-- more -->\n\n#### CPU Cache 加速\n\n- cache行对齐\n- 预取数据，CPU提供了指令来供程序员使用，提前把要读区的数据从内存加载到对应的Cache\n- 每个核尽量不与其他核共享数据，以减少Cache保持一致性带来的额外成本\n\n#### 引入大页表\n\n矛盾：TLB大小有限 VS 尽可能高的查询命中率\n\n解法：但是一个常规页4k，假设一个程序用了512页，总共2MB，这就需要TLB里至少方下512个页表项才能保证每次都能命中，但TLB大小有限。所以为了减少TLB不命中的情况，可以使用大页，以1G为单位进行分页。\n\n降低访存开销：利用内存大页HUGEPAGE降低TLB miss，利用内存多通道交错访问提高内存访问有效带宽\n\n#### 克服NUMA\n\n为了克服SMP的总线负担大的问题，引入NUMA，但是引入了新的问题：访问远程内存效率低下。\n\nDPDK为了克服NUMA的弊端，采取了如下措施：\n\n①Pre-corememory。每个核都有属于自己的内存，经常访问的数据结构有自己的备份。这样既满足了本地内存的需要，又可以避免cache一致性问题。\n\n②本地设备本地处理。如果一个PCI设备在node0上，那这个设备就由Node0处理。比如：\n\nq = rte_zmalloc_socked\\t(“fm10k”,sizeof(*q), RTE_CACHE_LINE_SIZE, socket_id);\n\n#### 充分利用DDIO\n\n没有DDIO的情况下，处理一个报文，CPU和网卡需要多次访问内存，而内存又很慢，造成CPU长时间等待内存。\n\nDDIO让外部网卡和cpu通过LLC Cache交换数据，绕过内存。但是报文要存在LLC Cache中，增加了对LLC Cache的容量需求。（*LLC = Last Level Cache）\n","tags":["知识体系"]},{"title":"Mysql系列-主从同步","url":"/backend_knowledge_architecture/db/main_slave.html","content":"\n## 0. 主从复制机制\n\nbinlog\n\n<!-- more -->\n\n## 1. 主从延迟原因\n\n主库和备库在执行同一个事务的时候出现时间差的问题，主要原因有：\n\n有些部署条件下，备库所在机器的性能要比主库性能差。\n备库的压力较大。\n大事务，一个主库上语句执行10分钟，那么这个事务可能会导致从库延迟10分钟。\n\n## 2. 如何降低主从延迟\n\n因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库可能是一直追不上主库的，带来的现象就是备库上seconds_behind_master值越来越大。\n在实际应用中，建议使用可靠性优先策略，减少主备延迟，提升系统可用性，尽量减少大事务操作，把大事务拆分小事务。\n\n## 3. 业务层面，如何处理过期读的方案\n\n强制走主库方案；\nsleep方案；\n判断主备无延迟方案；\n配合semi-sync方案；\n等主库位点方案；\n等GTID方案。\n\n### binlog的三种格式\n\nbinlog 有三种格式：\n\nStatement（Statement-Based Replication,SBR）：每一条会修改数据的 SQL 都会记录在 binlog 中。\nRow（Row-Based Replication,RBR）：不记录 SQL 语句上下文信息，仅保存哪条记录被修改。\nMixed（Mixed-Based Replication,MBR）：Statement 和 Row 的混合体。\n\n2.1.1 Statement\nStatement 模式只记录执行的 SQL，不需要记录每一行数据的变化，因此极大的减少了 binlog 的日志量，避免了大量的 IO 操作，提升了系统的性能。\n\n但是，正是由于 Statement 模式只记录 SQL，而如果一些 SQL 中 包含了函数，那么可能会出现执行结果不一致的情况。比如说 uuid() 函数，每次执行的时候都会生成一个随机字符串，在 master 中记录了 uuid，当同步到 slave 之后，再次执行，就得到另外一个结果了。\n\n所以使用 Statement 格式会出现一些数据一致性问题。\n\n2.2.2 Row\n从 MySQL5.1.5 版本开始，binlog 引入了 Row 格式，Row 格式不记录 SQL 语句上下文相关信息，仅仅只需要记录某一条记录被修改成什么样子了。\n\nRow 格式的日志内容会非常清楚地记录下每一行数据修改的细节，这样就不会出现 Statement 中存在的那种数据无法被正常复制的情况。\n\n不过 Row 格式也有一个很大的问题，那就是日志量太大了，特别是批量 update、整表 delete、alter 表等操作，由于要记录每一行数据的变化，此时会产生大量的日志，大量的日志也会带来 IO 性能问题。\n\n2.2.3 Mixed\n从 MySQL5.1.8 版开始，MySQL 又推出了 Mixed 格式，这种格式实际上就是 Statement 与 Row 的结合。\n\n在 Mixed 模式下，系统会自动判断 该 用 Statement 还是 Row：一般的语句修改使用 Statement 格式保存 binlog；对于一些 Statement 无法准确完成主从复制的操作，则采用 Row 格式保存 binlog。\n\nMixed 模式中，MySQL 会根据执行的每一条具体的 SQL 语句来区别对待记录的日志格式，也就是在 Statement 和 Row 之间选择一种。","tags":["数据库"]},{"title":"Redis缓存必知必会","url":"/backend_knowledge_architecture/cache/redis.html","content":"\n\n1. 如何评价redis的高性能？为何要把Redis设计成单线程？\n\n   (1)redis全内存，单线程，无锁。\n\n   (2)redis Rehash 渐进式hash,双缓冲 + 分而治之思想 \n\n    关于写入，仅写ht[1]，不再写入ht[0]；关于读取，优先读ht[1], 没有的话，再读取ht[0]\n\n    渐进式迁移的过程中，一次迁移一个bucket。包括用于解决冲突的hash链。\n\n    以下是哈希表渐进式 rehash 的详细步骤：\n\n（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。\n（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。\n（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。\n（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。\n\n渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。\n\n2. Redis提供了哪些数据结构；每一种数据结构的使用场景、大致实现（编码方式、内存占用、时间复杂度）\n\n##### 八种编码方式\n\n**INT** 64 位有符号整数类型的时候将会采用 INT 编码。 值在[0,1000)之间。 如果存入整数的值在[0,1000)中Redis将不会创建新的对象,而是直接指向**共享对象**,键值不额外占用空间。\n\n**EMBSTR**(EmbeddedString， 当存储的字符串长度较短时(len<=44 字节),Redis将会采用 embstr 编码，避免再次分配内存， 复用redis object)。这个长度是咋计算出来的呢？ 跟redis的底层内存池（jcmalloc）有关系。 64字节减去一些元数据。\n\n**RAW** 原始字符串\n\n**ZIPLIST** (压缩列表，连续内存，内存利用率高，增删改查效率低下；当hash、zset、list元素少且内容不大时使用该编码),\n\n压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。每次有写操作的时候，会**重新分配内存**，例如insert, remove等操作。\n\n**QUICK_LIST**（list元素较多时使用）\n\ndouble list of ziplist\n\n**INTSET**(整数集合，当set元素较少且都为整数时，使用该编码,从小到大的顺序存储，方便做交、并、差集运算。\n\nintset是一个由整数组成的有序集合，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合\n\nziplist可以存储任意二进制串，而intset只能存储整数。\nziplist是无序的，而intset是从小到大有序的。因此，在ziplist上查找只能遍历，而在intset上可以进行二分查找，性能更高。\nziplist可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段len），而intset只能整体使用一个统一的编码（encoding）。\n\n**HASH**（hash元素较多时使用） 渐进式扩容缩容策略\n\n**SKIPLIST**（跳表，zset元素多时使用）\n\n##### 数据结构与编码关系\n\n|  数据结构 | 紧凑实现 | 大致实现 |\n|  ----  | ----  | ---- |\n|  string | INT(仅限long类型的string), EMBSTR(字符串比较短，44以内) |RAW（普通字符串）|\n|  hash | ZIPLIST（元素较少，成员较小）|HASH|\n|  zset | ZIPLIST（元素较少，成员较小）|SKIPLIST + Dict|\n|  set | INTSET（集合元素不多, 且元素可以表示为int）|HASH|\n|  list | ZIPLIST（元素较少，成员较小）|QUICK_LIST|\n\n![在这里插入图片描述](https://images.gitbook.cn/0bc2bef0-a343-11ea-a506-f32f5295a5a9)\n\n实际上，Redis中sorted set的实现是这样的：\n\n当数据较少时，sorted set是由一个ziplist来实现的。\n当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。\n\n### Redis中的skiplist是什么样子的\n\nscore字段是数据对应的分数。\n\nbackward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。\n\nlevel[]存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个**span**值，它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。需要注意的是，level[]是一个柔性数组（flexible array member），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。\n\n假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。\n\n可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。\n\n#### skiplist与平衡树、哈希表的比较\n\nskiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。\n\n在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。\n\n平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。\n\n从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。\n\n查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。\n\n从算法实现难度上来比较，skiplist比平衡树要简单得多。\n\n#### Redis的可靠存储\n\nredis是如何实现可靠存储的：真的可靠吗？ AOF、RDB有啥区别？ 分别适用于什么场景？\n\n借助AOF、RDB可以一定程度上减少数据的损失，但是都无法做到数据的100%。\n\nRDB，定期fork一个子进程，通过copy on write技术，来进行内存的dump，成本相对AOF较高，所以不可能很短时间内就dump一次，所以如果内存中的数据还没有来得及dump到RDB，那么会丢失比较多的数据，好处是借助RDB恢复数据比较快。 RDB最大的时间成本是clone页表。\n\nAOF，定期（通常是s级别）append 写操作命令到文件中，只是简单的写一次磁盘，所以性能较好，如果新的命令append到aof之间发生宕机，丢失的数据也比较少。缺点是每次基于AOF恢复数据会比较慢。\n\nAOF缓冲数据的写入策略：NO（依赖操作系统的flush盘机制）、always（性能最差，安全性最好）、everySecond（最多丢失1～2秒数据）\n\nAOF重写【BGREWRITEAOF】，AOF 重写缓冲区\n\n把主线程的内存拷贝一份给fork出来的 bgrewriteaof 子进程，这里面包含了Redis中最新的数据。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6804bfkyyxo0.webp)\n\n下表是完整的AOF后台重写过程：\n\n时间    服务器进程（父进程）    子进程\n\nT1    执行命令 SET K1 V1\nT2    执行命令 SET K1 V1\nT3    执行命令 SET K1 V1\nT4    创建子进程，执行AOF文件重写    开始AOF重写\nT5    执行命令 SET K2 V2    执行重写\nT6    执行命令 SET K3 V3    执行重写\nT7    执行命令 SET K4 V4    完成AOF重写，向父进程发送信号\nT8    接收到信号，将T5 T6 T7 服务器的写命令追加到新的AOF文件末尾\nT9    用新的AOF替换旧的AOF\n\nT8 T9执行的任务会阻塞服务器处理命令。\n\nhttps://www.51cto.com/article/694868.html\n\nRedis 3.0 基于checkpoint思想的新持久化方式\n\n#### Redis的高可用性\n\nredis tw代理模式与cluster集群模式分别是如何工作的？ 哪一种模式使用了一致性Hash?\n\n两者都是为了解决单机数据存不下的问题。数据存不下，只能通过多台来存。\n\n客户端通过tw代理模式访问redis集群，数据分片使用了一致性hash，以尽可能减少某台redis机器不可用造成的影响，但是还是会丢数据。\n\n官方的**cluster集群**方案是由客户端sdk来维护slot分布，数据分片分片是通过CRC32(key)%16834来实现。无中心化，node之间通过gossip协议来进行通信，选主等。\n\n另外，redis cluster还尝试解决高可用的问题，但是由于CAP理论，他选择了可用性，丢失了一致性。 丢失一致性的点在于：1）异步复制；2）网络分区。\n\n![异步复制导致数据丢失](https://pic2.zhimg.com/80/v2-1530e8c407dd674e77ee7dc36295b161_1440w.jpg)\n\n另外值得一提的是**Redis哨兵模式**。这种模式只能解决高可用的问题（并不能保证数据不丢失），但是无法解决数据太大的问题。\n\n#### Redis 实现分布式锁\n\n1. 如何通过Redis实现一个“可靠”的分布式锁？\n\n分布式锁的特性：排他性、无死锁、高可用。\n\n先说加锁，setnx命令，支持cas操作，并且支持设置超时时间。通过设置超时时间这个功能点，可以避免加锁后进程挂掉造成的锁没法释放的问题。但是这种加锁方案还有一个缺点，那就是超时时间很难设置的很合理，设置过短可能会引起加锁时间内不足以完成业务逻辑；设置过长又导致宕机恢复时间过长。这种情况下，我们可以额外启动一个WATCH-dog线程来监视这些锁，如果锁快要到期了，就调用expire命令对锁进行续期；业务完成时禁用watch-dog即可。\n\n再说解锁unlock，理想情况下，解锁时只要通过del命令来把锁定的key删除即可。但是实际情况可能会更复杂一些。第一个问题，如果删除的key不是加的锁怎么办？ 容易想到，加锁时，设置key的value为一个unique id。 解锁删除时，先get一下key，看看key对应的value是不是跟预期的id相符，如果相符，del；否则，noop，说明我正准备删除别人加的锁。但是刚才的方案，还有一个缺陷那就是get跟del两个操作不是一个原子的，中途可能会被打断。如果真的被打断，还是会出现误解锁的过程。此时我们可以借助lua脚本将刚才的两个步骤原子化。至此，解锁操作才算基本完成。\n\n上面的方案还有啥问题呢？ 如果主从同步未完成，而主挂掉了，从上位之后，会导致之前加的锁失效。 这个问题，官方给的解决方案是使用redis cluster的红锁来解决。\n\n最后再提一下，除了redis可以实现分布式锁，还可以通过mysql数据库（version乐观锁，for update悲观锁），zookeeper等来实现分布式锁。\n\n#### redis key过期的方式\n\n- 惰性淘汰：在key请求时，判断key是否失效，失效就淘汰\n\n- 定时策略：每隔100毫秒检测一次， 移除所有已过期的键\n如果发现超过25%的键过期，会重复执行。\n\n#### redis 淘汰策略\n\n当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。\n\n2个维度的组合：\n\n1. 回收哪些：仅仅回收有TTL的（volatile）、所有的、空集\n2. 如何替换哪个： LRU、LFU、最短TTL、随机\n\n最多一共有$3^3$种组合，只是有一些没有意义。例如空集 + LRU、所有的 + 最短TTL。 剩下的有意义的包括：\n\n- noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。\n- volatile-lfu:\n- volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。\n- volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\n- volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间 存放。\n- allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\n- allkeys-lfu:  Least Frequently Used 最近最不常用的\n- allkeys-random: 回收随机的键使得新添加的数据有空间存放。\n\n### 事务\n\n事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。\n\n1. 命令入队报错，全部回滚，没有任何影响\n2. 命令执行时报错，不会回滚，而是会继续执行余下的命令\n\n#### watch机制\n\nwatch 一个变量， multi exec 根据中间有没有其他线程更改watched的变量来决定，是commit事务还是rollback事务，有点像CAS操作，只是Redis的watch机制并没有ABA问题\n\n### 高级用法\n\nBitmap :\n位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）；\n\nHyperLogLog:\n供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；\n\nGeospatial:\n可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？\n\n这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你有点东西。\n\npub/sub：\n功能是订阅发布功能，可以用作简单的消息队列。\n\nPipeline：\n可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。\n\nLua：\nRedis 支持提交 Lua 脚本来执行一系列的功能。\n\n我在前电商老东家的时候，秒杀场景经常使用这个东西，讲道理有点香，利用他的原子性。\n\n\n\n参考：http://zhangtielei.com/posts/blog-redis-ziplist.html","tags":["缓存"]},{"title":"go语言陷阱","url":"/backend_knowledge_architecture/language/go/index.html","content":"\n### 变量&类型相关\n\n```go\n\nfunc main() {\n    var a = []interface{}{1, 2, 3}\n\n    //变参函数忘记...展开\n    fmt.Println(a)\n    fmt.Println(a...)\n} \n\nfunc main() {\n    x := [3]int{1, 2, 3}\n\n    //在函数调用参数中，数组是值传递，无法通过修改数组类型的参数返回结果。\n    func(arr [3]int) {\n        arr[0] = 7\n        fmt.Println(arr)\n    }(x)\n\n    fmt.Println(x)\n}\n\n\nfunc Foo() (err error) {\n    if err := Bar(); err != nil {\n        return\n    }\n    return\n}\n\n//map是一种hash表实现，每次遍历的顺序都可能不一样。\nfunc main() {\n    m := map[string]string{\n        \"1\": \"1\",\n        \"2\": \"2\",\n        \"3\": \"3\",\n    }\n\n    for k, v := range m {\n        println(k, v)\n    }\n}\n\n```\n\n<!-- more -->\n\n### 调度相关\n\nGMP模型-GoRoutine, Machine, Processor\n\nG（Goroutine）：代表Go 协程Goroutine，存储了 Goroutine 的执行栈信息、Goroutine 状态以及 Goroutine 的任务函数等。G的数量无限制，理论上只受内存的影响，创建一个 G 的初始栈大小为2-4K，配置一般的机器也能简简单单开启数十万个 Goroutine ，而且Go语言在 G 退出的时候还会把 G 清理之后放到 P 本地或者全局的闲置列表 gFree 中以便复用。\n\nM（Machine）： Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程，想要在 CPU 上执行代码必须有线程，通过系统调用 clone 创建。M在绑定有效的 P 后，进入一个调度循环，而调度循环的机制大致是从 P 的本地运行队列以及全局队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。M的数量有限制，默认数量限制是 10000，可以通过 debug.SetMaxThreads() 方法进行设置，如果有M空闲，那么就会回收或者睡眠。\n\nP（Processor）：虚拟处理器，M执行G所需要的资源和上下文，只有将 P 和 M 绑定，才能让 P 的 runq 中的 G 真正运行起来。P 的数量决定了系统内最大可并行的 G 的数量，**P的数量受本机的CPU核数影响，可通过环境变量$GOMAXPROCS或在runtime.GOMAXPROCS()来设置，默认为CPU核心数。\n\n#### 基于信号的抢占式调度\n\n真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。不管协程有没有意愿主动让出 cpu 运行权，只要某个协程执行时间过长，就会发送信号强行夺取 cpu 运行权。\n\nM 注册一个 SIGURG 信号的处理函数：sighandler\nsysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占P超过10ms，会给M发送抢占信号\nM 收到信号后，内核执行 sighandler 函数把当前协程的状态从_Grunning正在执行改成 _Grunnable可执行，把抢占的协程放到全局队列里，M继续寻找其他 goroutine 来运行\n被抢占的 G 再次调度过来执行时，会继续原来的执行流\n\n```go\n//Goroutine是协作式抢占调度，Goroutine本身不会主动放弃CPU：\n//解决的方法是在for循环加入runtime.Gosched()调度函数：或者是通过阻塞的方式避免CPU占用：\n\nfunc main() {\n    runtime.GOMAXPROCS(1)\n\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(i)\n        }\n    }()\n\n\n    for {\n        runtime.Gosched()\n    }\n\n    select{}\n}\n```\n\n### 闭包相关\n\n```go\n\n//闭包错误引用同一个变量\nfunc main() {\n    for i := 0; i < 5; i++ {\n        defer func() {\n            //打印的i往往会不符合预期\n            println(i)\n        }()\n    }\n}\n\n//改进的方法是在每轮迭代中生成一个局部变量：\nfunc main() {\n    for i := 0; i < 5; i++ {\n        i := i\n        defer func() {\n            println(i)\n        }()\n    }\n}\n\n //或者是通过函数参数传入：\nfunc main() {\n    for i := 0; i < 5; i++ {\n        defer func(i int) {\n            println(i)\n        }(i)\n    }\n}\n\n```\n\n### defer相关\n\n```go\n\n//defer在函数退出时才能执行，在for执行defer会导致资源延迟释放：\nfunc main() {\n    for i := 0; i < 5; i++ {\n        f, err := os.Open(\"/path/to/file\")\n        if err != nil {\n            log.Fatal(err)\n        }\n        defer f.Close()\n    }\n}\n\n//解决的方法可以在for中构造一个局部函数，在局部函数内部执行defer：\nfunc main() {\n    for i := 0; i < 5; i++ {\n        func() {\n            f, err := os.Open(\"/path/to/file\")\n            if err != nil {\n                log.Fatal(err)\n            }\n            defer f.Close()\n        }()\n    }\n}\n```\n\n### error判定相关\n\n```go\n\n//比如返回了一个错误指针，但是并不是空的error接口：\ntype MyError struct {\n   code int\n   msg  string\n}\n\nfunc (e *MyError) Error() string {\n   return fmt.Sprintf(\"code:%d,msg:%v\", e.code, e.msg)\n}\n\nfunc returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n\n    //因为error是一个interface\n    //interface分为两部分：type + value\n    //返回的p是(*MyError, nil)\n    //这个玩意并不是单纯意义的nil\n    return p // Will always return a non-nil error.\n}\n```\n\n### 切片相关\n\nslice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice在并发执行中不会报错，但是数据会丢失\n\n切片append时，会发生变化\n\n```go\n//切片会导致整个底层数组被锁定，底层数组无法释放内存。如果底层数组较大会对内存产生很大的压力。\nfunc main() {\n    headerMap := make(map[string][]byte)\n\n    for i := 0; i < 5; i++ {\n        name := \"/path/to/file\"\n        data, err := ioutil.ReadFile(name)\n        if err != nil {\n            log.Fatal(err)\n        }\n        //解决的方法是将结果克隆一份，这样可以释放底层的数组：\n        headerMap[name] = append([]byte{}, data[:1]...)\n        headerMap[name] = data[:1]\n    }\n\n    // do some thing\n}\n\n```\n\n### 多线程相关\n\nmap、slice等线程不安全\n\n```go\n\n//不同Goroutine之间不满足顺序一致性内存模型\n\nvar msg string\nvar done bool\n\nfunc setup() {\n    msg = \"hello, world\"\n    done = true\n}\n\nfunc main() {\n    go setup()\n    //这个done可能已经加载到CPU cache中了，并不会每次读主存寸\n    for !done {\n    }\n    println(msg)\n}\n\n//因为在不同的Goroutine，main函数中无法保证能打印出hello,world:\n\n//下文为正确解法\nvar msg string\nvar done = make(chan bool)\n\nfunc setup() {\n    msg = \"hello, world\"\n    done <- true\n}\n\nfunc main() {\n    go setup()\n    <-done\n    println(msg)\n}\n```\n\n### recover相关\n\n```go\n\n//在局部作用域中，命名的返回值内同名的局部变量屏蔽：\nfunc Foo() (err error) {\n    if err := Bar(); err != nil {\n        return\n    }\n    return\n}\n\n//必须在defer函数中直接调用才有效：多层嵌套依然无效、直接defer调用也是无效\nfunc main() {\n    defer func() {\n        recover()\n    }()\n    panic(1)\n}\n```\n\n### 内存相关\n\n逃逸机制\n\n编译器会根据变量是否被外部引用来决定是否逃逸：\n如果函数外部没有引用，则优先放到栈中；\n如果函数外部存在引用，则必定放到堆中;\n如果栈上放不下，则必定放到堆上;\n\n总结\n\n栈上分配内存比在堆中分配内存效率更高\n栈上分配的内存不需要 GC 处理，而堆需要\n逃逸分析目的是决定内分配地址是栈还是堆\n逃逸分析在编译阶段完成\n\n### goroutine泄漏\n\n泄露原因\n\n1. Goroutine 内进行channel/mutex 等读写操作被一直阻塞。\n2. Goroutine 内的业务逻辑进入死循环，资源一直无法释放。\n3. Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待\n\n```go\nfunc main() {\n    ch := func() <-chan int {\n        ch := make(chan int)\n        //这个协程一直pending在write channel上\n        go func() {\n            for i := 0; ; i++ {\n                ch <- i\n            }\n        } ()\n        return ch\n    }()\n\n    for v := range ch {\n        fmt.Println(v)\n        if v == 5 {\n            break\n        }\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    ch := func(ctx context.Context) <-chan int {\n        ch := make(chan int)\n        go func() {\n            for i := 0; ; i++ {\n                select {\n                case <- ctx.Done(): \n                    return\n                case ch <- i:\n                }\n            }\n        } ()\n        return ch\n    }(ctx)\n\n    for v := range ch {\n        fmt.Println(v)\n        if v == 5 {\n            cancel()//ctx会done掉\n            break\n        }\n    }\n}\n```\n","tags":["编程语言"]},{"title":"关于缓存与数据库的一致性与过载保护机制","url":"/backend_knowledge_architecture/cache/consistency.html","content":"\n## 数据库、缓存一致性问题\n\n先说最重要的数据库、缓存一致性问题，关于该问题，有以下几点需要考虑：\n\n- 当DB数据发生变更时，是删除缓存还是修改缓存？\n\n   1. 答案是删除缓存。相比修改缓存，删除缓存是幂等性操作。删除缓存可以避免出现**双写并发**问题。\n\n   2. 另外一点，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值，也就是说update的value是什么我无法简单得知。\n\n   3. 懒加载思想： 更新了，但是没有读请求就白白浪费内存了。\n\n- 先写DB还是先写缓存？\n\n   答案是先操作DB。结合case1, 在读多写少的高并发场景下，如果先删缓存再操作DB，有一个很明显的逻辑错误，使得有极高的概率出现读写并发问题。虽然先db后缓存的方式也无法完全避免这类问题，但是出现的概率极低。【详细的问题时序见下文】\n\n   出现并发问题的时序如下：\n\n   1. 如果读的时候，key不存在，回源头读ReadDB\n   2. 写操作，UpdateDB\n   3. 写操作，删除缓存\n   4. 读操作，将第一步读到的数据写入缓存（此时，缓存已经过期）\n\n- 高并发下，关于缓存的一致性会出现什么问题？\n\n   case1, case2中提到了在高并发的情况下，会出现某种并发逻辑错误，导致数据不一致。\n\n- 是否听说过订阅数据库binlog变更去清理缓存的方法？这个方法的使用场景是啥？\n\n   通过binlog变更的方式去清理缓存，有两个好处：第一，无业务侵入型；第二，支持无限重试。\n\n### CacheAside模式\n\nCacheAside模式，一定是最佳的吗？不一定，具体场景具体分析：\n\n（1）新用户注册场景，同时数据库主从延迟1s\n\n解决方案：新建数据库 + 新建缓存（避免读取到延迟的数据结果）\n\n（2）写入特别频繁的场景，而我们对命中率有一定的要求\n\n  解决方案：\n\n  1. updateDB + updateCache(With Lock)\n  2. updateDB + updateCache(with TTL)\n\n### Write/Read Through模式\n\n两种应对write miss的办法：\n\n  （1）write-allocate 写cache，再由cache更新db\n  （2）no write allocate 直接更新db\n\n### write back模式\n\n![write-back模式的读](http://cdn.b5mang.com/2021320144254.png)\n\n![write-back模式的写](http://cdn.b5mang.com/2021320144312.png)\n\n变种：在允许数据丢失的情况下，写入时只写缓存，而异步写入存储\n\n## 经典问题\n### 缓存穿透\n\n再说缓存穿透问题。\n\n首先明确什么是缓存穿透问题？考虑在很高的读并发下，如果某一个redis key突然过期，会发生什么？如果真的发生这种情况，并且我们没有任何预防措施，按照cache aside模式，程序会read from db，然后set cache。但是由于并发很高，所有的线程同时去请求db，造成db过载不可用。我们称这种现象就缓存穿透。通过分布式锁来控制仅一个线程去read db，而其他线程等待，可以一定程度上避免缓存穿透问题。\n\n缓存并发穿透（狗桩效应）：极热点缓存失效，大量请求穿透到DB，造成DB瞬时压力过大\n\n如何解决缓存并发穿透呢？\n（1）热点发现，定时续期\n（2）对于极热点，启用本地缓存\n\n还有一种情况，如果请求的**某一个key在db中也不存在**，我们需要设置一个拥有较短TTL的空缓存来避免每次请求都穿透到db。\n\n回种空值---缺点在于：会占用很大的内存来存储好多无用请求，需要评估内存是否OK\n\n布隆过滤器---在写入DB时，额外写一份数据到布隆过滤器，查询时优先访问过滤器\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6w7buyfuv2s0.webp)\n\n### 缓存雪崩\n\n最后谈一下缓存雪崩。\n\n同样先搞清楚什么是缓存雪崩。由于某些系统设计不合理，缓存会设置为相同的过期时间或者很接近。这样子在某个时间点，缓存便会近乎同时失效，造成业务请求全部回源db,造成db过载，我们称这种情况为缓存雪崩。一般情况下，我们需要有意的设置key的过期时间，让他们**随机过期**，从而解决缓存同时过期导致的缓存雪崩问题。\n\n### 热key重建\n\n高并发多线程的情况下，热Key重键是使用redis比较典型的一个问题：\n\n解决方案：\n\n1. 加锁重键（互斥锁）：\n2. 热键不过期：在缓存中创建一个时间戳，先判断时间戳是否过期，如果没有过期返回原数据，过期了则访问数据源\n\n","tags":["缓存"]},{"title":"云游戏","url":"/backend_knowledge_architecture/system_design/cloud_game.html","content":"\n## 0. 云游戏场景描述\n\n云游戏指在云服务器端运行的游戏，不仅需要将渲染后的游戏画面推送到终端，还需要将终端操作的指令传输到云端服务器进行处理。这种实时交互的需求，使得云游戏对网络时延有较高的要求，需要在尽量靠近用户终端的位置提供服务。\n\n<!-- more -->\n\n## 1. 云游戏解决方案\n\n通过将云游戏服务部署在边缘计算机器，业务可以在靠近用户的位置提供云游戏服务。达到网络传输距离的缩减，显著降低网络时延，满足云游戏双向数据传输对网络时延的苛刻要求。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3wo7tdjjceg0.webp)","tags":["系统设计","CDN"]},{"title":"实时音视频","url":"/backend_knowledge_architecture/system_design/rt_av.html","content":"\n## 0. 实时音视频场景描述\n\n实时音视频业务（例如互动直播）场景下，业务对网络时延具有较高的要求。为保证优质的业务体验，需实现低网络时延。如果用户所在的地理位置与中心机房的物理距离过远，网络时延将会明显增加，影响业务体验。\n\n<!-- more -->\n\n## 1. 实时音视频解决方案\n\n腾讯云边缘计算机器的基础资源建设在全国各个地区，可以为业务提供靠近用户和终端的计算和网络的云服务。通过就近部署应用和服务，用户到业务服务器的网络时延可以得到明显优化。以互动直播为例，由于主播与观众的双向数据传输对时延敏感，如果您通过使用边缘计算机器部署相关业务服务，则可以极大的优化网络时延，使主播与观众的业务体验可以得到更好的保障。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3gsc69vwexa0.webp)","tags":["系统设计","CDN"]},{"title":"计算机硬件-CPU寄存器简介","url":"/backend_knowledge_architecture/hardware/cpu.html","content":"\n## CPU寄存器\n\n在用途方面，他们有各自默认的用途：\n\n- Eax用来保存所有API函数的返回值。寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；\n- 寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；\n- 寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；\n- 寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。\n\n寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，\n\n它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。\n\n那么ESP和EBP指的分别是什么呢？\n\n- ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。\n- EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。\n\n对于64位CPU，EAX ---> RAX\n\n### CPU指令的执行\n\n一个基本的CPU执行计算的过程如下：\n\n1. 程序以及数据被加载到主内存\n2. 指令和数据被加载到CPU的高速缓存\n3. CPU执行指令，把结果写到高速缓存\n4. 高速缓存中的数据写回主内存\n\n### 一次函数调用\n\n栈的增长方向：向下增长，ESP越来愈小、ESP比EBP小\n\n一个函数执行步骤：\n\n1. 函数参数压入stack中\n    push p1\n    push p2\n2. CPU**自己**把返回地址压入stack中\n    push eip\n3. CPU自己跳转到新的函数地址(call func)，开始执行（先保存EBP，然后让EBP指向当前ESP）\n    push ebp 保存老函数的EBP到新的stack中\n    mov esp => ebp  让ebp保存新函数的stack base\n4. 分配局部变量\n    sub esp 100 分配100字节的局部变量\n5. 局部变量赋值与访问\n    通过ebp - $Offset$ 来访问局部变量\n6. 访问参数\n    通过ebp + $Offset$ 来访问参数\n7. 函数返回\n    add esp 100\n    mov ebp => esp\n    注意：上面这一句应该是重复的，理论上只要对esp进行了完成逆操作，esp应该等于ebp了。是不需要额外通过ebp来还原的；当然如果要通过ebp来还原，也就不需要去显示操作esp了。\n    pop ebp 还原ebp\n    ret（pop eip）\n8. 将压入的参数POP出来\n    pop p2\n    pop p1\n\n## 指令集\n\n 所谓指令集，是CPU中用来计算和控制计算机系统的一套指令的集合。指令的强弱是CPU的重要指标，指令集是提高微处理器效率的最有效工具之一。\n\nCPU依靠指令来计算和控制系统，每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。与其他硬件电路相配合，决定的是这一款CPU的生态系统。因此，指令集搭建的是一个桥梁，是软硬件之间沟通的桥梁，简单来说，软件通过指令集和硬件讲话。因此，指令集对形成生态至关重要，从这个意义上讲，不同的CPU指令集，决定了这款CPU设计的复杂程度。\n\n从现阶段的主流体系结构讲，指令集可分为复杂指令集(CISC, complex instruction set computer)和精简指令集(RISC, reduced instruction set computer)两部分。简单来讲，RISC功能简洁，代表着简洁的CPU设计，CISC功能完备，代表着复杂的CPU设计。\n这里引用步日欣老师文章中的一段话：\n\n    CPU的指令，就如同盖房子的砖，如果都是小块的标准砖头，也能盖起各种不同的房子，这就是RISC；\n    如果除了标准砖头，还设计了很多的砖瓦结构件，适用于拐角、吊梁等，这就是CISC。\n    不同的模式，都能盖起房子，但是效率却大不一样，RISC的标准砖头，小平房可以盖，\n    摩天大楼也可以盖，底层的原材料很简单，都是标准化的砖头；\n    CISC的各种复杂的结构件，对于盖一种房子的时候效率确实高，吊起结构件随便一拼装就ok，\n    但是如果要盖的房子种类多了，就需要定义更多更复杂的结构件，结构件的管理就会越来越复杂，\n    而且在建设某种常见建筑的时候，大部分特殊的结构架是闲置不用的，大大影响了施工效率。\n    基于CISC模式下的CPU设计，在各种新需求下，堆叠的功能越来越复杂，芯片设计难度也越来越高，效率低下，\n    因此就出现了RISC精简指令集的概念。\n\n### 对比CISC和RISC\n\nCISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，只有Load/Store操作内存\n\nCISC支持多种寻址方式；RISC支持方式少\n\nCISC通过微程序控制技术实现；RISC增加了通用寄存器，硬布线逻辑控制为主，是和采用流水线\n\nCISC的研制周期长\n\nRISC优化编译，有效支持高级语言\n\n大白话就是：\n\nCISC架构，性能好，但是耗电多，电压高。主要用于桌面服务。\n\nRISC架构：耗电少，电压低，但是单核性能比不上CISC架构，主要用于嵌入式开发，或者移动设备开发。\n\n### CPU架构\n\n1. ARM架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构\n\n2. x86或80x86是英代尔Intel首先开发制造的一种微处理器体系结构的泛称。x86架构是重要地可变指令长度的CISC（复杂指令集电脑，Complex Instruction Set Computer）。\n\n3. MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlockedpipedstages)\n\n4. PowerPC 是一种精简指令集（RISC）架构的中央处理器（CPU），其基本的设计源自IBM（国际商用机器公司）的IBMPowerPC 601 微处理器POWER（PerformanceOptimized With Enhanced RISC\n\n### intel,amd和arm的关系\n\nIntel 与 AMD是两个公司，amd 与 arm 又是同一个公司（AMD）的两款产品\n\nIntel与AMD共同采用x86架构，都采用CICS指令集，一般用于桌面应用；\n\n而arm 采用 ARM架构，采用RICS指令集，例如家用游戏机、平板、手机等会采用arm CPU\n\n可以说，AMD CPU是 AMD公司为对抗Intel公司的Intel CPU推出的第一代产品；\n\n而 ARM CPU 是AMD公司为了对抗Intel公司的Intel CPU推出的第二代产品，\n\n## co 实现\n\n```cpp\n\nstruct co_ctx{\nvoid* regs[14]; //用于保存或者设定特定寄存器\nsize_t ss_size; //栈帧区域大小\nchar* ss_sp; // 协程栈帧内存区域，这个区域一般在堆上分配\n}\n\nco_make (co_ctx* co, func* p, p1, p2) {\n    使用p, p1, p2把co填充起来\n    co.ss_sp都是分配在堆上\n    co的EIP与ESP需要被单独赋值\n}\nco_swap（）{\n    主要要保存当前寄存器到要swap_out的co_ctx中\n    将要swap_in的co_ctx设置到寄存器中\n}\n```\n\n具体参考：https://vinsflyfish.github.io/posts/thinking-in-libco/","tags":["计算机硬件"]},{"title":"分裂二叉树的最大乘积","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/max_product.html","content":"\n## 0. 题目\n\n给你一棵二叉树，它的根为 root\n请你删除 1 条边，使二叉树分裂成两棵子树\n且它们子树和的乘积尽可能大\n\n由于答案可能会很大\n请你将结果对 10^9 + 7 取模后再返回\n\n<!-- more -->\n\n## 1. 差的思路\n\n（1）从下往上遍历二叉树，把每一个subtree的sum计算出来，并存到一个map中，key为treeNode*, value为该treeNode的sum\n\n（2）再遍历一遍二叉树，把所有的边（root--right; root--left）遍历出来放到一个容器中\n\n（3）遍历上面的容器，取出每一条的边的两个顶点（必为父子关系）；\n\n对于孩子节点，查map，获取该乘积的左边部分left_sum；\n\n对于父亲节点，查map[root->right] + root本身的val， 获取乘积的右边部分right_sum；\n\nmax = max(cur_max, left_sum * right_sum)\n\n## 2. 更好的思路\n\n上面思路中的right_sum还有别的方法可以获取？\n\n启发式思考，**正向思维是做加法，逆向思维是做减法**,right_sum = TotalSum - left_sum\n\n有了上面的思考，我们重新梳理新的思路：\n\n（1）遍历一遍二叉树，获取TotalSum\n\n（2）再自下而上遍历（后序遍历）一遍二叉树，得到当前root的sum（计作cur_sum)， 除了root子树以外的其他节点的sum为TotalSum - cur_sum\n\n（3）max = max(cur_max, cur_sum * (TotalSum - cur_sum))\n\n## 3. 代码实现\n\n```cpp\nclass Solution {\npublic:\n    long long ans;\n    long long sum;\n    void dfs1(TreeNode* root){\n        if(!root) return ;\n        sum += root->val;\n        dfs1(root->left);\n        dfs1(root->right);\n    }\n    \n    long long dfs2(TreeNode* root){\n        if(!root) return 0;\n        long long x = dfs2(root->left) + dfs2(root->right) + root->val;\n        ans= max(ans, x * (sum - x));\n        return x;\n    }\n    \n    int maxProduct(TreeNode* root) {\n        ans = 0;\n        sum = 0;\n        dfs1(root);\n        dfs2(root);\n        return ans % int(1e9+7);\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"函数调用约定","url":"/backend_knowledge_architecture/language/cpp/call_convention.html","content":"\n## 0. 函数调用约定\n\n|  名称 | 谁来清理入栈参数| 参数压栈顺序 |函数名转换规则|\n|  ----  | ---- |----  |----  |\n|__stdcall | 被调用函数在返回前清理入栈参数 |参数自右向左压栈 |C语言时，_function@number，number为参数的字节数；C++编译时函数名的转换：?function@@YG****@Z或者?function@@YG*XZ；若函数有参数，以@Z结束；若函数无参数，则以Z结束|\n|__cdecl | 调用函数在返回后清理入栈参数 |参数自右向左压栈 |_function，其中function为函数名；C++编译时函数名的转换：同__stdcall，把YG改为YA|\n|__fastcall | 被调用函数在返回前清理入栈参数 |使用ECX传递第一个参数，EDX传递第二个参数，其余参数自右向左压栈 |C编译时函数名的转换：@function@number；C++编译时函数名的转换：同__stdcall，把YG改为YI|\n|__pascal | 被调用函数在返回前清理入栈参数 |参数自左向右压栈 |较为复杂，参加pascal文档|\n\n<!-- more -->\n\n## 1. thiscall\n\nthiscall不是一个关键字，因此不能在程序中明确指定，它是C++类成员函数缺省的调用约定。由于成员函数调用涉及到一个this指针，因此必须进行特殊处理。\n\n参数自右向左压栈\n\n如果参数个数确定，this指针通过ECX传递给被调用者；如果参数个数不定，this指针在所有参数压栈后被压入堆栈\n\n如果参数个数确定，被调用函数自己清理堆栈；如果参数个数不定，由调用函数清理堆栈\n\n可见，对于参数个数固定情况下，它类似于__stdcall，不定时则类似__cdecl\n\n## 2. naked call\n\n使用前四种调用约定时，在进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。\n\nnaked call不产生这样的代码。更特殊的是，不能用return返回返回值，只能用插入汇编返回结果。\n\nnaked call必须和__declspec连用，即__declspec(naked)，naked call还可以和其他调用约定联用，如：\n\n```cpp\n__declspec(naked) int __stdcall function(int a, int b)\n```\n\n使用场合：\n\n1、_beginthread需要__cdecl的线程函数地址，_beginthreadex和CreateThread需要__stdcall的线程函数地址。\n\n2、main函数必须是__cdecl，一般的WIN32函数和回调函数都是__stdcall，并且专门定义了宏来标识：\n\n```cpp\n   #define CALLBACK __stdcall\n   #define WINAPI　 __stdcall\n```\n\n3.如果某函数在C语言编译器中编译，而在C++文件使用，由于两种编译器对函数名的解析不一样，因此需要在C++文件中使用extern \"C\"进行声明，否则会发生链接错误：\n\n```cpp\n   #ifdef _cplusplus\n   extern \"C\"{\n   #endif\n    int func(int a, int b);\n   #ifdef _cplusplus\n   }\n   #endif \n```\n\n## 3. C++编译函数转换规则\n\nC++编译时函数名的转换：?function@@YG****@Z或者?function@@YG*XZ\n若函数有参数，以@Z结束；若函数无参数，则以Z结束\n其中function为函数名，*代表参数表，为下列值：\n      X--void ，\n      D--char，\n      E--unsigned char，\n      F--short，\n      H--int，\n      I--unsigned int，\n      J--long，\n      K--unsigned long，\n      M--float，\n      N--double，\n      _N--bool，\n      PA--表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以\"0\"代替，一个\"0\"代表一次重复\n参数表第一项为返回类型，其后跟参数的类型，指针标识在其所指数据类型前\n例：int MyFunc1(unsigned char *arg1, unsigned long arg2)\n    ?MyFunc1@@YGHPAEK@Z\n    void MyFunc2(char *arg1, char *arg2, char *arg3)\n    ?MyFunc2@@YGXPAD00@Z\n    void MyFunc3()\n    ?MyFunc3@@YGXXZ\nC++编译器转换函数名时更多的考虑了参数，主要是为了方便函数重载，而C语言则不存在函数重载问题\n\n注意：对于可变参数的成员函数，始终使用__cdecl的转换方式\n\n参考：https://www.likecs.com/show-306640430.html","tags":["语言底层"]},{"title":"动态规划-扔鸡蛋问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/egg_drop.html","content":"\n## 0. The Two Egg Problem\n\nYou are given two eggs, and access to a 100-storey building. Both eggs are identical. The aim is to find out the highest floor from which an egg will not break when dropped out of a window from that floor. If an egg is dropped and does not break, it is undamaged and can be dropped again. However, once an egg is broken, that’s it for that egg.\n\nIf an egg breaks when dropped from floor n, then it would also have broken from any floor above that. If an egg survives a fall, then it will survive any fall shorter than that.\n\nThe question is: What strategy should you adopt to minimize the number egg drops it takes to find the solution?. (And what is the worst case for the number of drops it will take?)\n\n<!-- more -->\n\n## 1. 假如你只有一个鸡蛋\n\n显然，你**不得不**从一层到100层，一层一层的扔，因为如果不按这种策略的话，万一层坏掉了，你就没有更多的鸡蛋了？\n\n## 2. 假如你有无数的鸡蛋\n\n如果你有无穷多的鸡蛋，我可以采用**二分策略**去扔，第一次50层，如果碎了，那就第二次25层；如果没有碎，那就75层（50 + 25）\n\n## 3. 如果有2个鸡蛋呢？\n\n假设最坏情况下（也就是最多）能扔N次； 我们的扔蛋策略如下：\n\n第一次，在$N_{th}$层扔\n\n如果碎了，那第1层到第N-1层，就从低到高依次扔（这种情况下次数为1 + (N - 1) = N，没有超过N，ok\n\n如果没有碎，那么我就在$2N + 1$层扔（在第一次N的基础上，往上爬N-1层）为什么呢？爬的层数过多，总的次数会超过N次（与既定假设矛盾）；如果爬的层数过少，存在浪费现象，次数没有minimize。\n\n所以，N + (N - 1) + (N - 2) + ... + 2 + 1 是我总的可以探测到的层数；\n\n## 4. 普遍情况，如果有k个鸡蛋，有N层楼？\n\nF[n,k]表示k个鸡蛋，扔n次能够reach的最大层数\n\nD[n,k]表示k个鸡蛋，n层楼，需要扔的次数；\n\n正难则反，对于D来说，可以通过动态规划来实现，但是要想求他的解析解比较困难。\n\n但是对于F来说，我们可以借助一个G(n,k) = F() - F()来进行直接求解。\n\n参考：\nhttps://brilliant.org/wiki/egg-dropping/#a-better-approach\nhttps://datagenetics.com/blog/july22012/index.html\nhttps://spencermortensen.com/articles/egg-problem/","tags":["动态规划"]},{"title":"支持向量机-SVM","url":"/ai/classification/svm.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n之前总有一些年轻人问我，我应该了解哪些知识才能像某某某那么牛B。\n这句话的意思其实就是：他们特别困惑，想知道一个后端程序员的知识体系，想知道从哪开始学起。\n\n关于这个问题，琢磨了好久，我不想简单的一句话就敷衍过去了，这个问题我要深思熟虑去回答。\n因为如果 10 年前有人告诉我这个问题的答案，现在的我将少走很多的弯路，技术水平也会更上一层楼。\n\n简单说一下全文的结构，全文一共分为四大部分。第一部分，主要从硬件、操作系统、网络、数据结构&算法等几个方面跟大家聊一下计算机科学相关的基础知识。第二部分，讲一下设计一款高性能的服务框架，应该从哪些方面着手；第三部分，讲一下平常工作中使用最频繁的知识-数据库、缓存以及一些相关的经典问题；最后第四部分，讲述的侧重点从第二部分的微观转到相对宏观的内容，跟大家聊一下分布式系统、大型架构设计等相关知识。\n\n引用古人的一句话，来开始我们的征程！\n> “路漫漫其修远兮，吾将上下而求索！”\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"],"categories":["机器学习"]},{"title":"学习机器学习可能用到的数学","url":"/math/tpl.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3k2ld3hyx4q0.jpg)\n\n积分中值定理、微分中值定理\n\n---\n\n泰勒公式\n\n出发点：\n\n    用简单的熟悉的多项式来近似代替复杂的函数\n\n    易计算函数值，导数与积分仍是多项式\n\n    多项式由它的系数完全确定，其系数又由它在一点的函数值及其导数所确定。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6xln7bk35440.jpg)\n\n阶数\n\n阶乘：削弱高阶项的作用，让他晚一些起作用！\n\n<!-- more -->\n\n---\n\n拉格朗日乘子法\n\n求极值，并且带条件\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4d7j3hvxg760.jpg)\n\n---\n\n矩阵\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7kf4o4g1ei80.jpg)\n\n 矩阵不满足交换律 $$A*B \\ne B*A$$\n\n ![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7j26y9yr7r40.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7e70x8sfgq00.jpg)\n\n矩阵的秩： 矩阵中最大不相关向量的个数\n\n行秩 = 列秩\n\n二维 在秩为1的矩阵的作用下，会转换为一条线。\n二维，在秩为1的矩阵的作用下，还是保持为二维。\n\n矩阵 做 旋转、拉伸\n\n特征值 特征向量 特征空间\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.35a3lqh63wu0.jpg)\n\n一个矩阵有很多的特征向量，特征提取就是取$\\lambda$更大的特征向量\n\nSVD矩阵分解\n\n100W X 10W 稀疏矩阵 = 100W X 10 的矩阵 * 10 X 10W的矩阵\n\n基变换：旋转、伸缩坐标轴\n\n特征值分解\n\n$A = U*A*U^{-1}$\n\nU 特征向量 \nA 是对角阵，取最大的几个，他们就是代表。\n\n限制： N*N方阵\n\n$MN = MK*KK*KN$，其中K << N, 取10%的特征，占据的样本可能会超过99%（因为比较稀疏）\n\n---\n\n概率函数（概率质量函数）\n\n$p(x) = Prob(X = x)$\n\n概率分布，就是一个表格，表中罗列了随机变量X的所有取值以及其对应的概率。\n\n概率密度函数\n\n频率分布直方图，当分组越来越多，轮廓会变为一条曲线。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3s3afpjzgmo0.jpg)\n\n简单随机抽样，\n抽取的样本满足两点：\n（1）样本X1，2…Xn是相互独立的随机变量。\n（2）样本X1，X2.Xn与总体X同分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6mtlivhz1ys0.jpg)\n\n概率表达了在给定参数日时X=的可能性；而似然表示的是在给定样本X=时，参数的可能性！\n\n二维随机变量\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.zhvrg2wn4w0.jpg)\n\n联合概率分布，2 * 2表格\n\n二维随机变量(X,Y)的分布函数\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6hf4qer5oxk0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.39zcy7gk03m0.jpg)\n\n边缘概率分布\n$F_X(x) = P(X \\le x) $\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.qsgyvy3jf3k.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7d2k1suwjgw0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.fds0ah0bp6g.jpg)\n\n中心极限定理\n\n样本的平均值约等于总体的平均值。不管总体是什么分布，任意一个总体\n的样本平均值都会围绕在总体的整体平均值周围，并且呈正态分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3dnlhkacz3u0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.5o17vqnyt6g.jpg)\n\n正态分布\n\n二项式分布\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3khgm3xf8l00.jpg)\n\n做N次实验，成功概率是p， 则成功k次的概率服从以上分布。\n\n泊松分布\n\n泊松分布中使用了这些符号：\n·$\\lambda$是事件发生的速率；\n·t是时间间隔的长度；\n·X是该时间间隔内的事件数，其中，X称为泊松随机变量，X的概率分布称为泊松分布。\n·令$\\mu$表示长度为的间隔中的平均事件数。那么，$\\mu=\\lambda*t$。\n\n例如说一个医院中，每个病人来看病都是随机并独立的概率，则该医院一天（或者其他特定时间段，一小时，一周等等）接纳的病人总数可以看做是一个服从poisson分布的随机变量。但是为什么可以这样处理呢？通俗定义：假定一个事件在一段时间内随机发生，且符合以下条件：\n·（1）将该时间段无限分隔成若干个小的时间段，在这个接近于零的小时间段里，该事件发生一次的概率与这个极小时间段的长度成正比。\n·（2）在每一个极小时间段内，该事件发生两次及以上的概率恒等于零。\n·（3）该事件在不同的小时间段里，发生与否相互独立。\n则该事件称为poisson process。这个第二定义就更加利于大家理解了，回到医院的例子之中，如果我们把一天分成24个小时，或者24x60分钟，或者24x3600\n秒。时间分的越短，这个时间段里来病人的概率就越小（比如说医院在正午12点到正午12点又一毫秒之间来病人的概率是不是很接近于零？）。条件一符合。另\n外如果我们把时间分的很细很细，是不是同时来两个病人（或者两个以上的病人）就是不可能的事件？即使两个病人同时来，也总有一个人先迈步子跨进医院大\n门吧。条件二也符合。倒是条件三的要求比较苛刻。应用到实际例子中就是说病人们来医院的概率必须是相互独立的，如果不是，则不能看作是poisso分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.24ayqxutj8zk.jpg)\n\n均匀分布 uniform distribution\n\n卡方分布\n正态分布随机变量Xi的平方和服从卡方分布，有一个自由度参数$\\lambda$\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"]},{"title":"学习机器学习可能用到的数学","url":"/math/index.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3k2ld3hyx4q0.jpg)\n\n积分中值定理、微分中值定理\n\n---\n\n泰勒公式\n\n出发点：\n\n    用简单的熟悉的多项式来近似代替复杂的函数\n\n    易计算函数值，导数与积分仍是多项式\n\n    多项式由它的系数完全确定，其系数又由它在一点的函数值及其导数所确定。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6xln7bk35440.jpg)\n\n阶数\n\n阶乘：削弱高阶项的作用，让他晚一些起作用！\n\n<!-- more -->\n\n---\n\n拉格朗日乘子法\n\n求极值，并且带条件\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4d7j3hvxg760.jpg)\n\n---\n\n矩阵\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7kf4o4g1ei80.jpg)\n\n 矩阵不满足交换律 $$A*B \\ne B*A$$\n\n ![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7j26y9yr7r40.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7e70x8sfgq00.jpg)\n\n矩阵的秩： 矩阵中最大不相关向量的个数\n\n行秩 = 列秩\n\n二维 在秩为1的矩阵的作用下，会转换为一条线。\n二维，在秩为1的矩阵的作用下，还是保持为二维。\n\n矩阵 做 旋转、拉伸\n\n特征值 特征向量 特征空间\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.35a3lqh63wu0.jpg)\n\n一个矩阵有很多的特征向量，特征提取就是取$\\lambda$更大的特征向量\n\nSVD矩阵分解\n\n100W X 10W 稀疏矩阵 = 100W X 10 的矩阵 * 10 X 10W的矩阵\n\n基变换：旋转、伸缩坐标轴\n\n特征值分解\n\n$A = U*A*U^{-1}$\n\nU 特征向量 \nA 是对角阵，取最大的几个，他们就是代表。\n\n限制： N*N方阵\n\n$MN = MK*KK*KN$，其中K << N, 取10%的特征，占据的样本可能会超过99%（因为比较稀疏）\n\n---\n\n概率函数（概率质量函数）\n\n$p(x) = Prob(X = x)$\n\n概率分布，就是一个表格，表中罗列了随机变量X的所有取值以及其对应的概率。\n\n概率密度函数\n\n频率分布直方图，当分组越来越多，轮廓会变为一条曲线。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3s3afpjzgmo0.jpg)\n\n简单随机抽样，\n抽取的样本满足两点：\n（1）样本X1，2…Xn是相互独立的随机变量。\n（2）样本X1，X2.Xn与总体X同分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6mtlivhz1ys0.jpg)\n\n概率表达了在给定参数日时X=的可能性；而似然表示的是在给定样本X=时，参数的可能性！\n\n二维随机变量\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.zhvrg2wn4w0.jpg)\n\n联合概率分布，2 * 2表格\n\n二维随机变量(X,Y)的分布函数\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6hf4qer5oxk0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.39zcy7gk03m0.jpg)\n\n边缘概率分布\n$F_X(x) = P(X \\le x) $\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.qsgyvy3jf3k.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7d2k1suwjgw0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.fds0ah0bp6g.jpg)\n\n中心极限定理\n\n样本的平均值约等于总体的平均值。不管总体是什么分布，任意一个总体\n的样本平均值都会围绕在总体的整体平均值周围，并且呈正态分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3dnlhkacz3u0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.5o17vqnyt6g.jpg)\n\n正态分布\n\n二项式分布\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3khgm3xf8l00.jpg)\n\n做N次实验，成功概率是p， 则成功k次的概率服从以上分布。\n\n泊松分布\n\n泊松分布中使用了这些符号：\n·$\\lambda$是事件发生的速率；\n·t是时间间隔的长度；\n·X是该时间间隔内的事件数，其中，X称为泊松随机变量，X的概率分布称为泊松分布。\n·令$\\mu$表示长度为的间隔中的平均事件数。那么，$\\mu=\\lambda*t$。\n\n例如说一个医院中，每个病人来看病都是随机并独立的概率，则该医院一天（或者其他特定时间段，一小时，一周等等）接纳的病人总数可以看做是一个服从poisson分布的随机变量。但是为什么可以这样处理呢？通俗定义：假定一个事件在一段时间内随机发生，且符合以下条件：\n·（1）将该时间段无限分隔成若干个小的时间段，在这个接近于零的小时间段里，该事件发生一次的概率与这个极小时间段的长度成正比。\n·（2）在每一个极小时间段内，该事件发生两次及以上的概率恒等于零。\n·（3）该事件在不同的小时间段里，发生与否相互独立。\n则该事件称为poisson process。这个第二定义就更加利于大家理解了，回到医院的例子之中，如果我们把一天分成24个小时，或者24x60分钟，或者24x3600\n秒。时间分的越短，这个时间段里来病人的概率就越小（比如说医院在正午12点到正午12点又一毫秒之间来病人的概率是不是很接近于零？）。条件一符合。另\n外如果我们把时间分的很细很细，是不是同时来两个病人（或者两个以上的病人）就是不可能的事件？即使两个病人同时来，也总有一个人先迈步子跨进医院大\n门吧。条件二也符合。倒是条件三的要求比较苛刻。应用到实际例子中就是说病人们来医院的概率必须是相互独立的，如果不是，则不能看作是poisso分布。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.24ayqxutj8zk.jpg)\n\n均匀分布 uniform distribution\n\n卡方分布\n正态分布随机变量Xi的平方和服从卡方分布，有一个自由度参数$\\lambda$\n\nbeta分布\n\n可以看作一个概率的概率分布， 当你不知道一个东西的具体概率是多少时， 它可以给出了所有概率出现的可能性大小\n\n$\\alpha$ 跟 $\\beta$ 分别为先验的成功次数与失败次数；概率密度函数的输入是X(是一个概率值)， 输出也是一个概率，表示的是该事件成功率 = X的概率。\n\n---\n\n\n核函数\n\n为什么：\n\n如果我的数据有足够多的可利用的信息，那么我可以直接做我喜欢的事了，但是现在如果没有那么多的信息，我可不可以在数学上进行一些投机呢？\n\n低维（比如我只知道一个人的年龄，性别，那我能对她多了解吗？）\n高维（比如我知道他从出生开始，做过哪些事，赚过哪些钱等）\n\n如果我们对数据更好的了解（是机器去了解他们，我们不需要认识啦）得到的结果不也会更好嘛。\n \n低维度 =》 高维度\n\n低维不可分\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3d1u3wbplqu0.webp)\n\nlinear 核函数\n\n特征已经比较丰富了，样本数据量巨大， 需要进行实时得出结果的问题。\n\n一种计算向量内积的数学技巧\n\n多项式核函数\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.55un8ls0oc00.webp)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3wcw6an7gi20.webp)\n\n高斯核函数\n\n一维高斯核函数（正态分布）、二维高斯核函数\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.1zn6kly1z8kg.webp)\n\n---\n\n信息熵\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3iaoumor3r60.webp)\n\nlog的作用是把一个很小的概率p变为一个绝对值很大的数！\n\n对于分类任务，结果的熵越下，说明效果越好。\n\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"]},{"title":"逻辑回归","url":"/ai/logistic_regression.html","content":"\n逻辑回归，是一种分类算法，而并非回归算法。\n\n逻辑回归要解决的问题是，给你一组样本以及标签，你基于这些数据去训练你的模型。然后我再给你一个新的样本，你告诉我有多大概率的属于某一个分类【二分类问题，黑还是白】\n\n\n$Y = \\theta * X + \\epsilon $\n\n我们现在的目标是找到一组$\\theta$可以让它乘以X之后尽可能的匹配Y\n\n$\\epsilon$为误差，服从均值为0，方差为$\\mu^2$的正态分布\n\n预测值与真实值之间有误差\n\n学习的关键在于：确定什么样的参数最符合于你的目标\n\n我们的目标是什么？ 让误差项尽可能的小，接近于0，loss函数等于0\n\n条件概率：$$p(y|x;\\theta) = p(\\epsilon^{(i)}) $$ 也服从正态分布。\n\n对于某一个样本，要找到一个theta， 跟x组合之后，成为真实值y的可能性最大\n\n<!-- more -->\n\n### 从误差的正态分布得到\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6a7a9c3m0ak0.jpg)\n\n上图啥意思呢？上图最后得到了一个概率密度函数，表示在$\\theta$，跟$x^{(i)}$组合之后得到$y^{(i)}$的可能性（也就是概率）\n\n### 最大似然函数\n\n上面的概率函数，通俗来讲“要找到一个$\\theta$，跟$x^{(i)}$组合之后，成为$y^{(i)}$的可能性，越大越好”\n\n假设去了赌场（赌场中有一个固定的暗箱操作套路$\\theta$),我们现在尝试去猜测这种套路？\n\n来了一个人，我们按照这个套路去猜，猜对了，概率很高；\n又来了一个人，我们还是按照这个套路取材，猜对了，概率也很高...\n最有，我观察的人足够多之后，我们才敢宣称，我猜对了赌场的套路。\n\n同样的，我们需要找到一组参数，匹配所有样本的概率尽可能的大，也就是说下面的概率最大\n\n$p(y^{(1)},y^{(2)},...,y^{(n)}|\\theta;x^{(1)},x^{(2)},...,x^{(n)})$\n\n那么这个概率是多少呢？\n\n又因为每一个样本的误差都是独立同分布的，所以联合概率等于每一个边缘概率的乘积，也就说：\n\n$$p(y^{(1)},y^{(2)},...,y^{(n)}|\\theta;x^{(1)},x^{(2)},...,x^{(n)})=p(y^{(1)}|\\theta;x^{(1)}) * p(y^{(2)}|\\theta;x^{(2)}) * ... * p(y^{(n)}|\\theta;x^{(n)})$$\n\n也就是下面的公式\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.2re3lgi8a8o0.jpg)\n\n有了上面的累乘之后呢？我们如何求解到一个合适的$\\theta$让上面的概率最大呢？不太容易，因为是乘法。\n\n【启发思考】对于乘法，我们一般会取log，将其转换为加法，也就变成了上图中的“对数似然函数”\n\n#### 最小二乘法为啥可以作为线性回归的损失函数\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6n95l5gksgs0.jpg)\n\n如上图，我们对对数似然函数进行化简得到一个结论，我们想要对数似然函数最大，等价于让$J(\\theta)$最小；这也就是我们通常听到的“最小二乘法”，也就是线性规划算法的**目标函数**\n\n#### 最优化常用解法之-梯度下降\n\n最优化问题有很多解法，我们这里先介绍最常见的梯度下降算法【Gradient Descent】\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7gdzrxx0pxw0.webp)\n\n梯度，就是函数的导数。如果自变量有多个，我们就针对每一个自变量($\\theta_1,\\theta_0$)求偏导。\n\n求导时，你可能需要知道的**求导链式法则**。\n\n对于要迭代的每一步执行以下步骤：\n\n![梯度迭代](https://img-blog.csdn.net/20171013161617617)，其中$\\alpha$为学习率。\n\n学习率太高，步子迈得太大，容易跑偏，从而错过极值点；学习率太低，步子过小，算法收敛的会特别慢，程序运行会比较慢。\n\n- 批量梯度下降\n- 随机梯度下降\n- miniBatch梯度下降\n\n参考：https://www.bilibili.com/video/BV1uM411r7Cv?p=4&vd_source=9a48b33279c3ad3689807d049311d0ee"},{"title":"指数分布族","url":"/ai/exp_set.html","content":"\n## 1. 指数分布族\n\n指数族分布是一大类分布，基本形式为：\n\n![指数族分布](https://images2015.cnblogs.com/blog/798706/201705/798706-20170507141449601-502615027.png)\n\n分布函数框架中的h(x),η(θ),T(x)和A(θ)并不是任意定义的，每一部分都有其特殊的意义。\n\nθ是自然参数(natural parameter)，通常是一个实数；\n\nh(x)是底层观测值（underlying measure）；\n\nT(x)是充分统计量（sufficient statistic）；\n\nA(θ)被称为对数规则化（log normalizer）。\n\n<!-- more -->\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n\n参考：https://www.cnblogs.com/sddai/p/11279007.html","tags":["机器学习"]},{"title":"特征工程","url":"/ai/feature.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n特征预处理：\n\n- 非线性化：多项式、sin\n- 标准化：$$\\frac {x - \\mu} {1 + \\sigma}$$\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"]},{"title":"损失函数最优化","url":"/ai/minimize.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n\n正则化:\n\n- 岭回归\n- lasso\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"]},{"title":"模型验证","url":"/ai/validation.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n针对样本的不足，我们通常采用：交叉验证\n\n模型评估：\n\n- 混淆矩阵\n- 准确率、召回率\n- F1 score\n- RAC曲线\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["机器学习"]},{"title":"Tair介绍","url":"/backend_knowledge_architecture/store/tair.html","content":"\n在高吞吐、大连接数、热点请求、异常流量、复杂计算逻辑、弹性伸缩这些真实场景下保持稳定的低延时，是 Tair 能够在低延时场景被选择的关键因素。\n\n<!-- more -->\n\n## 低延时\n\n### 存储介质\n\n索引数据，与 真实数据 采用不同的存储介质\n\n除了存储介质的延时，通常我们还需要关心的是介质的成本。成本一方面是从硬件上，Tair 是率先采用 SCM 的云产品，相对于 DRAM，SCM 的密度更高能支持持久化，且成本更低。上面提到的三部分数据结构中， Tuple 和 String Pool 是主要占用数据的空间，存放在空间更大的 SCM 上，Index 需要频繁访问且占用空间更低，存放在空间较小延时更低的 DRAM 上。\n\n索引数据，全内存，延时<100ns\n真实数据，云存储,延时 <=300ns\n\n另外一方面是从**数据结构**上去降低成本，这里的技术手段包括，设计更友好的数据结构和碎片整理的机制、进行透明的数据压缩。Tair 中会以 Page 为单位来管理 Tuple，随着数据的删除，每个 Page 会有一些空闲的 Tuple，存储引擎会按照空闲率来对 Page 分组，当整体的空闲率高于一定阈值（默认是 10%）时，就会试图根据空闲率进行页的合并\n\nTair 目前在使用的索引主要有 HashTable、SkipList、RBTree、RTree、Number Tree、Inverted index 等，分别应用于不同的场景。索引和需要服务的模型是相关联的，比如如果服务的主要模型是 Key-Value，那么主索引使用 HashTable 来达到 O（1）的时间复杂度，ZSet 涉及到数据排序和排名的获取，所以 Zset 使用了一个可以在查找时同时获取 Rank 的 Skiplist 作为索引。排序场景使用 SkipList 作为索引是内存数据库中比较常见的方案，相较于 BTree 来说，由于没有 Structure Modification，更易于实现并发和无锁，当然，也会增加一些 Footprint。在 Table 存储中，使用 RBTree 作为排序索引，在数据量达到 10k 的场景下，RBTree 能够提供更稳定的访问延时和更低的内存占用。\n\n在数据库系统中，索引能力的增强还可以让执行器对外暴露更强的算子，比如 Tair 中的 RBTree 提供了快速计算两个值之间 Count 的能力，对外提供了 IndexCountOperator，这样类似于 Select count(*) from person where age >= 8 and age <= 25 的查询就可以直接使用 IndexCountOperator 来获取结果，无需朴素地调用 IndexScanOperator -> AggregateOperator对索引进行扫描才得出结果。\n\n\n### 高并发\n\n并发是低延时场景一个关键挑战。\n\n解法通常分为两种，\n\n一种是在存储引擎内部支持更细粒度的锁或者无锁的并发请求；还有一种是在存储引擎外部来进行线程模型的优化，\n\n保证某一部分数据（一般来说是一个分区）只被一个线程处理，这样就能够在单线程引擎之上构建出高吞吐的能力。【使用这种方式需要满足一些假设：对每个 Partition 的访问是均衡的；跨 Partition 的访问比较少】\n\n为了提升单机的处理能力，Tair 引入了 RCU 无锁引擎，实现内存 KV 引擎的无锁化访问，成倍提升了内存引擎的性能\n\n### 超大连接数\n\n连接数的限制是一个比较容易被忽略的约束。但在一个真实的系统中，连接数过多会给系统带来巨大的压力。比如说 Redis，即使在 6.0 支持了多 io 之后，能够支持的连接数也是有限的。而目前直接访问 Tair 的应用动辄有 100k 规模的容器数目，所以支持超多连接数是一个必选项。\n\n其中涉及到的技术主要是几方面：\n\na. 提高多线程 io 的能力，目前成熟的网络框架基本都有这个能力；\nb. 把 io 线程和 worker 线程解耦，这样可以独立增强 worker 的处理能力，避免对 io 产生阻塞，当然这个策略取决于 worker 的工作负载，对于单次处理延时稳定较小的场景，支持无锁并发后，整个链路使用 io 线程处理避免线程切换是更优的方案；\nc. 轻量化连接，把关联到连接上的业务逻辑和 io 功能剥离开，可以更加灵活地做针对性的优化，一些系统中连接对资源的消耗较大，一个连接需要消耗 ~10M 的内存资源，这样连接数就比较难以扩展了。\n\n### 水平扩展\n\nHA-Group 同一个进程处理好几个分段，对于[0~1023]分段，该进程是leader， 而对于[1024~2047]分段，该进程是follower。从而实现整个集群负载相对比较均衡。\n\n\n## 稳定性\n\n### 热点\n\n热点访问是商品维度、卖家维度的数据常常会遇到的一个挑战，热点方案也是 Tair 能够服务于低延时场景的关键能力。\n\n前面讲了水平扩展之后，用户的某个请求就会根据一定的规则（Hash、Range、List 等）路由到某一个分区上，如果存在热点访问，就会造成这一个分区的访问拥塞。\n\n处理热点有很多方案，比如**二级散列**，这种方案对于热点的读写可以做进一步拆分的场景是有用的，比如现在我们有一个卖家订单表，然后卖家 id 是分区列，则我们可以再以订单 id 做一次二级散列，解决一个大卖家导致的热点问题；目前淘宝大规模使用的 Tair 的 KV 引擎不满足使用二级散列的前提，一般来说商品的信息映射到 Tair 内就是某一个 Value，更新和读取都是原子的。\n\n所以 Tair 目前使用的方案是在一层进行散列，借助于和客户端的交互，将热点数据分散到集群当中的其它节点，共同来处理这个热点请求，当然这种方案需要应用接受热点在一定时间内的延迟更新。另外这种方案需要客户端和服务端协同，需要应用升级到对应的客户端才能使用。\n\n所以最新的 Tair 热点策略在兼容社区 Redis 的服务时使用了不同的方案，应用能够直接使用任一流行的开源客户端进行访问，因此需要在服务端提供独立的热点处理能力。目前的 Tair 热点能力是由 Proxy 来提供的，相对于 Tair 之前的方案，这种方案拥有更强大的弹性和更好的通用性。\n\n### 流控\n\n服务于多租户的数据库系统，解决资源隔离的问题通常需要对进行容量或者访问量的配额管理来保证 QoS。\n\n即使服务于单租户的系统，也需要在用户有突发异常流量时，保证系统的稳定性，识别出异常流量进行限制，保证正常流量不受影响，比如 Tair 中对于 慢 SQL 识别和阻断。\n\n再退一步，即使面对无法识别的异常流量，如果判断请求流量已经超过了服务的极限，按照正常的行为进行响应会对服务端造成风险，需要进行 Fast Fail，并保证服务端的可用性，达到可用性防御的目的，比如 Tair 在判断有客户端的 Output Buffer 超过一定内存阈值之后，就会强制 Kill 掉客户端连接；\n\n在判断目前排队的请求个数或者回包占用的内存超过一定阈值之后，就会构造一个流控的回包并回复给客户端。\n\n流控一般包含以下几部分内容：请求资源消耗的统计，这部分是为流控策略和行为提供数据支撑；流控的触发，一般是给资源消耗设定一个阈值，如果超过阈值就触发；流控的行为，这部分各个系统根据服务的场景会有较大的不同；最后的流控的恢复，也是就是资源消耗到达什么情况下解除流控。\n\n流控一般包含以下几部分内容：请求资源消耗的统计，这部分是为流控策略和行为提供数据支撑；流控的触发，一般是给资源消耗设定一个阈值，如果超过阈值就触发；流控的行为，这部分各个系统根据服务的场景会有较大的不同；最后的流控的恢复，也是就是资源消耗到达什么情况下解除流控。\n\n### 执行流程优化\n\n经典的 NoSQL 系统，提供的 API 都是和服务端的处理流程非常耦合的，比如说 Redis 提供了很多 API，光是 List 就有 20 多个接口。在服务端其实很多接口的执行过程中的步骤是比较类似的，比如说有一些 GenericXXX 的函数定义。我们再看看一般的 RDBMS 中的处理 SQL 的流程，一般是 解析（从 SQL 文本到 AST），然后是优化器编译 （把 AST 编译成算子，TableScan、Filter、Aggregate），然后是执行器来执行。\n\n类比到 Redis 中，用户传进来的就是 AST，且服务端已经预定了执行计划，直接执行就行了。如果我想使用 SQL，不想学习这么多 API，同时由于我的访问场景是比较固定的，比如进行**模板化**之后，只有十多种 SQL 语句，且访问的数据比较均衡，某一条特定的语句所有的参数用一条特定的索引就足够了，有没有办法在执行过程中省去解析、编译的开销来提高运行的效率？\n\n有很多同学可能已经想到了存储过程。是的，存储过程很多场景是在扩充表达能力，比如多条语句组成的存储过程，需要进行比较复杂的逻辑判断，单条语句存储过程本质上是在灵活性和性能上进行折衷。Tair 所有线上运行的 SQL 都是**预先创建存储过程**的，这样进行访问就类似于调用 Redis 的一个 API 了，这是在复杂计算逻辑的场景下保证低延时的一种方案。\n\n\n参考：https://mp.weixin.qq.com/s/kQ-U9eGHmeFiwLf_BO-ykA","tags":["存储"]},{"title":"股票买卖问题-限定两次","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/stock_k.html","content":"\n假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益\n\n1. 你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票\n2. 如果不能获取收益，请返回0\n3. 假设买入卖出均无手续费\n\n<!-- more -->\n\n```cpp\n\nconst int N = 1e5 + 1;\n//dp[i][k][0]; 第i天时，当前空仓，不持有股票，可交易次数\n//dp[i][k][1]，第i天时，当前满仓，持有股票，，可交易次数\nint dp[N][3][2];\n\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     * 两次交易所能获得的最大收益\n     * @param prices int整型vector 股票每一天的价格\n     * @return int整型\n     */\n    int maxProfit(vector<int>& prices) {\n        //状态，选择\n        /*\n        for (int i = 0; i < prices.size(); ++i) {\n            dp[i][0][0] = 0;\n            dp[i][0][1] = INT32_MIN;\n        }*/\n        //第-1天，不持仓 == 0\n        //第-1天，持仓 === -INF\n        //第i天，0交易次数，0 = 0\n        //第i天，0交易次数，1 = -INF\n\n        for (int i = 0; i < prices.size(); ++i) {\n            for (int k = 2; k >= 1; k--) {\n                if (i == 0) {\n                    dp[i][k][1] = -prices[i]; /* dp[i - 1][k-1][0] - prices[i] 前半部分等于0*/\n                    dp[i][k][0] = 0;\n                    continue;\n                }\n\n                //对于持仓状态，由前一天的买入状态、前一天的rest变化而来；\n                dp[i][k][1] = max(\n                    dp[i - 1][k-1][0] - prices[i], //选择买入\n                    dp[i - 1][k][1]               //保持不变\n                );\n                //对于空仓状态，由前一天的卖出状态、前一天的rest变化而来；\n                dp[i][k][0] = max(\n                    dp[i - 1][k][1] + prices[i],  //选择卖出\n                    dp[i - 1][k][0]\n                );\n            }\n        }\n\n        return dp[prices.size() - 1][2][0];\n    }\n};\n```","tags":["动态规划"]},{"title":"模版","url":"/work/tpl.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n之前总有一些年轻人问我，我应该了解哪些知识才能像某某某那么牛B。\n这句话的意思其实就是：他们特别困惑，想知道一个后端程序员的知识体系，想知道从哪开始学起。\n\n关于这个问题，琢磨了好久，我不想简单的一句话就敷衍过去了，这个问题我要深思熟虑去回答。\n因为如果 10 年前有人告诉我这个问题的答案，现在的我将少走很多的弯路，技术水平也会更上一层楼。\n\n简单说一下全文的结构，全文一共分为四大部分。第一部分，主要从硬件、操作系统、网络、数据结构&算法等几个方面跟大家聊一下计算机科学相关的基础知识。第二部分，讲一下设计一款高性能的服务框架，应该从哪些方面着手；第三部分，讲一下平常工作中使用最频繁的知识-数据库、缓存以及一些相关的经典问题；最后第四部分，讲述的侧重点从第二部分的微观转到相对宏观的内容，跟大家聊一下分布式系统、大型架构设计等相关知识。\n\n引用古人的一句话，来开始我们的征程！\n> “路漫漫其修远兮，吾将上下而求索！”\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n","tags":["知识体系"]},{"title":"机器学习-总体认识","url":"/ai/index.html","content":"\n## 0. 背景介绍，把人吸引过来\n\n之前总有一些年轻人问我，我应该了解哪些知识才能像某某某那么牛B。\n这句话的意思其实就是：他们特别困惑，想知道一个后端程序员的知识体系，想知道从哪开始学起。\n\n关于这个问题，琢磨了好久，我不想简单的一句话就敷衍过去了，这个问题我要深思熟虑去回答。\n因为如果 10 年前有人告诉我这个问题的答案，现在的我将少走很多的弯路，技术水平也会更上一层楼。\n\n简单说一下全文的结构，全文一共分为四大部分。第一部分，主要从硬件、操作系统、网络、数据结构&算法等几个方面跟大家聊一下计算机科学相关的基础知识。第二部分，讲一下设计一款高性能的服务框架，应该从哪些方面着手；第三部分，讲一下平常工作中使用最频繁的知识-数据库、缓存以及一些相关的经典问题；最后第四部分，讲述的侧重点从第二部分的微观转到相对宏观的内容，跟大家聊一下分布式系统、大型架构设计等相关知识。\n\n引用古人的一句话，来开始我们的征程！\n> “路漫漫其修远兮，吾将上下而求索！”\n\n<!-- more -->\n\n## 1. 是什么，XXX的本质\n\n## 2. 为什么：XXX的价值\n\n## 3. 怎么办：XXX带给我们的方法论\n\n参考：\n\nhttps://blog.csdn.net/fenglepeng/article/details/104507404\n\nhttps://blog.csdn.net/algorithmPro/article/details/103045824","tags":["机器学习"]},{"title":"线性回归-linear regression","url":"/ai/linear_regression.html","content":"\n$Y = \\theta * X + \\epsilon $\n\n我们现在的目标是找到一组$\\theta$可以让它乘以X之后尽可能的匹配Y\n\n$\\epsilon$为误差，服从均值为0，方差为$\\mu^2$的正态分布\n\n预测值与真实值之间有误差\n\n学习的关键在于：确定什么样的参数最符合于你的目标\n\n我们的目标是什么？ 让误差项尽可能的小，接近于0，loss函数等于0\n\n条件概率：$$p(y|x;\\theta) = p(\\epsilon^{(i)}) $$ 也服从正态分布。\n\n对于某一个样本，要找到一个theta， 跟x组合之后，成为真实值y的可能性最大\n\n<!-- more -->\n\n### 从误差的正态分布得到\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6a7a9c3m0ak0.jpg)\n\n上图啥意思呢？上图最后得到了一个概率密度函数，表示在$\\theta$，跟$x^{(i)}$组合之后得到$y^{(i)}$的可能性（也就是概率）\n\n### 最大似然函数\n\n上面的概率函数，通俗来讲“要找到一个$\\theta$，跟$x^{(i)}$组合之后，成为$y^{(i)}$的可能性，越大越好”\n\n假设去了赌场（赌场中有一个固定的暗箱操作套路$\\theta$),我们现在尝试去猜测这种套路？\n\n来了一个人，我们按照这个套路去猜，猜对了，概率很高；\n又来了一个人，我们还是按照这个套路取材，猜对了，概率也很高...\n最有，我观察的人足够多之后，我们才敢宣称，我猜对了赌场的套路。\n\n同样的，我们需要找到一组参数，匹配所有样本的概率尽可能的大，也就是说下面的概率最大\n\n$p(y^{(1)},y^{(2)},...,y^{(n)}|\\theta;x^{(1)},x^{(2)},...,x^{(n)})$\n\n那么这个概率是多少呢？\n\n又因为每一个样本的误差都是独立同分布的，所以联合概率等于每一个边缘概率的乘积，也就说：\n\n$$p(y^{(1)},y^{(2)},...,y^{(n)}|\\theta;x^{(1)},x^{(2)},...,x^{(n)})=p(y^{(1)}|\\theta;x^{(1)}) * p(y^{(2)}|\\theta;x^{(2)}) * ... * p(y^{(n)}|\\theta;x^{(n)})$$\n\n也就是下面的公式\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.2re3lgi8a8o0.jpg)\n\n有了上面的累乘之后呢？我们如何求解到一个合适的$\\theta$让上面的概率最大呢？不太容易，因为是乘法。\n\n【启发思考】对于乘法，我们一般会取log，将其转换为加法，也就变成了上图中的“对数似然函数”\n\n#### 最小二乘法为啥可以作为线性回归的损失函数\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6n95l5gksgs0.jpg)\n\n如上图，我们对对数似然函数进行化简得到一个结论，我们想要对数似然函数最大，等价于让$J(\\theta)$最小；这也就是我们通常听到的“最小二乘法”，也就是线性规划算法的**目标函数**\n\n#### 最优化常用解法之-梯度下降\n\n最优化问题有很多解法，我们这里先介绍最常见的梯度下降算法【Gradient Descent】\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.7gdzrxx0pxw0.webp)\n\n梯度，就是函数的导数。如果自变量有多个，我们就针对每一个自变量($\\theta_1,\\theta_0$)求偏导。\n\n求导时，你可能需要知道的**求导链式法则**。\n\n对于要迭代的每一步执行以下步骤：\n\n![梯度迭代](https://img-blog.csdn.net/20171013161617617)，其中$\\alpha$为学习率。\n\n学习率太高，步子迈得太大，容易跑偏，从而错过极值点；学习率太低，步子过小，算法收敛的会特别慢，程序运行会比较慢。\n\n- 批量梯度下降\n- 随机梯度下降\n- miniBatch梯度下降\n\n参考：https://www.bilibili.com/video/BV1uM411r7Cv?p=4&vd_source=9a48b33279c3ad3689807d049311d0ee"},{"title":"sk learn介绍","url":"/ai/sk_learn.html","content":"\nsk learn的六大功能：\n\n分类\n\n回归\n\n聚类\n\n\n预处理\n\n模型选择\n\n降维\n\n8:2 \ncross validation\n\nTraining 切成N份（例如10）\n\n选前9份，进行交叉验证，对结果进行平均（准确率一般平均）。\nValidation 验证数据\n\n\nTesting 比较宝贵\n\n\nconfusion matrix 混淆矩阵，relative with 召回率，准确率\n\nTruePostive     FalsePostive\nFalseNegative   TrueNegative    \n\nTrue 做到了； \nPostive 正类\n\n\n评价指标有几个：\n\nrecall 召回率\n\nprecision 准确率\n\nF1 score (调和平均数) = 2 / （1 + precision） + 1 (1 + recall) 给予低值更高的权重\n\nvarious **thresholds**(阈值就是要求，越高越严格！) 跟 score比较 \n\npredict = score > thresholds : True : False\n\n随着thresholds从低到高，精确率上升，召回率降低；\n\n准确率-召回率曲线\n\nROC curves (ROC曲线)\n\nAUC 测量曲线下面积（综合评估），最好是1，最差是0.5\n\n"},{"title":"数学公式用法","url":"/ai/math.html","content":"\nhttps://blog.csdn.net/fencecat/article/details/123530441\n\n$$f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma}{\\rm e} ^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$\n\n$$f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma}\\exp\\left [ {-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\right ]$$\n\n\n$$\\lim\\limits_{N\\to \\infty} P \\left\\{ \\left|\\frac{I(\\alpha_{i})}{N}-H(s) \\right| <\\varepsilon\\right\\}=1$$\n\n$$\\frac{\\partial f}{\\partial x}|_{x=0}$$\n$$\\left.\\frac{\\partial f}{\\partial x}\\right|_{x=0}$$\n"},{"title":"更好的代码","url":"/backend_knowledge_architecture/code/better_code.html","content":"\n“好”的代码与“坏”的代码\n虽然对于“什么是优秀的代码“难以形成一致意见，但是这么多年的经验，让我对代\n码“好”与“坏”积累了一些自己的看法。\n比如说，“好”的代码应该：\n\n1.容易理解；\n2.没有明显的安全问题：\n3.能够满足最关键的需求；\n4.有充分的注释：\n5.使用规范的命名；\n6.经过充分的测试。\n\n“坏”的代码包括：\n1.难以阅读的代码：\n2.浪费大量计算机资源的代码：\n3.代码风格混乱的代码：\n4.复杂的、不直观的代码：\n5.没有经过适当测试的代码。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.41pzc88d5ge0.jpg)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.29ucrvenk9lw.jpg)\n\n这种阅读起来的确定性至少有三点好处，第一点是可以减少代码错误；第二点是可以节省我思考的时间；第三点是可以节省代码阅读者的时间。\n\n减少错误、节省时间，是我们现在选择编码方式的一个最基本的原则。"},{"title":"快速排序","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/quick_sort/qsort.html","content":"\n两个考察点：分治、双指针实现快速partition\n\n时间复杂度：\n\n平均 lgn;\n最坏：n^2\n最好：\n\n```cpp\n//快速排序算法模板\nvoid quick_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n    while (i < j)\n    {\n        do i ++ ; while (q[i] < x);\n        do j -- ; while (q[j] > x);\n        if (i < j) swap(q[i], q[j]);\n    }\n    quick_sort(q, l, j), quick_sort(q, j + 1, r);\n}\n\n下面这道题目是基于快排思想的TopK，他们的partion逻辑不太一样，其中一个很重要的点在于：\nquickselect要求把输入分成了三部分，[<=X] X [>X]；\n而上面的quicksort只是把输入分成了两部分，[<X],[>=X]或者[<=X], [>X]\n分割点在某一区间内，但是不一定在区间的两端；\n\n```cpp\nclass Solution {\npublic:\n    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {\n        qselect(input, 0, input.size() - 1, k);\n        vector<int> res(k);\n        for (int i = 0; i < k; ++i) {\n            res[i] = input[i];\n        }\n        return res;\n    }\n\n    void qselect(vector<int>& q, int l, int r, int k) {\n        if (l >= r) return;\n        \n        int i = l, j = r, x = q[l];\n        while (i < j) {\n            while(i < j && q[j] > x) j--; //优先从j开始\n            q[i] = q[j];\n            while (i < j && q[i] < x) i++;  //注意<=，而不能是<\n            q[j] = q[i]\n        }  \n        a[i] = x;\n\n        //qselect(q, l, j, k);\n        //qselect(q, j + 1, r, k);\n        \n        if (i - l + 1 == k ) return;\n        else if (i - l + 1 < k) qselect(q, j + 1, r, k - (i - l + 1)); \n        else  qselect(q, l, j - 1, k);\n    }\n};\n```\n\n对于有序数组，上面把start作为Pivot的方法，会让算法时间复杂度退化为O(N^2),导致超时。\n对数组进行shuffle，能解决有序数组的问题，但是无法解决所有元素全部相同的问题。当所有元素都一样时，shuffle无用，时间复杂度还是O(N^2)\n于是就有了下面的解法。这种方法，返回了中间区域的左右边界，让问题迅速简化！\n\n```cpp\n\nvoid quick_sort_3part(int q[], int l, int r) {\n    if (l >= r) return;\n    \n    swap(q[l], q[l + rand() % (r - l + 1)]); //随机化\n    int lt = l, gt = r, i = l + 1, x = q[l];\n    // 6,4,1,3,6,6,6,6,4,3,10,45,32\n    // |     |       |     |\n    // l    lt      i     gt\n    // 三路快排，确定等于主元pivot的左右边界\n    while (i <= gt) {\n        if (q[i] < x) swap(q[i++], q[++lt]);  //gt左边的元素都比x大，但是gt指向的不一定大\n        else if (q[i] > x) swap(q[i], q[gt--]);//把比x大的元素，换到后面了；但换回来的元素不一定“满足条件”，所以i不能变，需要再比较一次！\n        else i++;// 等于主元，则继续\n    }\n    swap(q[l], q[lt]);\n\n    quick_sort_3part(q, l, lt - 1);\n    quick_sort_3part(q, gt + 1, r);\n}\n```\n","tags":["排序","快速排序"],"categories":["数据结构与算法"]},{"title":"贪心-分糖果问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/greedy/candy.html","content":"\n一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下：\n\n1. 每个孩子不管得分多少，起码分到一个糖果。\n2. 任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制)\n\n给定一个数组 arrarr 代表得分数组，请返回最少需要多少糖果。\n\n要求: 时间复杂度为 O(n)O(n) 空间复杂度为 O(n)O(n)\n\n```cpp\n\nclass Solution {\npublic:\n    /**\n     * pick candy\n     * @param arr int整型vector the array\n     * @return int整型\n     */\n    int candy(vector<int>& arr) {\n        //正向遍历一次，满足了中间大于左边时的要求；\n        vector<int> s(arr.size(), 1);\n        for (int i = 1;i < arr.size(); i++){\n            if (arr[i] > arr[i - 1]) {\n                s[i] = s[i - 1] + 1;\n            }\n        }\n\n        //逆向遍历一遍，继续满足中间大于右边时的要求\n        for (int i = arr.size() - 2; i >= 0; i--) {\n            if (arr[i] > arr[i + 1] && s[i] <= s[i + 1]) {\n                s[i] = s[i + 1] + 1;\n            }\n        }\n\n        int res = 0;\n        for (auto x : s) {\n            res += x;\n        }\n\n        return res;\n    }\n};\n```","tags":["贪心"],"categories":["数据结构与算法"]},{"title":"链表系列-删除重复节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/delete_duplicated.html","content":"\n```cpp\n/**\n * struct ListNode {\n *\tint val;\n *\tstruct ListNode *next;\n * };\n */\n\nclass Solution {\npublic:\n    /**\n     * \n     * @param head ListNode类 \n     * @return ListNode类\n     */\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* pre = new ListNode(-100000);\n        ListNode* nHead = pre, *tail = pre;\n        int preCnt = 2;\n        while (head) {\n            if (head->val == pre->val) { //如果当前元素 与 前一个元素；\n                preCnt++;\n            } else {\n                if (preCnt == 1) { //如果前面的元素出现一次\n                    tail->next = pre;\n                    tail = pre;\n                    tail->next = NULL;   \n                } \n                pre = head;\n                preCnt = 1;\n            }\n            head = head->next;\n        }\n\n        if (preCnt == 1) {\n            tail->next = pre;\n            pre->next = NULL;\n        }\n\n        return nHead->next;\n    }\n};\n```\n","tags":["链表"],"categories":["数据结构与算法","剑指Offer"]},{"title":"回溯-N皇后问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/nqueue.html","content":"\n状态：已经填好的行数，每一行填在了哪些位置\n\n选择: 最多N种选择\n\n路径：放置了Queue的<u,j>位置的列表；\n\n结果集：列表的列表\n\n结束条件： 已经把所有的行数填写完；\n\n```cpp\nclass Solution {\npublic:\n    int res;\n    int Nqueen(int n) {\n        res = 0;\n        dfs(0, n, 0, 0, 0);\n        return res;\n    }\n\n    void dfs(int u, int n, int col, int pie, int na) {\n        if (u == n) {\n            res++;\n            return;\n        }\n\n        for (int j = 0; j < n; ++j) {\n            //用位运算来记录状态\n            //注意对角线的技巧\n            //左上 y = x + b;  b = (y - x + N) 来表现一条线！！\n            //右下 y = -x + b; b = (y + x) 来表现一条线！！\n            if ((col & 1 << j) || (pie & (1 << (n + u - j))) || (na & (1 << (u + j))))\n                continue;\n            //col，pie，na都是局部变量，不用保存现场\n            dfs(u + 1, n, col | (1 << j), pie | (1 << (n + u - j)), na  | (1 << (u + j)));\n        }\n    }\n};\n```\n","tags":["回溯"],"categories":["数据结构与算法"]},{"title":"计算机排序算法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/index.html","content":"\n![总](https://img-blog.csdnimg.cn/20210316213527859.png)\n\noutplace的都是稳定的；\noutplace的需要一定的memory， inplace中的qsort由于是递归的，所有需要lgn的mem，其他的都不要额外的内存\n\ninplace大多数都不稳定，除了冒泡排序、插入排序\n\n|算法|思想|衍生问题|\n|----|----|----|\n|quick sort|分治思想，借助双指针在$O(n)$时间内完成partition|线性第k大，线性求中位数|\n|merge sort|分治思想，双指针（稳定的）|逆序数|\n|heap sort|借助容器来实现排序，还有类似的BST中序遍历|topK问题|\n|counting sort|空间换时间，非比较；通过扫描min/max来支持负数，通过**累加和+倒序遍历来保持稳定**||\n|bucket sort|抽屉原理，稳定排序，适合元素值集合较小的情况，特别适合外部排序|排序后最大间隔问题、大整数文件取中位数问题|\n|radix sort|稳定子排序算法（计数排序、桶排序来实现）对数字进行k遍排序||\n|shell sort|分块思想，缩小增量排序，一种特殊的插入排序；递减序列的选择很重要|适用于基本有序序列|\n|insertion sort|减治思想，扑克牌|适用于基本有序序列\n|Bubble sort|稳定|\n\n\n\n\n","tags":["排序"],"categories":["数据结构与算法"]},{"title":"归并排序","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/merge_sort/index.html","content":"\n\n归并排序，是一种特别有用的排序算法；\n\n它背后的算法思想是 分治。\n\n归并排序同时也是一种思想，可以解决归并排序思想解决很多问题。\n\n例如，计算逆序数。\n\n```cpp\n//归并排序算法模板\nvoid merge_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n\n    int mid = l + r >>1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    vector<int> tmp(r -l + 1);\n    int k = 0, i = l, j = mid + 1;\n    while (i <= mid && j <= r ) {\n        if (q[i] < q[j]) tmp[k++] = q[i++];\n        else  tmp[k++] = q[j++];\n    }\n\n    while (i <= mid) tmp[k++] = q[i++];\n    while (j <= r) tmp[k++] = q[j++];\n\n    for (i = l, k = 0; i <= r; i++, k++) q[i] = tmp[k];\n}\n\n```\n\n","tags":["排序","归并排序"],"categories":["数据结构与算法","经典题目"]},{"title":"高性能服务器系列-线程池","url":"/backend_knowledge_architecture/server/thread_model/thread_pool.html","content":"\n### 核心参数\n\n1、corePoolSize:线程池中的常驻核心线程数\n\n2、maximumPoolSize：线程池能容纳同时执行的最大线程数，此值必须>=1\n\n3、keepAliveTime：多余的空闲线程的存活时间\n\n当前线程池数量超过corePoolSize时，当空闲的时间达到keepAliveTime值时，多余的空闲线程会被直接销毁直到只剩下corePoolSize个线程为止\n\n4、timeUtile：keepAliveTime的单位\n\n5、workQueue:任务队列，被提交但未被执行的任务\n\n6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。\n\n7、handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数\n\n\n### 工作流程\n\n线程池内部是通过队列+线程实现的，当我们利⽤线程池执⾏任务时：\n1. 如果此时线程池中的线程数量⼩于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建\n新的线程来处理被添加的任务。\n2. 如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放⼊\n缓冲队列。\n3. 如果此时线程池中的线程数量⼤于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数\n量⼩于maximumPoolSize，建新的线程来处理被添加的任务。\n4. 如果此时线程池中的线程数量⼤于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等\n于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。\n5. 当线程池中的线程数量⼤于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被\n终⽌。这样，线程池可以动态的调整池中的线程数\n\n\n### 合理线程数\n\nCPU密集型：CPU核数+1个线程的线程池\n\nIO密集型：a)CPU核数*2；b)CPU核数/(1-阻塞系数)。（阻塞系数：0.8～0.9）\n\n### 拒绝策略\n\n第一种拒绝策略是 AbortPolicy，这种拒绝策略在拒绝任务时，会直接抛出异常 RejectedExecutionException （属于RuntimeException），让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。\n\n第二种拒绝策略是 DiscardPolicy，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。\n\n第三种拒绝策略是 DiscardOldestPolicy，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。\n\n第四种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。\n\n第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。\n第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。\n \n ","tags":["高性能服务器"]},{"title":"用户增长","url":"/core/growth/user_growth.html","content":"\n用户增长的前提是你的产品是**满足需求**的，且与**市场是匹配**的（用户来了之后才能够留得住），但到达用户存在阻碍。\n\n所以用户增长的主要工作就是：要减少阻碍，降低交易成本（比如认知成本、信任成本、分享成本等等）。\n\n开始前，先问问自己 7 个与增长相关的基础问题，带着问题思考更高效。\n\n（1）XX公司的商业模式是什么？\n\n（2）XX公司所在的社会环境是什么？\n\n（3）XX公司处在企业生命周期的什么阶段？\n\n（4）XX公司的增长战略、增长策略、增长战术是什么？\n\n（5）XX公司的用户是谁？\n\n（6）XX公司当前是怎么做用户增长？\n\n（7）XX公司的北极星指标是什么？\n\n（因为）不同商业模式、不同阶段，则有不同的增长侧重。所以谈用户增长不能不谈**商业模式**、**社会大环境**、**企业生命周期**。\n\n"},{"title":"定时器系列｜时间轮","url":"/backend_knowledge_architecture/server/timer/time_wheel.html","content":"\n时间轮\n\n逻辑形式：时间轮\n\n实际结构：链表数组\n\n实现原理：\n\n最小轮子走一圈，它的上层轮子走一格。\n\n假设图中每层轮子为20个格子，第一层轮子最小时间间隔为1ms，第二层为20ms，第三层为400ms，此时添加5ms后执行的任务，此时应该添加到第一层的第5格子中。\n\n如果此时添加445ms后执行的任务，则第一层表示的时间跨度不够，第二层表示的时间跨度也不够，第三层表示的时间跨度足够，该任务应该放到第三层轮子第二格子中，该轮子指针指到第二格子中时，计算离任务启动时间还有多长时间，慢慢将该任务移动到底层轮子上，最终任务到期执行。\n\nHashedWheelTimer时间轮是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。\n\n```cpp\n\nclass TimeWheel {\n    void push() {\n         //利用当前时间与currentTs，计算目标offset。\n         //把事件插入到offset对应的ticks链表中\n    }\n\n    void pop() {\n        //利用当前时间与currentTs，计算目标offset。\n        //确认需要往前移动多少格\n\n        //把过期事件，trigger掉；\n\n        //然后移动currIdx与currentTs;\n    }\n\n    void background_thread() {\n        //每秒钟一次运行，exTicks中1s中后就要运行的item移动到ticks[(currentIdx - 1) % N]。\n        //此处考虑并发\n        //对currentIdx的读访问要考虑并发，可以考虑用原子变量\n        //对链表的访问可以用互斥锁（理论上：并不是有实际冲突，因为这个tick还有接近1分钟才会被访问到。）\n    }\n\n    map<ts, Item> exTicks; //超过1分钟的事件；\n    vector<List> ticks;  //假设60个格子，只能承载最近60s的事件。\n    currentIdx;\n    currentTs;\n};\n\n```","tags":["高性能服务器"]},{"title":"动态规划系列-最长回文子序列","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/longest_palindrome.html","content":"\n设dp[i][j]为从i到j的字符串，回文子序列的最大长度\n\nIF d[i] == d[j];\n    dp[i][j] = dp[i + 1][j - 1] + 2 \nELSE \n    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n如何遍历，通过图示法可以得知，首先沿着对角线，然后斜向上。\n\n!(图示)[https://pic3.zhimg.com/80/v2-1988e6664d09383c479fc879dcc419fa_1440w.webp]   ","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"一个非专业人士关于产品的思考","url":"/core/product/think_about_product.html","content":"\n作为一个时不时需要跟产品同学打交道的非专业人士（一介码农），有必要掌握一些一些关于产品的入门知识。\n\n下面的这几个问题，我觉得是最基础的。本文就结合梁宁老师的《产品思维30讲》来尝试着回答一下。\n\n1. 产品的本质是什么？\n2. 做产品的通用方法论是什么？\n3. 如何才能做出爆品？\n4. 产品创新有啥通用方法论吗？\n\n<!-- more -->\n\n---\n\n第一个问题，产品的本质是什么？\n\n我们首先考虑下你用过有哪些产品：\n产品，有时候是一项服务，例如理发。\n产品，有时候是一个实体，例如手机。\n产品，有时候是一个网站，例如 www.baidu.com\n产品，有时候是一个app，例如大众点评app\n\n等等，某一个能产生现金流的债权也有可能被证券化，打包成一款产品，供其他人来购买。\n\n让我们看一下百度百科上产品的定义：\n> 产品是指作为商品提供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。\n\n从上面的定义可以看出，关于产品最重要的一点就是：它需要能够满足用户的某种需求。\n\n用户需要被满足的需求有很多。例如，我老婆在购物时发现有一个商品一下买两个的话价格会便宜50%，可是呢？两个她又用不了。这时候，他就产生了一个需求：“如果有一个人跟我一起买就好了！”\n\n还有一点，好多时候用户在出现某一款产品来满足他的“需求“之前根本就没有需求。Jobs就说过，用户根本不知道自己想要什么。例如，在汽车出来之前，人们出行都是靠马车的。那个时候，用户能够说出自己的真正需求吗？\n\n说这么多，回答刚才的问题。产品的本质是什么？ 在我看来，产品就是用来满足用户需求的东西。这句话的重点不是主语，而是定语。好的产品与坏的产品的差别就在于：\n\n1. 相比坏产品，好的产品更好的满足用户的需求。用户用起来更爽，更顺手。\n2. 相比坏产品，好的产品满足了用户真正的需求。好的产品，直击要害。\n\n所以，做好一款产品，最重要的是就是**围绕着用户去思考，我可以解决哪些用户的哪些需求，给这些使用我产品的用户带来什么价值**。\n\n用一个公式来表示： 产品价值 = 细分用户 * 用户需求\n\n为什么要细分用户呢？ 因为不同的用户有不同的需求，而一个产品不可能满足所有用户的需求。\n\n---\n\n站在产品经理的视角，怎么看待一个人或者一款产品呢？\n\n首先是表面，\n\n1. 外在层，他长得如何，页面做的是否华丽。\n2. 角色层，他是做什么职业的\n\n其次是中间层，\n\n3. 资源层，他拥有多少财富、人脉、精神资源？\n\n最后是核心，\n\n4. 能力层，他能做成什么事情，这块产品给我提供什么确定性\n5. 存在感，为什么而存在，存在的价值是什么？\n\n---\n\n### 动用同理心，去洞察人性\n\n首先说人性，也就是四个生理情绪\n\n人，首先有需求，不是所有的需求都能得到满足。\n\n需求得到满足了，就会**愉悦**。\n\n需求憋了好久，终于得到满足了，就会**爽**。\n\n需求得不到满足，就会郁闷，就会**不爽**。\n\n接着，人活在世上，免不了与别人接触。\n\n在接触的过程中，如果自己的边界被侵犯了，我们就会**恐惧**。\n\n侵犯过程中，如果我们意识到对方没有那么强大，可以教训教训他，我们就会**愤怒**。\n\n恐惧是一个非常基本的情绪，好多其他情绪都是源于恐惧；例如刚才说的愤怒，是一种对自己无能的恐惧；羞耻，是一种对社会世俗眼光的恐惧等等。\n\n我们做产品，要么就满足用户的爽点，让用户愉悦；要么就解决用户的痛点，让用户不再恐惧。\n\n---\n\n接着，再谈意识与潜意识。\n\n对比一个好的销售与好的产品经理。销售擅长的是打破消费者“意识”的防御，但不管怎样，意识起作用了，”意识即防御“。\n\n对比看，一个好的产品经理，会充分考虑人性，遵从人的潜意识，顺应人性，让用户自然而然的做了某件事情，根本不会触及到意识的防御。\n\n这里提到了潜意识，潜意识的形成可能有两方面：童年、基于重复的催眠（洗脑）。其实本质是就是重复。\n\n从小到大，我们接触的最多的催眠，就是教育。\n\n---\n\n最后谈下的人的角色化与集体人格\n\n教育是反人性的，教育本质上讲就是通过不停的通过重复去按照社会想要的样子去塑造我们，让人们去角色化，成为集体的一部分。\n\n当然，集体人格不一定能够深入到人的潜意识当中。人们需要按照角色**应该的方式**的去做事情，但是内心并不顺从，并不自然。\n\n做产品，也是类似。用户不应该按我们要求的去做，而是用户在使用我们产品的过程中，很自然就做了某些事情。\n\n### 机会判断\n\n首先，点线面体思考框架\n\n点线面体本质上是高维思考，这种思考方式让我们不局限于当下的一个点，而是要进行维度升级，升级到线、面甚至是体。 这关乎格局，关乎对趋势的预判。\n\n例如，职业选择问题。 你在一家夕阳行业的公司争取一个高端职位的意义，不一定大于在一个朝阳行业公司做一个普通员工。\n\n有道是“胜与不胜在于彼，败与不败在于己”与“求之于势，不责于人”，说的也是这个道理。\n\n作为领导者，应该去修炼自己的格局，去抓更大的趋势，去做更维度的思考，而不要过分“责于人”，竟关注每一个员工小小的“点”的努力。\n\n---\n\n当然，规划产品时，一定要有切入点。这里的切入点前面提过，一共有三个：\n\n痛点： 帮客户解决了什么恐惧的问题；\n\n爽点：给用户带来了什么愉悦的感觉；\n\n痒点：产品有没有满足虚拟自我，想象中的自己； 网红产品、偶像剧就很大程度上满足了用户的痒点。\n\n这个切入点必须是真实的，具体的，不能是YY出来的，不能不痛不痒。\n\n---\n\n两套经典的用户画像\n\n第一个模型是草地模型。\n\n该模型把产品比喻成草地；\n\n产品的第一批用户，比喻成第一支羊。这只羊来到草地吃了草之后，是死了呢？还是很愉悦呢？ \n\n产品的核心用户，比喻成头羊。网络效应。\n\n产品的付费用户，比喻成狼。\n\n第二个模型是大明、笨笨、小闲\n\n大明：用户有明确的需求，对价格敏感，一般忠诚度不高。 例如：百度、京东。这类用户的爽点需求：平台提供的价格特别符合预期、系统提供的搜索结果满足了自己的需求。\n\n笨笨：用户不知道想要买什么，就是逛逛，看看自己需要什么。例如：小红书、淘宝。 这类用户的痒点需求：看到别的大V、明星的分享，特别羡慕，特别向往，所以追求。\n\n小闲：纯打发时间，例如腾讯玩游戏、看视频。这类用户的爽点需求：好装备掉落、推荐类似的、自动播放下一集等。\n\n---\n\n场景\n\n场景 = 时间、空间 + 情景、触发情绪\n\n人的理性、意识拉着你不去做，而人的潜意识、情绪推着你去做事情，这是不由自主的。\n\n例如，你读了一篇好的书摘，当你读完之后，你下意识最想做的事情是什么呢？ 很多用户肯定想把书下载下来（当然，将来看不看就不得而知了，😁）。此情此景下，我们的产品要做的事情就呼之欲出了：把电子书的下载链接放在文末。\n\n---\n\n### 系统能力\n\n\n\n\n","categories":["产品"]},{"title":"产品思维30讲摘要","url":"/core/product/liangning_chanpinsiwei30.html","content":"\n作为一个时不时需要跟产品同学打交道的非专业人士（一介码农），有必要掌握一些一些关于产品的入门知识。\n\n下面的这几个问题，我觉得是最基础的。本文就结合梁宁老师的《产品思维30讲》来尝试着回答一下。\n\n1. 产品的本质是什么？\n2. 做产品的通用方法论是什么？\n3. 如何才能做出爆品？\n4. 产品创新有啥通用方法论吗？\n\n---\n\n第一个问题，产品的本质是什么？\n\n我们首先考虑下你用过有哪些产品：\n产品，有时候是一项服务，例如理发。\n产品，有时候是一个实体，例如手机。\n产品，有时候是一个网站，例如 www.baidu.com\n产品，有时候是一个app，例如大众点评app\n\n等等，某一个能产生现金流的债权也有可能被证券化，打包成一款产品，供其他人来购买。\n\n让我们看一下百度百科上产品的定义：\n> 产品是指作为商品提供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。\n\n从上面的定义可以看出，关于产品最重要的一点就是：它需要能够满足用户的某种需求。\n\n用户需要被满足的需求有很多。例如，我老婆在购物时发现有一个商品一下买两个的话价格会便宜50%，可是呢？两个她又用不了。这时候，他就产生了一个需求：“如果有一个人跟我一起买就好了！”\n\n还有一点，好多时候用户在出现某一款产品来满足他的“需求“之前根本就没有需求。Jobs就说过，用户根本不知道自己想要什么。例如，在汽车出来之前，人们出行都是靠马车的。那个时候，用户能够说出自己的真正需求吗？\n\n说这么多，回答刚才的问题。产品的本质是什么？ 在我看来，产品就是用来满足用户需求的东西。这句话的重点不是主语，而是定语。好的产品与坏的产品的差别就在于：\n\n1. 相比坏产品，好的产品更好的满足用户的需求。用户用起来更爽，更顺手。\n2. 相比坏产品，好的产品满足了用户真正的需求。好的产品，直击要害。\n\n所以，做好一款产品，最重要的是就是**围绕着用户去思考，我可以解决哪些用户的哪些需求，给这些使用我产品的用户带来什么价值**。\n\n用一个公式来表示： 产品价值 = 细分用户 * 用户需求\n\n为什么要细分用户呢？ 因为不同的用户有不同的需求，而一个产品不可能满足所有用户的需求。\n\n---\n\n如何准确洞察用户的需求？\n\n了解人有哪些\n\n产品能力，就是这样训练一个人：\n判断信息，抓住要点，整合有限的资源，把自己的价值打包成一个产品向世界交付，并且获得收获。\n\n![产品思维](http://cdn.b5mang.com/2021219103712.png)\n\n微观视角\n同理心 人性 心理学\n\n![同理心](http://cdn.b5mang.com/2021219103743.png)\n\n用户体验，对人或者产品做一个体检：\n\n任何产品的5个层次，从表到里：\n\n【表层】感知层（让人直接感知到的外在）\n\n【表层】角色框架层（集体赋予你的人格，通过教育习得，角色化）\n\n资源结构层（一个人的财富、人脉、甚至精神资源，也就是一个人的历程）\n\n【内核】能力圈（扩充能力圈，极其痛苦）\n\n【内核】存在感（正是由于存在感不能被满足，才会去扩大自己的能力圈\n\n现在，我们再把一个人从外而内的五层再拎一遍：\n\n最外层是感知层，是你看到的一个人的样子，他的相貌、举止、着装。\n\n其实当你看到这个人的时候，你要知道有一部分是天生的，有一部分其实是角色化的产物。\n在感知层之内的第二层是角色框架层。\n\n在角色框架层的再往里的第三层是资源结构层，资源不只是大家一般都会认为的人脉和财产，还包括了一个人的精神结构和他的精神资源。\n\n在这个资源结构层再往后的一层就是能力圈，在能力圈的里面就是这个人对自己存在感的感知。\n所以，如果你明确知道自己想成为一个什么样的存在，你就会不断地改变自己的能力圈，改变自己的资源，然后甚至改变自己外在的样子。\n\n---\n学会读懂用户的情绪\n    用户不会分层次的表达自己的体验，只会表达自己的情绪。\n\n四种最基本的**生物性情绪**\n    愉悦、不爽、愤怒、恐惧\n\n满足\n\n愉悦，就是自己的个层面的需求被满足\n\n一个蹦了很久侧需求，突然被满足，就叫爽\n\n上瘾：（微小的愉悦感 + 突然被满足的爽感）= 确定性的满足\n\n不爽：就是不满足\n\n做产品：就是通过产品建立你与人之间的关系，通过产品来服务人，本质就是用户是否通过你的服务得到了满足。\n\n这就是上帝给你初始化的操作系统的密码，你不厌其烦的地方，就是你的天分所在。\n\n满足是度量产品、人与人关系的度量\n\n被侵犯，因为侵入者的体量不同，而出现不同的情绪：愤怒、恐惧\n\n愤怒：就是感觉到自己的边界被侵犯\n恐惧：就是感觉到自己的边界被侵犯，而无可奈何\n\n愤怒，就是一种恐惧，一种对自己无能的恐惧；羞耻感也是一种恐惧，一种对社会评论的恐惧；忧郁也是一种恐惧，来自无法逃避的想象的恐惧，一种持续的恐惧，内化为忧郁。\n\n恐惧\n\n恐惧是边界，看到了一个人怕什么，就看到了他的边界。\n\n恐惧是动力，害怕失去现在的好生活，害怕给不了家人更好的生活，所以采取努力。\n\n恐惧是痛点，做产品，要么满足人们让他爽，要么帮他们抵御恐惧。例如化妆产品可以抵御对青春逝去的恐惧，罗辑思维可以抵御人们对认知焦虑的恐惧。\n\n---\n\n因为人会基于自身所处的**角色**、所在的**场景**和个人的**认知**判断，**选择性**地说一些他觉得正确的话。\n\n优秀的销售人员（打破防御）与 优秀的产品经理（根本不让用户启动防御）\n\n基于意识清醒的交流，达成交易的唯一方式：“让对方感觉占了便宜” ---打破防御\n\n而好的产品经理，在于不让用户启动防御，顺应用户的潜意识。意识即防御。\n\n---\n\n潜意识：1）童年  2）催眠（本质就是绕过防御）-重复（手段）/集体人格\n\n集体人格 / 角色\n\n集体，一堆角色，集体人格\n\n集体人格的形成，角色化行为，就是一个人被教育的过程：\n\n确定目标：给人们树立什么的观念\n建立恐惧的边界（明确角色不可以做什么，如果违反了，就惩罚）\n放入清晰的标的（明确角色只能做什么）\n给予红利，然后让他产生路径依赖\n不断重复\n\n为什么通过教育让人形成集体人格呢？ 为了便于管理。所以，教育是违反人性的。\n\n教育是按照人类对社会的美好期望来教育你，换句话来讲教育是理想化的\n\n有经验的将军其实能够通过训练与管理，让一个集体的**集体人格短时间压倒个体的脆弱**。老大一声喊，大家就冲上去了，但是这是不得已才会发生的情况。\n\n---\n\n自然（自发，符合人性） 与 应该（被教育，反人性）\n\n人们只有在压力非常大的情况下，才会去扮演角色。除非你给他的压力非常到位，否则就不要对他做角色化预期。\n\n角色化生存，角色化生存就是我们真实的生存处境。产品经理应该去角色化得认识、沟通、交互，才能得到真正的感情。\n\n---\n\n自律 VS 自我，哪一个更贴近产品精神。\n\n做产品经理的人善于感知，在已有的结论上建立新观点。而做其他管理的人更善于逻辑推理和总结归纳。\n\n自律：靠恐惧驱动、规则边界，控制力是自律的延伸\n\n被认为算“左脑思维”的人：\n逻辑推理能力强、时间观念强，同时感受力差\n因为感受力差，所以没那么敏感和情绪化，整个人体现为情绪稳定，甚至刻板；\n更容易根据规则调适自己，更自律，更容易角色化。\n\n自我：靠愉悦驱动，创造力是自我的延伸。\n\n感受力强；\n能在别人已经有结论的地方，建立自己的新观察，并且不太喜欢听已有的逻辑；\n难以控制自己的情绪，能激情地表达自己，具有人格魅力。\n\n看到自己的愉悦和恐惧，看清自己的天分，看到别人的愉悦和恐惧，了解他们的潜意识与集体人格，不要触发他们的防御。\n\n---\n\n中观视角 日常产品工作视角\n\n机会判断（一套底层思维，三个具体方法）发现机会\n\n![机会判断](http://cdn.b5mang.com/2021219103816.png)\n\n机会判断\n\n点线面体思考框架\n\n穷人-点的努力\n中产-至少要获得一次线性周期的收益\n富人-借助面和体的崛起（国家、经济体、经济周期、产业、行业、领域）\n\n做一个产品的时候，入手只能是一个点；但是：\n这个点，是附着在哪个面（你在哪个公司上班）上？这个面是在和谁竞争，他能如何展开？\n这个面，是附着在那个经济体上？这个经济体是在崛起还是在沉没？\n\n1.描述一下，你现在的职业是什么样的一个点？\n2.你所在的公司或者业务肯定是需要串联很多点的一条线，那你的这个点是在公司这条线的什么位置上？\n3.这个公司附着在什么样的一个面上，谁在给你或你的公司赋能？这个面又是附着在哪个经济体上？\n就好像在地球仪上，找到自己的位置点一样，请你用点线面体的框架，尝试标一下自己的位置。\n\n---\n\n孙子兵法：\n\n胜与不胜在于彼，败与不败在于己。（《孙子兵法》的全篇核心就是这个概念，意思就是说：我能不能赢了你，其实我做不了主，这是你的问题；但是我会不会输，会不会打光所有的牌，会不会下桌走人，那是我自己的问题。）\n\n求之于势，不责于人。（一个人要做成一件事情，其本质上不在于你有多强，而是你要顺势而为，于万仞之上推千钧之石）\n\n作为领导者，要自己去寻找有势能的**面**，而不能寄希望于员工的点。反过来你要想，大家把自己最好的“点“都给了你。在一个时间周期之后，你会回报给大家什么样的线性收益呢？\n\n离开你情绪的点，去看线的方向，去预测这条线的周期，并且明确自己在周期的哪个位置，是哪个面再给你赋能。\n\n你在一条正弦曲线的哪个位置？ 这个曲线是往下的还是向上的？\n\n人生的选择远比努力更重要。\n你的个人努力，只是在点、线、面、体的既定框架内，作为一个点的挣扎而已。\n\n---\n\n从点开始：痛点、爽点、痒点都是产品机会\n\n表象之下：\n\n为什么？因为自我实现其实是一条漫长而痛苦的路。人的本性是懒惰的。你看到一个人展现出了勤奋、规整、自律，其实这是被一系列的恐惧（痛点）、集体人格、潜意识压迫，才会呈现出那个样子。\n\n痛点：就是恐惧，打中人的恐惧\n\n爽点：就是即时满足，用户有什么需求，你能够即时满足他\n\n痒点：就是满足虚拟自我，要满足用户想象中的自己。例如，网红产品的流行。\n\n---\n\n用户：两套经典的用户画像（其实两套用户画像系统）\n\n第一套：羊群与草地\n\n草地：你提供的产品，我们提供的草地，一定要让“第一只羊”爽，能够满足他们；\n\n第一只羊（关键角色）：你的首批用户，羊死了，或者羊在草地上玩的不爽\n\n你找到了这个用户，他可以在你这里得到即时满足玩得很开心，那么针对这只羊，针对这个用户的同类用户去做推广，你的产品就可以被快速地推开。\n\n头羊（关键角色）：核心用户，自组织，具备网络效应；头羊的数量决定了你的网络效应有多大。\n\n当你要评估一个产品或者一家公司的网络效应有多大时，一个非常简单的评估方式就是数一数它有多少头羊（比如说论坛的版主、Y公会的老大、微博的大V、重度用户、淘宝的店主，这些都是头羊。）\n\n狼：变现用户\n\n基本上所有玩互联网网络效应的、玩社区都是这一套用户画像。\n\n例子：摄影网站的版主、BBS天涯的版主、百度贴吧的版主、淘宝的买家\n\n第二套：大明、笨笨、小闲\n\n- 大明：对自己的需求非常明确、非常清晰（寻求的是价格、或者硬货；）\n\n大明用户需要的是搜索，因为他们对自动主动要找的东西是非常明确的。\n\n最早的互联网电商：找到自己想要的，然后比价格。京东的成功，源于强大的体量，对供应链的挤压能力越来越强，能够越来越好的服务好大明用户。\n\n用户特点：需求清晰明了（价格、帮我搞定事情）、没有忠诚度\n\n- 笨笨：我有大概的需求，但是没那么明确。\n\n女人买裙子，小红书，逛。\n\n笨笨变大明：逛到要买的东西后，开始追求最便宜的。但是，如果笨笨决定了要买什么产品，那么下一秒有70%-80%的概率，笨笨就会变成大明，然后开始去追求价格。\n\n一个经典场景是我在豆瓣东西上找买东西的灵感，接着到淘宝上去找最便宜的一件购买。\n\n- 小闲：我没有消费需求，我就是来打发时间的\n\n百度、京东服务小明，淘宝服务笨笨，那么腾讯就是服务小闲的。\n\nQQ、微信朋友圈、游戏、看视频\n\n腾讯用户往游戏、视频的转换率会很高，但是往电商转化却很低，源于场景不对。\n\n---\n\n两套画像的关系 + 痛点、痒点、爽点\n\n不管是小明、笨笨还是小闲，他们都是羊；你想服务哪种羊，就要按照三种不同的羊的需求，来管理你的草地，来制作你的产品。\n具体到 痛点、痒点、爽点，你得让三种羊按照他们的心理预期，来吃一口你的草，如果吃得开心就再也不离开了。具体就是：解决了他的痛点、让他开心让他爽了。\n\n狼：\n腾讯像用户收费，剪羊毛\n京东、淘宝向商家收费\n\n---\n\n场景-设计产品时要包括产品的场景\n\n什么是场景\n\n场：一个场就是时间加空间，用户必须在这个空间里停留和消费（不停留，不是场景）\n景：情景和互动。\n\n当用户停留在这个空间的时间里，要有情景和互动让用户的情绪出发，并且裹挟用户的意见，这就是场景\n\n新场景的出现，其实也是一个“体”，比如碎片时间就是一个新场景。\n\n罗辑思维：碎片时间（一个新的场景） + 认知焦虑（用户痛点）\n\n场景的核心就是在时间加空间的点上触发别人的情绪。\n\n人的理智和意识都是把人往回拉的，而所有的情绪都是推动人的行动的。所以人会做某一个动作，会往前走，是被情绪所推动的。\n\n只有能触发用户情绪的场景才是真正的流量入口。\n\n互联网商业其实就三个核心词：产品、流量、转化率，也就是产品的比拼、流量的争夺、转化率的优化。这就是互联网竞争的全部。\n\n---\n\n当你规划一个产品时，要问自己七个问题：\n（1）我的产品解决了什么问题？是痛点、痒点还是爽点？\n（2）我是在为谁解决这个问题？他得到即时满足了嘛？这是用户画像的问题\n（3）有多少人需要解决这个问题？这个是市场规模的问题\n（4）目前人们是如何解决这个问题的？这个是竞争分析的问题\n（5）我的竞争方案为什么能够在市场竞争中胜出？你不要简单的看单点的竞争力，而是要看点线面体，谁给你赋能\n（6）用户会在怎样的场景触发情绪？需要马上去解决问题，这是场景问题。\n（7）当用户遇到问题的时候，他会想到哪个名字？\n\n---\n\n系统能力（四个步骤，打造个人、公司核心能力）\n\n![系统能力](http://cdn.b5mang.com/2021219103838.png)\n\n用系统能力给人提供确定性\n\n#### 系统能力的定义\n\n我们看到的所有结果，都是系统能力的产物。你可以回到《机会判断：点线面体的战略选择》一课里，思考为什么一个“点”没那么重要？因为任何一个“点\"都附着在一条“线”上，每一个“点”其实都是一条“线”的截面。\n\n这也是为什么结婚教练建议以结婚为目的的相亲，第\n一次见面正常平淡即可，没有必要专门地表现自己，因为**每个人的自然呈现都是系统能力的结果**。\n\n比如一个人好的身材，其实是长期自律的结果；一个人得体而有美感的着装，其实是长期的审美陶冶的产物；一个人的神情和谈吐，其实是学识和性情的产物。所以一个人很自然地展现的一切，是层层叠加、长期积累的系统能力的产物。\n\n当你说你要做一个产品，你需要的是建设一套系统能力。\n\n就好像你想拥有好的身材，就必须得有控制饮食和保持运动的系统能力一样。\n\n整体流程和确定性\n\n##### 产品视角 VS 服务视角\n\n以用户得到一个洞为目的去提供服务，而不是想着把要做一个打孔机，卖给卖出去，这就是产品与服务的区别。\n\n如果总谈产品，容易以产品经理为中心，想着通过一款产品去改变世界。但\n\n是如果出发点是服务，就会以用户获得和用户满足为中心来设计。\n\n这两种方式的目的和实现途径完全不一样。\n\n产品：ATM\n服务：取现金\n系统能力（确定性）：验证ID后，问你需要多少钱，然后吐钱给你。\n\n##### 确定性的重要性\n\n人们生来惧怕不确定性，所以当我们提供了某种确定性，其实就是解决了用户的某一个痛点。\n\n你现在急需用钱，可是ATM能不能取到钱是不确定的，你害怕吗？\n\n不确定性的东西是没有办法让你投入时间或者持续**依赖**的。\n\n围绕ATM系统能力的设计和建设，所做的一切都是为了确保确定性。\n（当你提供核心服务时，也分流了系统的核心资源）\n\n##### 基于服务的产品思考流程\n\n从存在感 到 能力圈层，再到资源层。\n当你提供核心服务的时候，也分流了企业的核心资源。\n\n基于服务的本质，我们需要的几个流程：\n（1）战略判断：战略部门需要做一个决策，为什么要提供这个服务？提供服务对于企业、对于用户的价值是什么？可能的价值点～\n（2）运营部门要对每一台ATM有没有实现战略诉求来做价值评估（看看取款机有没有人用）\n（3）运营不闷对每个点的战略价值做完数据分析和价值评估后，需要哪个点存在，我就要保证它的服务可用（确保它能够吐出钱）\n（4）维护ATM还需要更多事情，比如硬件管理\n（5）客服管理\n\n当你准备做一个产品时，基于系统能力，你需要考虑：\n\n（1）你的产品在“点线面体”的什么位置？\n（2）你提供的是一个什么样子的确定性\n（3）为了确保确定性的稳定提供，你需要的系统能力需要包括哪些环节？你有**足够的资本和能力来支撑**所有的环节吗？\n\n#### 系统效率\n\n产品是系统能力的产物；而企业则是效率分工的产物。\n\n做产品就是在建设一套系统能力，提供并保障确定性，而效率则是这个系统能力的一个核心指标。\n\n互联网思维最关键的两个点：一个是用户体验，一个是效率。小米的护城河：效率。 ---雷军\n\n效率就是快\n\n当你决定要做一个产品，准备搭建自己的系统能力时，你先问自己一句“我应该从哪个点来建立我**系统性的效率优势**？”因为没有效率优势，这个系统是一个没有竞争力的系统。\n\n小米：集中力量打造一款手机；小米之家（逆袭）；小米小店\n\n#### 迭代\n\n迭代就是小步快跑，把最内核的部分先放出来，不断优化，小范围试错。\n\n版本规划能力，产品就是要直指人心！\n\n判断产品经理是否牛B，很重要的一条就在于判断他设计的产品第一个版本有多简单、直接、切中要害，能不能直指人心。\n\n不自信，才附加更多功能，寻找心理依靠。\n\n所以产品的核心功能点有效比什么都重要，基于核心功能附加的其他功能点没有那么重要，可以一步步来。\n\n\n**圈层** （B站的二次元圈层）\n\n**圈层壁垒**（B站的破圈之路）\n\n互联网核心用户 460w (很长时间，微信红包很长一段时间内活跃用户数）)\n\n微信红包 =》 春晚\n\n从400万用户到一亿用户，靠**春节**这样一个核心场景\n的触发完成。支付宝积累一亿用户用了多久呢？大概是8年，而微信支付是一天。\n\n用户体验（五个具体方法，优化你的表达界面与产品体验）\n\n#### 关键任务-关系系统生死的任务\n\n带领大家找到关键任务，穿越生死的能力，就是领导力。\n\n普通员工：明确知晓有风险\n项目经理：具备风险规避意识。\n总监：有风控能力，有风险规避意识，明知有长线风险。无法避过时，知道如何组织大家做好突发预案。\n总经理，能操作有风险的执行---非生即死，富贵险中求\n\n面对生死考验，依靠的不是管理能力，而是领导力。甄别**关键任务**，动员大家穿越生死。\n\n#### 系统能力\n\n所有的产品都是系统能力的结果；我们要做的不是一个产品，而是建设一种能力，然后为你的用户提供确定性。\n\n系统能力的效率优势、系统的迭代能力，都不是最后你呈现的产品表面能看得出来的，但是你的系统能力是你的产品能否存在的本质。\n\n只要你在创业，终有一天会面临跨越生死。那个时候，副总裁、总监通通都帮不了你。这时能够支撑你的，是你对**关键任务的甄别**，你**内心的确认感**和你**真正的兄弟**。\n\n---\n\n### 用户体验\n\n![用户体验]](http://cdn.b5mang.com/202121910397.png)\n\n#### 用户体验的五个层次\n\n情绪纠偏，认知纠偏，不再只从原生感受上来看问题。从用户的潜意识层面考虑，从用户的情绪出发，通过场景reach到用户的痛点、爽点、痒点。\n\n不仅要仅仅考虑用户，用户的需求可能随着时间带来的趋势发生变化甚至消失，所以我们要顺势而为，“于万仞之上推千钧之石”，预测趋势，顺应趋势，抓住趋势。\n\n【承上启下】厚积薄发，厚积在于建设系统能力，薄发在于提升用户体验。\n\n用户体验有哪5个层次：\n\n- 战略存在层\n\n明确的回答两个问题：\n\n1. 我们要通过这个产品得到什么？（对于企业的价值）\n2. 我们的用户要通过这个产品得到什么？他们为什么要依赖我们？ （对于用户的价值）\n\n- 能力圈范围层\n  \n围绕着清晰的战略，我们需要明确回答：\n\n1. 我们要做到哪些事情，具体要提供什么样子的确定性？\n2. 我们不做那些事，对这些事坚决不碰。\n\n能力圈朝着战略的方向变化、拓展。\n\n- 资源结构层\n\n资源：毛泽东一句话定义了“资源”，就是“谁是我们的敌人，谁是我们的朋友”。\n\n建设资源与能力有关，更与战略有关。\n\n- 角色框架层\n\n用于网站是框架，用于用户是角色。\n\n例如你跟空姐或者银行职员对话，她的反馈方式即是角色框定的。\n\n- 感知层\n  \n精美的网站、简洁、体验\n\nbaidu 胜出 google，胜出在了资源层、能力圈层\ngoogle 胜出 yahoo，胜出在了框架层\n  \n#### 用户体验地图\n\n用户体验地图就是通过画一张图，用一种讲故事的方式，从一个特定用户的角度出发，记录下他与产品或者服务进行接触、进入、互动的完整过程。\n\n如何画用户体验地图\n\n1. 一个画像完整的人物角色（你对你的第一只羊，了解吗？）\n2. 清晰的描述用户的目标和预期（他为什么来到你的草地上？他买打孔机，不是为了用户打孔机，而是为了在墙上打个洞；吃饭的目的在于什么？吃饱还是营造气氛？）\n3. 服务触点（用户从接触你的服务，到实现他的目的，会跟你在产品上有哪些接触）\n4. 用户使用路径（用户逛宜家是使用路径，而到盒子前拿免费资料是触点）\n5. 用户情绪曲线（场景是要触发情绪的）\n\n一个好产品，是从一个好故事开始的。要讲好用户故事，而不要过分关注数据。\n\n#### 服务蓝图\n\nCEO核心工作：定义战略、建设能力圈\n服务设计蓝图：解决资源结构和角色框架的问题\n\n用户体验地图，是以用户情绪为中心的，讲的是第一只羊如何才能玩得开心，具体在哪个点爽、哪个点不爽\n\n而服务蓝图，则是以服务流程为中心的。你提供的产品，不可能满足用户所有的预期。资源有限，控制成本\n\n服务蓝图到底要做什么：一眼，一条路、三个点\n\n一眼：产品要第一时间让用户“一眼”看到自己的目标\n一条路：产品要有一个清晰的路径，让用户能够知道如何使用你的服务，用来达到或者接近自己的目标。服务崩溃点\n三个点：峰值、终值、忍耐底线\n成本控制是本分，但是不能挑战用户的忍耐底线\n峰终定律：体验最高峰（正面、负面）以及结束时的体验，难以忘记。\n\n![宜家的服务设计蓝图](http://cdn.b5mang.com/20213922230.png)\n\n设计服务蓝图的核心在于：让你在资源有限的情况下，配置你的资源，在关节点上安排角色，保证整体服务路径不崩溃，尽量不要压倒用户的忍耐底线。然后，尽量集中资源，打造体验的峰值，最后在做一个体验终值的美好小尾巴。\n\n#### 上瘾机制：用户激励系统\n\n激励：完成预定动作，就能得到满足。\n\n不确定的爽点 与 确定的爽点，就是用户体验地图情绪曲线。\n\n游戏的动力，就是压力感突然被满足，压力释放的爽感、确定性的获得、激励的满足感和在一起，让一个人成瘾。\n\n确定就是依赖；不确定就是伤害；一个确定性的丧失，无论大小都是非常难受的。\n\n宏观视角\n创新模式（五个创新模式，洞悉顶级公司的创新战略）\n\n![创新模式](http://cdn.b5mang.com/2021219103928.png)\n","categories":["产品"]},{"title":"分布式系统-分层与抽象","url":"/backend_knowledge_architecture/distributed_system/layered_architecture.html","content":"\n一个复杂的应用程序可能会有更多的中间层次，比如基于API的API，不过基本思想仍然是一样的：\n\n每个层都通过提供一个**明确的数据模型**来**隐藏更低层次中的复杂性**。\n\n这些抽象允许不同的人群有效地协作（例如数据库厂商的工程师和使用数据库的应用程序开发人员）。\n","tags":["分布式系统"]},{"title":"变种题系列-打家劫舍","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/rob.html","content":"\n### 普通版本打家劫舍\n\n普通DP，第i家抢还是不抢？\n\n### 环形版本打家劫舍\n\n思路：\n\n由于首尾也属于相邻，因此需要分别判断，以第一家是否打劫分成两个问题\n\n第一家抢：最后一家一定不能抢，从第0个到len-2做动态规划\n\n第一家不抢：从1到len-1做动态规划\n\n然后比较找出最大值\n\n### 二叉树版本打家劫舍\n\n不太像是一个DP问题，他的本质是一个DFS问题。\n\n本质上所有的DP问题都可以看作DFS + 备忘录。\n","tags":["动态规划","变种题"],"categories":["数据结构与算法"]},{"title":"高性能服务器系列-go的协程管理","url":"/backend_knowledge_architecture/server/thread_model/co_for_go.html","content":"\nM(Machine)，可以理解成一个线程，真正执行P的线程。系统线程，想要在CPU上执行代码必须有线程，通过系统调用clone创建\n\nP(Processor)，一个P表示一个逻辑处理器，用于调度G。每一个Processor有一个称为G的队列，队列里放了等待被调度运行的协程。M必须获得P才能执行P队列中的G代码，否则会陷入休眠\n\nG，一段goroutine代码，放到P对应的队列上，等待被调度运行。代表一个计算任务，由代码和上下文（如当前代码执行的位置、栈信息、状态等）组成。\n","tags":["高性能服务器"]},{"title":"大数高精度加减乘除","url":"/backend_knowledge_architecture/structure_algorithm/structures/big_number.html","content":"\n一般而言，通过倒序vector\\<int\\>来表示高精度大数；\n\n因为做运算时，通常需要从低位开始，所以一般vector需要进行逆转处理。\n\n```cpp\n//高精度加法 —— 模板题 AcWing 791. 高精度加法\n// C = A + B, A >= 0, B >= 0\nvector<int> add(vector<int> &A, vector<int> &B)\n{\n    if (A.size() < B.size()) return add(B, A);\n\n    vector<int> C;\n    int t = 0;\n    for (int i = 0; i < A.size(); i ++ )\n    {\n        t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    if (t) C.push_back(t);\n    return C;\n}\n\n//高精度减法 —— 模板题 AcWing 792. 高精度减法\n// C = A - B, 满足A >= B, A >= 0, B >= 0\nvector<int> sub(vector<int> &A, vector<int> &B)\n{\n    vector<int> C;\n    for (int i = 0, t = 0; i < A.size(); i ++ )\n    {\n        t = A[i] - t;\n        if (i < B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t < 0) t = 1;\n        else t = 0;\n    }\n\n    //清除后面的0（高位）\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    return C;\n}\n\n//高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法\n// C = A * b, A >= 0, b > 0\nvector<int> mul(vector<int> &A, int b)\n{\n    vector<int> C;\n    int t = 0;\n    for (int i = 0; i < A.size() || t; i ++ )\n    {\n        if (i < A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    return C;\n}\n\n//高精度除以低精度 —— 模板题 AcWing 794. 高精度除法\n// A / b = C ... r, A >= 0, b > 0\nvector<int> div(vector<int> &A, int b, int &r)\n{\n    vector<int> C;\n    r = 0;\n    for (int i = A.size() - 1; i >= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n    return C;\n}\n```\n","categories":["数据结构与算法"]},{"title":"题目组织说明","url":"/backend_knowledge_architecture/structure_algorithm/problem/index.html","content":"\n我们按照多个维度来组织我们的知识。\n\n第一个维度，知识的维度。\n\n通过知识维度，我们能够熟练掌握该类知识能够解决的经典问题，从而加深了对知识的理解。\n\n第二个维度，问题的维度。\n\n问题维度的话，我们尽量罗列该问题的多种解法（从一般算法到最优解法）；通过这种方式，我们体会算法&数据结构的精妙的同时，不断加深对问题的理解。\n\n第三个维度，问题变种维度。\n\n有很多问题，可以衍生出很多的变种。对于这些问题，我们也会开一个专门的目录来对待。\n\n参考：\n\n按照pattern刷题 https://www.zhihu.com/question/36738189/answer/908664455\n\nhttps://www.educative.io/courses/grokking-the-coding-interview?aff=K7qB"},{"title":"面试技巧","url":"/backend_knowledge_architecture/interview.html","content":"\n### GM面试\n\n#### 此次面试的目的\n\n总结一下GM比较关注的问题方向\n\n1）在这个岗位上可以发挥什么价值？\n2）稳定性怎么样？\n3）潜力、自驱思考力如何？\n\n#### 可能的一些问题\n\n为什么选腾讯; 你的同事怎么形容你一个词;\n\n自我介绍，为何离职？当前和上一家公司介绍在当前公司过去一年最大成就;\n\n再问了一个比较详细的项目问题和你在项目里的职责以及贡献点，\n\n你是否了解面试的岗位（职位）？这个岗位做什么的？\n你面试要做的这个产品解决了什么问题？\n市面上已经有的产品面临什么问题？\n为什么在职业生涯发展阶段中从C端产品转做了平台产品？\n职业生涯规划如何？\n你和职业生涯下一步的差距在哪里？\n为什么最开始先去CSIG面试了？这两个岗位差距还不小，你如何理解的？\n\n为什么选择现在所在的行业（比如我在做物流）？\n未来这个行业会怎么样？\n你们公司现有的xxx业务如何做的？哪里做的不好？\n如果你是公司的xxx业务负责人，你会怎么做？\n\n最后时间有限可以问gm一个问题？\n\n#### 如何回答\n\n1. 分别拆解基于每个point会问我的问题\n\n1）为团队带来的价值：\n\na. 这个岗位是做什么的？-- 对照岗位介绍和之前面试官重点关注的方向做思考总结；\n（1）项目架构设计工作 （2）借助研发流程、业务抽象，提升研发效率与质量 （3）理解业务特性，改善团队的分工协作效率\n\nb. 如果你来了你准备怎么做？（你可以为团队产出什么价值？）-- 照着岗位介绍去思考哪里是团队的机会、我个人可以产出哪些边际价值；\n\nc. 对部门的理解？-- 根据之前面试官问的问题，看了很多行业报告结合自己的思考，猜测了一下行业未来的机会。（这一部分说对说错也没所谓，反正想了总比没想好）\n\nd. 之前带团队做管理有什么心得？ -- 首先要建立信任、坦诚沟通。为团队成员要做三件事：1. 给些导师指导 2. 帮忙争取资源 3. 主动承担责任\n\n角色认知：由工程师转向管理者\n管理规划：职能（为什么存在，使命与职责）、目标、团队、选择\n    你团队是干什么的？（职责是下限，使命是上限）\n    你团队想做出什么成果？\n    你依靠什么样的团队？\n    你需要投入哪些资源？\n团队建设：能力与意愿、分工与协作、梯队与文化\n任务管理：事前轻重缓急；事中有效执行；事后流程\n    目标清晰、责任明确、机制健全和沟通到位\n管理沟通：目的、内容、通道、影响力\n\n2）稳定性怎么样？\n\na. 期待在这份工作里收获什么？（职业生涯规划？）-- 我个人是想成为某个行业的专家，并且有触类旁通迁移的能力。\n\nb. 为什么想离职？-- 缺少指路人。\n\nc. 为什么之前突然从C端产品经理转做平台产品经理？ -- 不是主动要求转岗，是当时公司缺平台产品，我加班做了这部分工作，做着做着就做成了平台产品经理。( ´▽｀)\n\nd. 之前为什么面试CSIG的岗位？跟你之前做的方向不太一致 -- 想变成平台产品的行业专家，所以需要做比较复杂业务下的平台类产品，从这个角度将这两个岗位其实是一致的。\n\ne. CSIG为什么面了五面挂了？如何复盘的？\n\n-- 我觉得挂掉有两个原因：1. CSIG的岗位90%的要求其实是满足的，但是有10%的不契合；2. 因为这10%的不契合而过分紧张，没发挥好，很多想过的问题都没有答到点上。\n\n-- 自己复盘了一下，其实没必要对那10%不自信，只要稳定发挥基本上没问题的。\n\n3）潜力怎么样？思考的宽度和深度\n\na. 为什么当时想来“货拉拉“？\n\n-- 考虑到三个因素：1. 好赛道（来之前查了物流行业占全国总GDP的15%的样子）2. 好公司（势头很猛，从默默无闻到闷声赚钱）3. 好领导（当时是觉得leader能力非常棒才来尝试的，但是很快leader就撤了…）\n\nb. 你觉得这个行业会如何发展？\n\n-- 发达国家的物流行业占全国总GDP大概在12%的样子，我国和发达高价还有3%的gap。基于这个gap猜测，后续物流行业的GDP会越来越低，信息化、智能化、供应链会做的越来越好。在这个行业背景下，越是有研发能力的公司越容易变成寡头，两极分化会更明显。\n\n作为技术管理者，我如何保持技术判断力\n\n建立技术学习机制。盘点你负责的业务，需要哪些方面的技术，成立一个或几个核心的技术小组，让团队对各个方向的技术保持敏感，要求小组定期做交流和分享，这样你就可以保持技术的敏感度。\n专项技术调研项目化。如果某项技术对团队的业务有重要的价值，可以专门立项做技术调研，并要求项目负责人做调研汇报。\n和技术大牛交流。越是厉害的技术人，越能深入浅出地把技术讲明白，所以针对某项技术找大牛取经，也是学习的好途径。你看，虽然实际操刀的时间少了，但是你和技术大牛的交流机会多了，一方面因为你有更大的影响力了，另一方面，你和大牛有了共同的诉求，就是把技术“变现”，让技术产生价值。\n听取工作汇报。因为你带的是技术团队，大部分工作都和技术相关，在读员工的周报、季度汇报时，相互探讨，也是一种切磋和学习。\n\n引发新经理不自信的三个困境，我们就探讨完了，我把它们简要总结一下：\n\n第一，你可以通过梳理自己可迁移的能力，提升能力自信；\n\n第二，你可以通过把自己从团队成员的对立面抽离，提升角色自信；\n\n第三，你可以通过收集外部积极正向的反馈，提升自我认同。\n\n一面\n第一轮是笔试，方式是邮箱发的牛客网上的链接，一共2个小时，3种题型：10个选择，2个填空，3个问答题，选择题涉及C++基础知识\n如没有名字的类有哪些特点：有没有构造函数和析构函数，是不是编译错误；int**x的指针中(x[2]+4)[3]跟哪一个指的是同一块儿地址，\n还有操作系统一个程序阻塞SIGUSER1和SIGCHILD消息，\n当这个程序变为非阻塞时是否会收到这两个消息；\n填空题第一题是给你一个main程序和foo()函数程序（分别在不同的.c中），问用gcc-o -main.c foo.c命令编译的C++程序，最终输出的a,b,c的值具体是多少（a,b,c分别在main函数和foo函数中定义并给出初始化）；\n第二道是给出五个程序都是实现了用一个线程创建另外两个线程，问这五个里面是否有发生竞态；问答题有3道：\n第一个是动态规划问题：如果用a=1,b=2,……z=26那么给出一个数字串如111，一共有多少种用字符替换的方式，如ak,ka和aaa三种，返回3；\n第二道题是奇数阶魔方矩阵的填数，告诉你实现的算法文字描述，让你用代码实现，比较简单；\n第三道是数组的封装（如数组的底层内存分配有mmap和堆空间创建等方式，因此有不同的数组实现方式，让提出方案把几种实现方式封装），让你写设计方案，感觉好像是写文字就行\n\n\n10道选择题，两道填空题以及三道问答题。\n主要知识点偏 C 语言方向：\nQ：1. fork函数相关的执行流程\n0条回答\nQ：2. 信号优先级以及阻塞机制（SIGHLD、SIGUSR1）\n2条回答\nQ：3. 给一个常见的需求场景，要求设计相关的方案，比如有多个底层实现的数组（mmap、malloc或自定义的实现）；要求提供给用户的接口是统一的，用户无需关心数组底层的实现即可直接使用。\n\n第一轮笔试：6选择题+2填空题+2编程题+1设计题。有防作弊选择题是牛客的中上水平，时间宽裕。填空题略难，需要演算。编程题不是OJ，估计需要看你代码风格，一道是easy数列题（前缀积），一道是数独题。设计题与循环队列相关。第二轮技术群面：是每个组的组长来面。询问以往经历的C++调优、海外经历等。考察了一道medium编程题、一道无锁队列题。可以和面试官沟通。第三轮HRBP：非常专业的HRBP，问题犀利，考察你做工作时的这么几个素质：抗压能力、钻研倾向、稳定倾向等等。如果遇到她感兴趣的会一直追问到你难以回答为止。谢天谢地过了。第四轮CTO终面：还没开始，后面回来写。\n\n一面 第一轮是笔试，方式是邮箱发的牛客网上的链接，一共2个小时，3种题型：10个选择，2个填空，3个问答题，选择题涉及C++基础知识如没有名字的类有哪些特点：有没有构造函数和析构函数，是不是编译错误；int**x的指针中(x[2]+4)[3]跟哪一个指的是同一块儿地址，还有操作系统一个程序阻塞SIGUSER1和SIGCHILD消息，当这个程序变为非阻塞时是否会收到这两个消息；填空题第一题是给你一个main程序和foo()函数程序（分别在不同的.c中），问用gcc-o -main.c foo.c命令编译的C++程序，最终输出的a,b,c的值具体是多少（a,b,c分别在main函数和foo函数中定义并给出初始化）；第二道是给出五个程序都是实现了用一个线程创建另外两个线程，问这五个里面是否有发生竞态；问答题有3道：第一个是动态规划问题：如果用a=1,b=2,……z=26那么给出一个数字串如111，一共有多少种用字符替换的方式，如ak,ka和aaa三种，返回3；第二道题是奇数阶魔方矩阵的填数，告诉你实现的算法文字描述，让你用代码实现，比较简单；第三道是数组的封装（如数组的底层内存分配有mmap和堆空间创建等方式，因此有不同的数组实现方式，让提出方案把几种实现方式封装），让你写设计方案，感觉好像是写文字就行\n\n1、简历问题，排名多少能拿奖学金，上过什么课等等2、c++有什么特点3、封装是什么意思，为什么要封装4、虚函数的底层实现5、成员的三种访问属性。子类能不能访问父类protected的成员6、聊项目，没展开很多，主管展开得多...7、epoll好在哪里，epoll_wait是阻塞还是非阻塞8、讲讲epoll的流程9、继承要满足什么条件？（组合和继承的关系）10、问学没学过操作系统，讲讲操作系统（有点尬不知道讲什么...）11、做题：逆波兰表达式求值 ，面试官共享屏幕看题目，然后共享自己的屏幕在本地IDE写。有个小bug没发现运行结果不太对，但面试官说bug不调了，他觉得是对的。\n\n时长大概2小时，基础原理 编程，数学为主， 概率题：买卖股票，蚂蚁怕树枝等模板题：template 判断某个类中是否包含某个变量，，编程题：难度还好\n\n10选择 2填空 3问答\n主要是数学，c++ 和linux相关问题\n主要考察信号、程序运行结果以及指针操作相关问题\n\nnew()的内存分配过程\n进程与线程\ntcp和udp\nepoll原理\n项目介绍\n\n首先是笔试，笔试有两个小时时间会考察很多基础知识还有编程题。\n要考察你的c++功底，比如c++的面向对象编程特点，还有一些数据库的知识，还有很多操作系统较为底层的知识，比如io多路复用等。\n我笔试后好久没出结果了。\n\n、输入某一年，输出这一年每个月最后一个星期五是哪一天-，输出格式\"2020-10-23\"\n2、多线程题目，有3个线程，每个线程都分别输出0，偶数，奇数，如何设计输出01020304....\n3、算法题-动态规划题      假设你有M万元（M为整数，100\n\n题目整体偏难，考察C++深度比较深入。问了很多C++底层的知识，考察了宏，模板，等，io多路复用，算法题目感觉都是leetcode\n\nlinux系统的相关问题，如调用的时延；\ncache miss x86；\n面试官问了人选一些项目上的问题及工作难点，及如何运用到量化交易的项目上\n\n涉及的面挺广的，操作系统，数据结构，概率等4个小时的答题时间，刚刚毕业的学霸做这些题目会比较有优势。\n\n五道单选， 计算机基础，unix基础 \n两道算法 数独 加 ip地址\n量化交易公司的软件开发岗，时间一个小时 时间比较紧\n\n给你一根面条求围成圈圈的期望2老王已知有俩娃参加聚会的时候带来了一儿子求另一个为儿子的概率3leecode是求注水体积问题用单调栈解决и还有挺多数学题的不太记得了\n\n编写出求两正整数M,N之间的最大公因数的程序\n\n编写出求两正整数M,N之间的最大公因数的程序\n\n具体题目：\n1.二叉树一层一层打印下来，然后再从左到右打印奇数，从右到左打印偶数。 2.找括号，经典栈的算法题\n3.输入一个二维数组，输出这个二维数组的所有元素的和\n4.写出一个判断参数是否符合要求的装饰器\n其他的编程题目就是和交易直接相关的，处理一连串时间序列判断是不是交易日，处理交易数据计算收益率，还有编写一个模拟交易所撮合成交单子程序。都还比较简单，用pandas就能搞定，其中没有嵌入复杂的算法。\n\nhttps://blog.csdn.net/weixin_42327556/article/details/101844256\n\n新型股票交易策略，可以买卖任意手（可不买100的倍数手)，全天24小时任意交易。但规定，每一小时内只能交易一次，相邻T i T_{i}T \ni\n​\n 和T i + 1 T_{i+1}T \ni+1\n​\n 交易差的绝对值不超过1；第24时内的交易和1时的交易差的绝对值不超过1；考虑交易方向。成交净买入为零，即买入的手数=卖出的手数。问，每天最多可以交易多少次？（答：144次）\n4个球分别为不同的颜色，每次随机取出两个，将第二个的颜色涂成第一个的颜色，问多少次才能将4个球涂成同一个颜色的期望？\n蚂蚁的问题，有N只重量均为1的蚂蚁均匀分布在一根杆上，要么往左，要么往右走，速度相同，但是第1只往右走，第N只能往左走。狩猎规则：重量大吃重量小的；重量相等，往左走吃往右走的。（1）第N只存活的概率？（2）第K！=N只存活的概率？\n二叉树怎么返回公共组节点？\n做过最有成就感的项目，项目背景，课题理解的深度，如何克服困难？\n期望题：回去看草稿纸。\n————————————————\n版权声明：本文为CSDN博主「Ya2020」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_46643879/article/details/114919063\n\nhttps://cloud.tencent.com/developer/article/1453534\n\nhttps://zhuanlan.zhihu.com/p/498681895\n\nreverse the sequence of all the words in a string.\n\n\n2. 1M 7 digit phone numbers, 2MB spare memory, read each number only once and sort them.号码都不一样。\n\n1 How do you traverse a binary tree to get a sorted list?\n2 How do you insert an item to a circular linked list? What is it complexity? How about inserting it in constant time?\n3 given a special programming language. No for or while loop, but you are given function that can add an element in front of array, and a function for comparing two elements. Can you use this language to sort an array?\n4 reverse the sequence of all the words in a string.\n知乎@华尔街老兵\n\n文章首发于知乎号，华尔街老兵©2022\n\n转载请注明出处。\n\n一副4色扑克牌，共52张牌。现在排成一列，问有多少种排法使得没有两张相 同花色是 相邻的？\n\n\n\nGiven two classes:\n\n\n\nclass B { public:\n\n\n\nB(args_1); B(args_2); // and many constructors with different arg lists };\n\n\n\nclass D : public B { public:\n\n\n\nD(args_1) : B(args_1) {} D(args_2) : B(args_2) {} // and many constructors with different signatures similarly implemented // some additional stuff speciﬁc to D };\n\n\n\nAssume that the arg list for B's constructors are quite long and may be revised pretty often in the future, in which case D's constructors have to be recoded correspondingly. Duplicating the update by copy-and-paste will certainly work here. Can you propose a better way so that the update can be done in one place without copy-and-paste duplication?"},{"title":"并查集系列之最长连续序列","url":"/backend_knowledge_architecture/structure_algorithm/structures/union_set/longest_consecutive.html","content":"\nLongest Consecutive Sequence 求最长连续序列, $O(n)$复杂度\n\n解题思路：\n\n  1. hash来记录是否使用过，以某个元素为中心，向两侧扩展\n  2. 带size的并查集\n  \n```c++\nclass Solution {\npublic:\n    unordered_map<int,int> father_map;//节点-父节点\n    unordered_map<int,int> child_count;// 节点-子节点个数\n    int longestConsecutive(vector<int>& nums) {\n        int res = 1;\n        if( nums.size() == 0) return 0;\n        for(int i = 0;i < nums.size();i++)\n        {\n            father_map[nums[i]] = nums[i];\n            child_count[nums[i]] = 1;\n        }\n        for(int i = 0;i < nums.size();i++)\n        {\n             if( father_map.find(nums[i]+1) != father_map.end())\n             {\n                 res = max (res,mergexy(nums[i],nums[i]+1));\n             }\n        }\n        return res;\n    }\n    int getfather(int i)\n    {\n        if( father_map[i] == i)\n        {\n            return i;\n        }\n        else\n        {\n            father_map[i] = getfather(father_map[i]);\n            return father_map[i] ;\n        }\n    }\n    int mergexy(int x,int y)\n    {\n        x = getfather(x);\n        y = getfather(y);\n        if( x == y )\n        {\n            return child_count[x];\n        }\n        else\n        {\n            father_map[y] = x; \n            child_count[x] +=child_count[y];\n            return child_count[x];\n        }\n    }\n};\n```","categories":["数据结构与算法"]},{"title":"跳表","url":"/backend_knowledge_architecture/structure_algorithm/structures/skip_list.html","content":"\n\n跳表是一种随机化数据结构，\n\n其随机化体现在插入元素的时候元素所占有的层数完全是随机的，层数是通过随机算法(随机化思想)产生的。\n\n改变索引构建策略，有效平衡执行效率与内存消耗\n\n使用场景：\n\n1. Redis ZSET实现\n2. LevelDB选用SkipList来实现memory table\n\n参考：https://segmentfault.com/a/1190000020596941","categories":["数据结构与算法"]},{"title":"并查集","url":"/backend_knowledge_architecture/structure_algorithm/structures/union_set/index.html","content":"\n\n并查集是一个代码很简单、但技巧性极强的数据结构，我们需要知道并查集的最重要特性：\n\n能够在近乎$O(1)$的时间复杂度内完成元素归属集合以及元素合并的操作。\n\n通常我们利用数组来实现并查集，并经常会通过路径压缩技巧来进行性能优化。\n\n我们在图的连通性判定、最小生成树-kraskal等问题中可以看到常规并查集的应用。另外，我们有时候需要额外维护size、distance等额外属性去解决更多的问题。这种技巧也需要掌握。\n\n#### 将多个集合合并成没有交集的集合\n\n给定一个字符串的集合，格式如：{aaa， bbb，ccc}，{bbb，aaa,ddd}，{eeefff}，{ggg}，{dddhhh}要求将其中交集不为空的集合合并，要求合并完成后的集合之间无交集，例如上例应输出{aaabbbcccdddhhh}，{eeefff}，{ggg}。\n（1）请描述你解决这个问题的思路；\n（2）请给出主要的处理流程，算法，以及算法的复杂度\n（3）请描述可能的改进。\n\n回答：类似于并查集的思路\n\n```cpp\n并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量\n(1)朴素并查集：\n\nint p[N]; //存储每个点的祖宗节点\n\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i <= n; i ++ ) p[i] = i;\n\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\n\n\n(2)维护size的并查集：\n\nint p[N], size[N];\n//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i <= n; i ++ )\n{\n    p[i] = i;\n    size[i] = 1;\n}\n\n// 合并a和b所在的两个集合：\nsize[find(b)] += size[find(a)];\np[find(a)] = find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\nint p[N], d[N];\n//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n        int u = find(p[x]);\n        d[x] += d[p[x]];\n        p[x] = u;\n    }\n    return p[x];\n}\n\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i <= n; i ++ )\n{\n    p[i] = i;\n    d[i] = 0;\n}\n\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n```\n","categories":["数据结构与算法"]},{"title":"Splay Tree","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/splay.html","content":"\nSplayTree，一种二叉查询树，与红黑树类似，是一种自调整的二叉树，\n\n但是调整过程不仅仅发生在插入和删除，SplayTree中对节点访问都是通过splay操作完成节点的定位，查询、插入都是通过splay操作得到节点位置，每个splay操作都将进行对节点进行调整，将目标节点调整至树根，频繁访问的节点，调整到离根近的位置上，加快查询速度，反之“冷”节点的查询会耗时多。\n\n按照8-2原则，假如程序80%的查询量中，频繁被查询到的数据仅仅是总数据的20%，那么将数据放入SplayTree中提供查询，对“热”数据的查询会大大加速，这样子会大大降低这80%查询量所需要的时间。\n\n事物总有其缺陷的一面，SplayTree也是如此，倘若访问“冷”节点，这时的代价可能是O(n)，但是对于“热”节点，甚至可以达到O(1)。\n\nSquid中SplayTree应用于ACL，所谓ACL即访问控制列表，用户通过配置文件配置的ACL元素(例如：http_accessacl1,acl2,acl3，这里的acl1，acl2，acl3就是acl元素)，在内存中使用两种方式组织，一种是SplayTree，另一种是链表。采用的SplayTree组织ACL的种类有：DSTIP、SRCIP、用户认证、DSTDOMAIN等，原因很简单，这些元素访问非常频繁，假如元素很多时，链表查询的代价是O(n)，让这些类型ACL元素放入SplayTree中，那么查询时间就是可以做到O(log(n))，甚至是O\n\n理论依据：局部性原理\n\n参考：\nhttp://blog.csdn.net/yykxx/article/details/8679017","categories":["数据结构与算法"]},{"title":"MerkleTree - 概览","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/merkle_tree.html","content":"\nMerkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。\n\n![Merkle Tree](https://images2015.cnblogs.com/blog/834896/201605/834896-20160527163537178-321412097.png)","categories":["数据结构与算法"]},{"title":"树","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/index.html","content":"\n### heap\n\n### red-black\n\n更加平衡，没有极端；\n\n### avl\n\n过于平衡，查询性能最好，但是维护成本过高；\n\n### treap\n\n### splay-tree\n\n### 区间树\n\n区间树是在平衡树基础上进行扩展得到的支持以区间为元素的动态集合的操作，其中每个节点的关键值是区间的左端点。\n\n![区间树](https://bkimg.cdn.bcebos.com/pic/279759ee3d6d55fb5d3e06426c224f4a21a4ddde)\n\n### 线段树\n\n线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 [1]\n对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。\n\n对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是$O(log2(n))$\n\n参考：https://blog.csdn.net/zearot/article/details/48299459\n\n用线段树解题，关键是要想清楚每个节点要存哪些信息（当然区间起终点，以及左右子节点指针是必须的），\n\n以及这些信息如何高效更新，维护，查询。不要一更新就更新到叶子节点，那样更新效率最坏就可能变成O(n)的了。\n\n先建树，然后插入数据，然后更新，查询\n\n### 树状数组（binary indexed tree）\n\n树状数组所能解决的典型问题就是存在一个长度为n的数组，我们如何高效进行如下操作：\n\n- update(idx, delta)：将num加到位置idx的数字上。\n\n- prefixSum(idx)：求从数组第一个位置到第idx（含idx）个位置所有数字的和。\n\n- rangeSum(from_idx, to_idx)：求从数组第from_idx个位置到第to_idx个位置的所有数字的和","categories":["数据结构与算法"]},{"title":"B+树 - 概览","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/bplus_tree.html","content":"\nm叉树中的m具体取决于一个Page的大小，例如4K\n\n如果一个Node的子节点数量超过m，则分裂；如果小于m，会考虑合并\n\n有一根双向链表来连接所有的叶节点\n\nB+优势：\n\n- 查询效率更加稳定，所有数据的查找均是从根节点到叶子节点。\n\nMongoDB采用B树，聚合文档，没有范围查找需要。","categories":["数据结构与算法"]},{"title":"Trie系列 - 概览","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/trie/index.html","content":"\n\n字典树(Trie)，顾名思义是以树结构来模拟字典。\n\n回想我们查字典的过程，比如查找\"man\"，先翻到字典m部分，再翻第二个字母a和第三个字母n，一共查找3次。\n\n查找次数最多是等于个单词的长度。插入查找单词的时间复杂度时$O(m)$，此外有公共前缀的单词只需存一次公共前缀，节省了空间，也可理解为**前缀树**。\n\n#### 字典树应用\n\n- 字符串检索\n    1. 查询检索字符串\n- 词频统计\n    1. 统计一个单词出现了多少次\n- 字符串排序\n    1. 字典树建好后，先序遍历就得到了排序。\n- 前缀匹配\n    1. 根据前缀，用于搜索提示等\n\n```cpp\nint son[N][26], cnt[N], idx;\n// 0号点既是根节点，又是空节点\n// son[][]存储树中每个节点的子节点\n// cnt[]存储以每个节点结尾的单词数量\n\n// 插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i ++ )\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u]) son[p][u] = ++ idx;\n        p = son[p][u];\n    }\n    cnt[p] ++ ;\n}\n\n// 查询字符串出现的次数\nint query(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i ++ )\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u]) return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n```\n","tags":["Trie"],"categories":["数据结构与算法"]},{"title":"字符串","url":"/backend_knowledge_architecture/structure_algorithm/structures/string/index.html","content":"\n\n### 跟字符串关联很大的数据结构包括\n\n1. Trie\n2. 后缀树\n3. 后缀数组(Suffix Array)\n\n后缀树建树的时间和空间成本都很高。**后缀数组**和后缀自动机可以看作是对后缀树时间和空间上的优化，通过映射关系避免建树和提高树节点重复利用率。\n\n### 跟字符串相关的hash算法\n\n- P进制hash（滚动哈希）\n    1. 例如：构造哈希比较前缀和后缀，快速判断回文串\n\n```cpp\n字符串哈希 —— 模板题 AcWing 841. 字符串哈希\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低\n小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果\n\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n\n// 初始化\np[0] = 1;\nfor (int i = 1; i <= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n```\n\n### 跟字符串有关系的技巧\n\n1. 翻手定则\n\n```cpp\nclass Solution {\npublic:\n    void reverse(string& s, int i, int j) {\n        while (i < j) {\n            swap(s[i++], s[j--]);\n        }\n    }\n\n    string trans(string s, int n) {\n        int begin = 0;\n        for (int i = 0; i < s.length();) {\n            if (s[i] == ' ') {\n                reverse(s, begin, i - 1);\n                i++;\n                begin = i;\n            }\n            else {\n                i++;\n            }\n        }\n        reverse(s, begin, s.length() - 1);\n\n        reverse(s, 0, s.length() - 1);\n\n         for (int i = 0; i < s.length(); ++i) {\n             if (s[i] >= 'a' && s[i] <= 'z') {\n                 s[i] = 'A' + (s[i] - 'a');\n             } else if (s[i] >= 'A' && s[i] <= 'Z') {\n                 s[i] = 'a' + (s[i] - 'A');\n             }  \n         }\n        return s;\n    }\n};\n```\n\n### 字符串匹配算法\n","tags":["字符串"],"categories":["数据结构与算法"]},{"title":"单调栈","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/mono_stack/index.html","content":"\n分类\n单调递增栈，栈顶元素最大\n单调递减栈，栈顶元素最小\n\n一般套路\n\n如果找右边更大的元素，则从前到后构造从底到顶的递减栈;\n如果找右边更小的元素，则从前到后构造从底到顶的递增栈;\n如果找左边更大的元素，则从后到前构造从底到顶的递减栈;\n如果找左边更小的元素，则从后到前构造从底到顶的递增栈;\n\n举一个例子: n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)。右边比我更大的问题\n\n栈里面存的是啥？\n存的是还没有算出来的元素，为啥没有算出来呢，因为还没有遇到比栈顶元素更大的。并且栈顶元素是最小的，所以当前元素也不会大于栈里面的其他元素。\n\n什么时候可以算出来？\n后面遇到比栈顶更大的元素，这时候就出栈，并更新数据。\n\n遍历到最后，栈里面还有啥内容？\n整个列表中没有比这些元素更大的元素。\n\n```cpp\n\n//单调栈 —— 模板题 AcWing 830. 单调栈\n//常见模型：找出每个数左边离它最近的比它大/小的数\nint tt = 0;\nfor (int i = 1; i <= n; i ++ )\n{\n    while (tt && check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}\n\n```\n\n---\n\nGiven a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n\n```cpp\nvector<int> dailyTemperatures(vector<int>& t) {\n    int n = t.size();\n    stack<int> s;\n    int top = 0;\n    for (int i = 0; i < n; ++i) {\n        while (!s.empty() && t[i] > t[top = s.top()]){\n            t[top] = i - top;\n            s.pop();\n        }\n\n        s.push(i); //压入了一个更小的，递减栈\n    }\n\n\n    while (!s.empty()) {\n        t[s.top()] = 0;\n        s.pop();\n    }\n    return t;\n}\n```\n","tags":["单调栈","栈"],"categories":["数据结构与算法"]},{"title":"单调栈系列之<最小数字*区间和>的最大值","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/mono_stack/range_min_max.html","content":"\n求解一个区间的和乘以这个区间最小值的最大值\n\n解题思路：单调栈 + 前缀数组\n\ni到j的区间和，通过前缀数组，比较容易在O（1）的复杂度内取得。\n\n对每一个元素，取得左边第一个比他小的元素，作为j；从后往前遍历，递增栈；\n\n对每一个元素，取得右边第一个比他小的元素，作为i；从前往后遍历，递增栈；\n\n整体时间复杂度$O(n)$\n","tags":["单调栈","栈"],"categories":["数据结构与算法"]},{"title":"队列","url":"/backend_knowledge_architecture/structure_algorithm/structures/queue/index.html","content":"\n关于队列一共有两类问题\n\n1. 在一定条件下，实现某种具有某种特性的队列\n2. 借助队列的某些特性去巧妙的解决某一类问题。\n\n队列的特点：先进先出\n\n队列的用途：\n\n1. 单调队列解决滑动窗口最值问题\n2. 树或者图的BFS\n\n```cpp\n\n//队列 —— 模板题 AcWing 829. 模拟队列\n1. 普通队列：\n// hh 表示队头，tt表示队尾\nint q[N], hh = 0, tt = -1;\n\n// 向队尾插入一个数\nq[ ++ tt] = x;\n\n// 从队头弹出一个数\nhh ++ ;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空\nif (hh <= tt)  //如果hh <= tt, 则队列不空。\n{\n\n}\n\n//2. 循环队列\n// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空\nif (hh != tt) //只要两者不相等，队列就不空。\n{\n\n}\n\n```\n\n### 实现队列\n\n借助两个栈来实现一个队列\n\n### 滑动窗口最值问题\n\n利用一种特殊的队列（单调队列）来巧妙的解决滑动窗口最值问题。\n","tags":["队列"],"categories":["数据结构与算法"]},{"title":"队列系列之利用栈实现队列","url":"/backend_knowledge_architecture/structure_algorithm/structures/queue/queue_impl_with_stack.html","content":"\n请用栈实现一个队列，支持如下四种操作：\n\npush(x) – 将元素x插到队尾；\npop() – 将队首的元素弹出，并返回该元素；\npeek() – 返回队首元素；\nempty() – 返回队列是否为空；\n注意：\n\n你只能使用栈的标准操作：push to top，peek/pop from top, size 和 is empty；\n如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；\n输入数据保证合法，例如，在队列为空时，不会进行pop或者peek等操作；\n样例\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> is;\n    stack<int> os;\n    \n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        is.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (os.empty()) {\n            while (!is.empty()) {\n                os.push(is.top());\n                is.pop();\n            }\n        }\n        int r = os.top();\n        os.pop();\n        return r;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (os.empty()) {\n            while (!is.empty()) {\n                os.push(is.top());\n                is.pop();\n            }\n        }\n        return os.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return is.empty() && os.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * bool param_4 = obj.empty();\n */\n```\n","tags":["队列"],"categories":["数据结构与算法"]},{"title":"单调队列","url":"/backend_knowledge_architecture/structure_algorithm/structures/queue/mono_queue/index.html","content":"\n```cpp\n//单调队列 —— 模板题 AcWing 154. 滑动窗口\n//常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1;\nfor (int i = 0; i < n; i ++ )\n{\n    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh <= tt && check(q[tt], i)) tt -- ;\n    //新的元素入队\n    q[ ++ tt] = i;\n}\n```\n","tags":["队列","单调队列"],"categories":["数据结构与算法"]},{"title":"链表系列-LRU缓存","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/lru.html","content":"\n什么是LRU缓存，怎么设计的LRU缓存。\n时间复杂度：$O(1)$\n\n1. Hash + 双向链表\n2. 哨兵节点来简化判断\n\n```cpp\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode* pre;\n}\n\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNode*> hash;\n    ListNode* head;\n    ListNode* tail;\n    int n;\n\n    LRUCache(int nn) {\n        n = nn;\n        head = new ListNode();\n        tail = new ListNode();\n        head->next = tail;\n        tail->pre = head;\n    } \n\n    void put(int k, int v) {\n        ListNode* r = get2(k);\n        if (r != NULL) return;\n\n        ListNode* node = NULL;\n        if (hash.size() > n) {\n            //链表上移除\n            auto node = tail->pre;\n            node->next->pre = node->pre;\n            node->pre->next = node->next;  \n            //hash移除 \n            hash.erase(node->k);\n        }\n        else {\n            node = new ListNode();\n        }\n\n        node.val = v;\n        //将node放在头部\n        node->next = head->next;\n        node->pre = head;\n   \n        head->next->pre = node;\n        head->next = node;\n\n        hash[k] = node;\n\n    }\n\n    ListNode* get2(int k) {\n        auto it = hash.find(k);\n        if it == hash.end() {\n            return NULL;\n        }\n\n        auto node = *it;\n        \n        //移除\n        node->next->pre = node->pre;\n        node->pre->next = node->next;\n\n        node->next = head->next;\n        node->pre = head;\n   \n        head->next->pre = node;\n        head->next = node;\n    }\n\n    int get(int k) {\n        ListNode* r = get2(k);\n        if (r == NULL) return -1;\n        else r->val;\n    }\n};\n\n```\n","tags":["哈希","链表"],"categories":["数据结构与算法"]},{"title":"堆","url":"/backend_knowledge_architecture/structure_algorithm/structures/heap/index.html","content":"\n二叉堆，包括最大堆、最小堆\n\n最大特点：在$O(1)$时间内找到最小（最大）元素\n\n堆的常见应用：\n\n1. 堆排序\n2. 用两个堆（一个最大堆，一个最小堆）来维护/查询第K大/小的操作\n3. 贪心算法优化\n\n```cpp\n堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n// ph[k]存储第k个插入的点在堆中的位置\n// hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;\n    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while (u / 2 && h[u] < h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u >>= 1;\n    }\n}\n\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n```\n\n","tags":["堆"],"categories":["数据结构与算法"]},{"title":"不使用额外空间，找出数组重复数字","url":"/backend_knowledge_architecture/structure_algorithm/structures/array/duplicateInArrayNoSpace.html","content":"\n给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。\n\n请找出数组中任意一个重复的数，但不能修改输入的数组。\n\n样例\n给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。\n\n返回 2 或 3。\n\n思考题：如果只能使用 O(1) 的额外空间，该怎么做呢？\n\n思考： 把肯定不符合条件的一半给忽略掉；\n\n```cpp\nclass Solution {\npublic:\n    int duplicateInArray(vector<int>& nums) {\n        int l = 1, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;  //[l, mid], [mid + 1, r]\n            int s = 0;\n            //注意这里是遍历了所有的元素\n            for (int i = 0; i < nums.size(); ++i) s += (nums[i] >= l && nums[i] <= mid);\n            if (s > (mid - l + 1)) r = mid;\n            else l = mid + 1; //数量不够，说明这个区间内的某个数肯定被替换掉了，所以肯定在另外一边。\n        }\n        \n        return r;\n    }\n};\n```\n","tags":["二分"],"categories":["数据结构与算法"]},{"title":"本地交换系列-数组重复数字","url":"/backend_knowledge_architecture/structure_algorithm/structures/array/duplicateInArray.html","content":"\n给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。\n\n数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。\n\n请找出数组中任意一个重复的数字。\n\n注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；\n\n样例\n给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。\n\n返回 2 或 3。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int duplicateInArray(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) \n            if (nums[i] < 0 || nums[i] > n - 1) return -1;\n        \n        for (int i = 0; i < n; ++i) {\n            while (i != nums[i]) {\n                int x = nums[i];\n                if (nums[x] == x) return x; //如果坑位已经被占了，说明重复了。\n                else swap(nums[x], nums[i]);\n            }\n        }\n        x\n        return -1;\n    }\n};\n```\n","tags":["本地交换"],"categories":["数据结构与算法"]},{"title":"概率相关问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/possibility.html","content":"\n#### 根据1到m生成1到n随机数\n\n问题1： 给定一个函数rand()能产生1到m之间的等概率随机数，产生1到n之间等概率的随机数？\n\n```cpp\nint rand10()\n{\nint x;\ndo\n{\n    x = (rand7()-1)*7+rand7();\n}while(x > 40)  //【1, 40】的范围\nreturn (x-1） / 4+1; //分为10段，0～9 + 1 =》 1 ～ 10\n}\n```\n\n考虑如果rand（）返回的是浮点呢？\n\n这种情况下可以简化为，如何把[a,b]线段上的点等概率的映射到[c,d]\n\n另外， 为啥不能考虑rand（） \\* rand()呢？\n\n因为不等概率，7*6与6*7的计算结果都是42，这样子就使得出现42的概率是1/49 + 1/49；出现1的概率是1/49。\n\n参考：\n\nhttps://www.cnblogs.com/double-win/archive/2014/04/07/3650314.html\n\nhttps://my.oschina.net/u/4401597/blog/4038277\n\n#### p & 1 -p 生成等概率\n\n问题2： 有一个随机生成器randA()，以p的概率返回0，1-p的概率返回1，利用这个randA()构造randB()，使randB()等概率的返回0和1，即0.5的概率返回0，0.5的概率返回1。\n\n分析比较简单： 出现00的概率是p^2; 出现10的概率是p*(1-p)，出现01的概率是p*(1-p); 出现11的概率是（1-p）^2;\n\n以上，只要丢弃掉00，01的结果； 10与01的出现概率就是相等的；也就各为50%。\n\n```cpp\nint randB()\n{\nint x1, x2;\ndo\n{\n    x1 = randA();\n    x2 = randA();\n}while(x1+x2 != 1)\nreturn x1;\n}\n```\n\n已知一随机发生器，产生0的概率是p，产生1的概率是1-p，\n现在要你构造一个发生器，\n使得它构造0和1的概率均为 1/2；\n构造一个发生器，使得它构造1、2、3 的概率均为 1/3； ...，\n构造一个发生器，使得它构造 1、2、3、...n 的概率均为1/n，要求复杂度最低。\n\n思路：\n由于需要产生1/2，而用1位0，或1位1无法产生等概率，\n因此，考虑将随机数扩展成2位：\n00   p*p\n01  p*(1-p)\n10  (1-p)*p\n11 (1-p)*(1-p)\n有上述分析知道，01和10是等概率的，因此我们只需要产生01和10就行了。\n于是可以，遇到00和11就丢弃，只记录01和10。可以令，01表示0,10表示1，则等概率1/2产生0和1了。\n对于n=2，一次性生成两个数字，认为01表示0，10表示1，\n其它情况放弃，它们的概率都是p*(1-p)；\n对于n=3，一次性生成三个数字，认为001表示0，010表示1，100表示2，\n其它情况放弃，它们的概率都是p*p*(1-p)；\n对于n=4，一次性生成是个数字，认为0001表示0，0010表示1，0100表示2，1000表示3，\n其它情况放弃，它们的概率都是p*p*p*(1-p)；\n5为例，此时我们取x=2，因为C(2x,x)=C(4,2)=6是比5大的最小的x，\n此时我们就是一次性生成4位二进制，把1出现个数不是2的都丢弃，\n这时候剩下六个:0011,0101,0110,1001,1010,1100，\n取最小的5个，即丢弃1100，那么我们对于前5个分别编号1到5，\n这时候他们的概率都是p*p*(1-p)*(1-p)相等了。\n关键是找那个最小的x，使得C(2x,x)>=n这样能提升查找效率。\n因为C(n,i)最大是在i接近n/2的地方取得，此时我有更大比率的序列用于生成，\n换句话说被抛掉的更少了，这样做是为了避免大量生成了丢弃序列而使得生成速率减慢，\n实际上我之所以将x取定是为了让我取得的序列生成的概率互相相等，\n比如C(2x,x)的概率就是[p(1-p)]^x，\n互等的样例空间内保证了对应的每个值取得的样例等概率。\n\n#### Shuffle算法\n\n一个从1到n的序列，随机打乱，保证每个数出现在任意一个位置的概率相同。\n\n基于交换，将a[i]与arr[rand(i, n - 1)]随机交换；\n\n```cpp\n// 得到一个在闭区间 [min, max] 内的随机整数\nint randInt(int min, int max);\n\nvoid shuffle(int[] arr) {\n    int n = arr.length();\n    for (int i = 0 ; i < n; i++) {\n        // 从 i 到最后随机选一个元素\n        int rand = randInt(i, n - 1);\n        swap(arr[i], arr[rand]);\n    }\n}\n```\n\n#### N个数随机选M\n\n问题3： 程序的输入包含两个整数m和n，其中$m \\lt n $。输出是0~n-1范围内m个随机整数的有序列表，不允许重复。从概率的角度来说，我们希望得到没有重复的选择，其中每个选择出现的概率相等。\n\n选出这个序列的概率是：$m/n * (m-1) / (n-1) * ... *  (1)/(n-m)$\n\n```cpp\nvoid generate(int m,int n)\n{\nint t = m;\nfor(int i = 0; i < n; i++)\n    if(Rand(0,n-1-i) < t) //即以t/(n-i)的概率执行下面的语句\n    {\n        printf(\"%d\\n\",i); //这里打印的是i，一直在增长；所以不会重复！！！\n        t--;\n    }\n}\n//随着算法继续，i越大，rand（0，n-1-i)得到的数值越小，就容易被选中，\n//如果i已经等于n-1-t了，则后面的必然全不都被选中。\n```\n\n#### 蓄水池采样算法\n\n问题4： 如何数据流中随机选出N个元素\n\n蓄水池采样算法，具体步骤如下：\n\n（1）先把N个坑位填上\n\n（2）对于后面新来的第i元素，做如下概率处理：令X=rand(0, i), i > N\n\nA. 如果X在[0, N]之间，则用swap(X, i)\n\nB. 否则啥也不做\n\n```cpp\nint i = 0;\nvector<int> res;\nwhile (cin >> Elem) {\n    i++;\n    if (i < N) {\n        res.push(Elem);\n        continue;\n    }\n\n    X = rand(0, i); \n    if (X < N) {\n        swap(res[X], res[i]);\n    }\n}\n```\n\n深入一下，分布式蓄水池算法： https://www.jianshu.com/p/7a9ea6ece2af\n\n### Probability simulation\n\nYou are given a fair coin. Can you design a simple game using the fair coin so that your\nprobability of winning is p, 0 < p < 1\n\n把p表示为2进制小数；例如0.100011100110101\n\n开始抛硬币，正面1； 反面0，计作s[i]\n\n如果第i次抛出1，而p[i] = 0, 则win；\n如果第i次抛出0，而p[i] = 1, 则lose；\n如果s[i] == p[i]，则继续新的循环\n\n### 概率分布\n\n男孩女孩问题\n\n如果一个地区所有人都生了女孩就继续生，直到生出男孩立马停下，这个地区会趋于什么样的男女比例？ \n\n1:1 ，几何分布\n\nhttps://www.zhihu.com/question/355605125\n\n\n一根绳子分三段，能够合成三角形的概率\n\n线性规划 + 几何概率， 1/4\n\n如果在高速公路上30分钟内到一辆车开过的几率是0.95，那么在10分钟内看到一辆车开过的几率是多","tags":["概率"],"categories":["数据结构与算法"]},{"title":"字节版-多路归并","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/merge_sort/merge_k_byte.html","content":"\n算法题2：给定k个数组，每个数组都是有序的，且每个数组最大值-最小值<1000，1 < k<1000，求所有数的中位数。\n\n解答思路：\n\n定义一个结构体 NumCount {\n    int number;\n    int cnt;\n}\n\n预处理所有数据，将原来的数据用NumCount nums[k][1000]来保存。\n\n用一个大顶堆来维护K路的最小值。\n\n时间复杂度：$O(1000 * k)$\n","tags":["排序","归并排序"],"categories":["数据结构与算法","经典题目"]},{"title":"双指针系列-荷兰旗问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/DutchNationalFlag.html","content":"\n0,1,2\n\n分为三段：0段、未判定段、2段，用三个指针（s0, cur, s2)指向每一段的当前位置。\n\ns0并不是指向0段的最后一个元素，而是指向最后一个元素的下一个元素。s2类似。\n\n如果A[cur]=0，则s0（其实指向1）,cur互换位置； s0++; cur++;\n如果A[cur]=1，则cur++;\n如果A[cur]=2,则s2，cur互换位置； s2--; cur不变；\n","tags":["双指针","快速排序"],"categories":["数据结构与算法"]},{"title":"双指针系列-移除AC和B","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/remove_b_ac.html","content":"\n有字符串,将所有连续的ac跟单独的b去掉后的字符串：如bbbacccccb->ccc; aacceacdby->edy\n\n时间复杂度O(n) 空间复杂度O(n) --> 时间复杂度O(n) 空间复杂度O(1)\n\n这是本题较好的一种解法，设两个指针cur和loc分别从头开始出发，cur每次移动一格，另一个指针loc保留当前的操作位置，如果cur指向的字符是c且loc指向的是a，则将loc回移一位（ac抵消了），如果遇到其他非b的字符，则将loc处的字符置为cur处的字符（++location），一直进行直到到cur到达字符串尾部，此时取字符串开头到loc指针之间的子串即为本题的解。这种解法妙就妙在loc处的字符是即时更新的，一些边界条件都自动消除了。\n\n参考：\nhttps://www.cnblogs.com/SteelArm/p/12773014.html","tags":["双指针"],"categories":["数据结构与算法"]},{"title":"找出次数一半的数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/moore_majority_vote.html","content":"\n输入n个整数，输出出现次数大于等于数组长度一半的数。\n输入描述:\n\n每个测试输入包含n个空格分割的n个整数，n不超过100，其中有一个整数出现次数大于等于n/2。\n输出描述:\n\n输出出现次数大于等于n/2的数。\n\n#### 解题思路\n\n摩尔投票法的核心就是一一抵消，删除不同的数。\n\n因为要找过半的数，用一个变量count记录读取每个变量变化的次数，一个变量temp记录可能过半的数。\n\n先让count = 1，然后让temp = vec[0]，然后往后遍历一遍。\n碰到和temp相同的数就给count++，否则就count--，如果count变成0，就让temp=vec[i] (v数组遍历过程中的当前值),并让count = 1。\n\n如此遍历一遍，因为有一个数过半，所以temp最后肯定存储的是过半的数\n\n```cpp\nclass Solution {\npublic:\n    int moreThanHalfNum_Solution(vector<int>& nums) {\n        int cnt = 0;\n        int val = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (!cnt) {val = nums[i];}\n            \n            if (nums[i] == val) {\n                cnt++;\n            }\n            else {\n                cnt--;\n            }\n        }\n        \n        return val;\n    }\n};\n```\n\n参考：\nhttps://www.zhihu.com/question/284969980/answer/440979325","tags":["摩尔投票法"],"categories":["数据结构与算法","剑指Offer"]},{"title":"图论-深度优先遍历","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/graph/dfs.html","content":"\n给定一个包含了一些 0 和 1 的非空二维数组 grid 。\n\n一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n\n找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)\n\n解题思路：\n\nDFS\n","tags":["图论","深度优先遍历"],"categories":["数据结构与算法"]},{"title":"图论-基本算法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/graph/index.html","content":"\n#### 图的表示\n\n稠密图，邻接矩阵；\n\n稀疏图，邻接表\n\n```cpp\n\n(1) 邻接矩阵：g[a][b] 存储边a->b; a, b是定点的序号，特别浪费空间，适合稠密图。\n\n//稀疏图\n(2) 邻接表：\n\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n\n// 添加一条边a->b\nvoid add(int a, int b)\n{\n    //把b当作value， 插入到链表头\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\n```\n\n#### DFS  && BFS\n\n```cpp\n树与图的遍历\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心\n\nint dfs(int u)\n{\n    st[u] = true; // st[u] 表示点u已经被遍历过\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n\n(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次\n\nqueue<int> q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n{\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        }\n    }\n}\n```\n\n#### 拓扑排序\n\n```cpp\n拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列\n时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort()\n{\n    int hh = 0, tt = -1;\n\n    // d[i] 存储点i的入度\n    for (int i = 1; i <= n; i ++ )\n        if (!d[i])\n            q[ ++ tt] = i;\n\n    while (hh <= tt)\n    {\n        int t = q[hh ++ ];\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (-- d[j] == 0)\n                q[ ++ tt] = j;\n        }\n    }\n\n    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt == n - 1;\n}\n```\n\n#### 最短路问题的解法\n\n  | 算法  | 解决的问题 | 算法原理 | 时间复杂度 |\n  |  ----  | ----  | ---- | ---- |\n  | dijkstra| 单源最短路，稠密图， 正权 | 找到最小距离，用找到的最小距离更新剩余距离 |$O(N^2)$ N为图点的数量|\n  | 堆优化版dijkstra| 单源最短路，稀疏图，正权 | 借助堆来优化dijkstra算法中的查找最小值操作 |$O(N^2)$N为图点的数量|\n  | bellman-ford| 单源最短路，负边权，限制步数的情形 | 迭代k次，每次找最小距离 |$O(N^2)$ N为图点的数量|\n  | SPFA| 单源最短路，负边权，判定有没有负环 | 队列优化 |$O(N^2)$ N为图点的数量|\n  | floyd| 多源汇最短路 | 动态规划思想，三角不等式 |$O(N^3)$ N为图点的数量|\n\n```cpp\n\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I\n时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint g[N][N];  // 存储每条边\nint dist[N];  // 存储1号点到每个点的最短距离\nbool st[N];   // 存储每个点的最短路是否已经确定\n\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i < n - 1; i ++ )\n    {\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j <= n; j ++ )\n            if (!st[j] && (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        // 用t更新其他点的距离\n        for (int j = 1; j <= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n\n        st[t] = true;\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II\n时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数\ntypedef pair<int, int> PII;\n\nint n;      // 点的数量\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储所有点到1号点的距离\nbool st[N];     // 存储每个点的最短距离是否已确定\n\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    heap.push({0, 1});      // first存储距离，second存储节点编号\n\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n\n        int ver = t.second, distance = t.first;\n\n        if (st[ver]) continue;\n        st[ver] = true;\n\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\nBellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路\n时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数\n注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\n\nint n, m;       // n表示点数，m表示边数\nint dist[N];        // dist[x]存储1到x的最短路距离\n\nstruct Edge     // 边，a表示出点，b表示入点，w表示边的权重\n{\n    int a, b, w;\n}edges[M];\n\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i < n; i ++ )\n    {\n        for (int j = 0; j < m; j ++ )\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] > dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n\nspfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路\n时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N];        // 存储每个点到1号点的最短距离\nbool st[N];     // 存储每个点是否在队列中\n\n// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    queue<int> q;\n    q.push(1);\n    st[1] = true;\n\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\nspfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n;      // 总点数\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数\nbool st[N];     // 存储每个点是否在队列中\n\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n{\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n\n    queue<int> q;\n    for (int i = 1; i <= n; i ++ )\n    {\n        q.push(i);\n        st[i] = true;\n    }\n\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nfloyd算法 —— 模板题 AcWing 854. Floyd求最短路\n时间复杂度是 O(n3)O(n3), nn 表示点数\n初始化：\n    for (int i = 1; i <= n; i ++ )\n        for (int j = 1; j <= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n{\n    for (int k = 1; k <= n; k ++ )\n        for (int i = 1; i <= n; i ++ )\n            for (int j = 1; j <= n; j ++ )\n     \n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\n```\n\n#### 最小生成树问题的解法\n\n| 算法  | 解决的问题 | 算法原理 | 时间复杂度 |\n|  ----  | ----  | ---- | ---- |\n| prim算法| 单源最短路，稠密图， 正权 | 找到最小距离，用找到的最小距离更新剩余距离 |$O(N^2)$ N为图点的数量|\n| kraskal算法| 单源最短路，稀疏图，正权 | 并查集 |$O(N^2)$ N为图点的数量|\n\n```cpp\n\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树\n时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数\nint n;      // n表示点数\nint g[N][N];        // 稠密图 邻接矩阵，存储所有边\nint dist[N];        // 存储其他点到当前最小生成树的距离\nbool st[N];     // 存储每个点是否已经在生成树中\n\n稠密图，朴素版prim N^2\n稀疏图，heap优化版 mlgn 很少用，用kruakal替代\n\nkruskal mlgm\n// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n{\n    memset(dist, 0x3f, sizeof dist);\n\n    int res = 0;\n    for (int i = 0; i < n; i ++ )\n    {\n        int t = -1;\n        for (int j = 1; j <= n; j ++ )\n            if (!st[j] && (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        if (i && dist[t] == INF) return INF;\n\n        if (i) res += dist[t];\n        st[t] = true;\n\n        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);\n    }\n\n    return res;\n}\n\nKruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树\n时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数\nint n, m;       // n是点数，m是边数\nint p[N];       // 并查集的父节点数组\n\nstruct Edge     // 存储边\n{\n    int a, b, w;\n\n    bool operator< (const Edge &W)const\n    {\n        return w < W.w;\n    }\n}edges[M];\n\nint find(int x)     // 并查集核心操作\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\n\nint kruskal()\n{\n    sort(edges, edges + m);\n\n    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集\n\n    int res = 0, cnt = 0;\n    for (int i = 0; i < m; i ++ )\n    {\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n        a = find(a), b = find(b);\n        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并\n        {\n            p[a] = b;\n            res += w;\n            cnt ++ ;\n        }\n    }\n\n    if (cnt < n - 1) return INF;\n    return res;\n}\n\n```\n\n如何判定图是不是二分图：DFS遍历，奇数环\n\n二分图匹配：匈牙利算法\n\n```cpp\n染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图\n时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nint n;      // n表示点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储图\nint color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色\n\n// 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n{\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (color[j] == -1)\n        {\n            if (!dfs(j, !c)) return false;\n        }\n        else if (color[j] == c) return false;\n    }\n\n    return true;\n}\n\nbool check()\n{\n    memset(color, -1, sizeof color);\n    bool flag = true;\n    for (int i = 1; i <= n; i ++ )\n        if (color[i] == -1)\n            if (!dfs(i, 0))\n            {\n                flag = false;\n                break;\n            }\n    return flag;\n}\n\n匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配\n时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数\nint n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数\nint h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边\nint match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个\nbool st[N];     // 表示第二个集合中的每个点是否已经被遍历过\n\nbool find(int x)\n{\n    for (int i = h[x]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true;\n            if (match[j] == 0 || find(match[j]))\n            {\n                match[j] = x;\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\nint res = 0;\nfor (int i = 1; i <= n1; i ++ )\n{\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n}\n```\n","tags":["图论"],"categories":["数据结构与算法"]},{"title":"动态规划系列-不相邻序列最大和","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/max_sum_no_adj.html","content":"\nMaximum sum such that no two elements are adjacent\nGiven an array of positive numbers, find the maximum sum of a subsequence with the constraint that no 2 numbers in the sequence should be adjacent in the array. So 3 2 7 10 should return 13 (sum of 3 and 10) or 3 2 5 10 7 should return 15 (sum of 3, 5 and 7).Answer the question in most efficient way.\nExamples :\nInput : arr[] = {5, 5, 10, 100, 10, 5}\nOutput : 110\n\nInput : arr[] = {1, 2, 3}\nOutput : 4\n\nInput : arr[] = {1, 20, 3}\nOutput : 20\n\n## 不相邻序列最大和--思路\n\n遍历array 中的所有元素，设置两个变量：\n\nexcl[i]: 不包含i元素的最大和\n\nincl[i]: 包含i元素的最大和\n\n更新当前元素的 excl 和 incl：\n\n不包含当前元素的最大和 excl[i] = max(incl[i-1]， excl[i-1])\n\n包含当前元素的最大和 incl = excl[i-1]+A[i] (元素不能相邻)\n\n因为只与前一项有关，所以可以用空间压缩。\n","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"动态规划系列-丑数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/ugly_number.html","content":"\n我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。\n\n例如6、8都是丑数，但14不是，因为它包含质因子7。\n\n求第n个丑数的值。\n\n样例\n输入：5\n\n输出：5\n注意：习惯上我们把1当做第一个丑数。\n\n#### 解答思路\n\n第二种：创建数组保存已经找到丑数，用空间换时间的解法。\n根据丑数的定义， 丑数应该是另一个丑数乘以 2、3 或者 5 的结果（1 除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以 2、3 或者 5 得到的。\n\n这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经有若干个丑数排好序后存放在数组中，并且把己有最大的丑数记做M，我们接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以 2、3 或者 5 的结果， 所以我们首先考虑把已有的每个丑数乘以 2。在乘以 2 的时钝能得到若干个小于或等于 M 的结果。由于是按照顺序生成的，小于或者等于 M 肯定己经在数组中了，我们不需再次考虑：还会得到若干个大于 M 的结果，但我们只需要第一个大于 M 的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以 2 后大于 M 的结果记为 M2，同样，我们把已有的每一个丑数乘以 3 和 5，能得到第一个大于 M 的结果 M3 和 M，那么下一个丑数应该是 M2、M3 和 M5 这 3 个数的最小者。\n\n前面分析的时候，提到把已有的每个丑数分别都乘以 2、3 和 5。事实上这不是必须的，因为已有的丑数是按顺序存放在数组中的。对乘以 2 而言， 肯定存在某一个丑数 T2，排在它之前的每一个丑数乘以 2 得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以 2 得到的结果都会太大。我们只需记下这个丑数的位置， 同时每次生成新的丑数的时候，去更新这个 T2。对乘以 3 和 5 而言， 也存在着同样的 T3 和 T5。\n\nT2的更新是需要靠遍历来完成的，但是需要明确的是：T2不需要每次都从0开始，他是越来越大的。\n","tags":["动态规划"],"categories":["数据结构与算法","剑指Offer"]},{"title":"动态规划系列-矩阵中找一条最长的递增路径","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/long_path_in_2d_array.html","content":"\n求解一个矩阵中找一条最长的递增路径？\n\n可能解法：有向图DFS和记忆化搜索处理\n\ndp[i][j]表示以(i,j)出发的最长路径。\n\n该题目用常规的DP很难完成，因为他没有base condition，不知道从何处开始计算。\n","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"动态规划系列-切绳子问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/maxProductAfterCutting.html","content":"\n给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。\n\n每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？\n\n例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。\n\n样例\n输入：8\n\n输出：18\n\n自上而下 + 备忘录解法\n\n```cpp\nclass Solution {\npublic:\n    vector<int> dp;\n    \n    int dfs(int n) {\n        if (dp[n] > 0) {\n            return dp[n];\n        }\n        \n        if (n <= 3) {\n            dp[n] = n - 1;\n            return n - 1; \n        }\n        if (n == 4) {\n            dp[n] = 4;\n            return dp[n];\n        }\n         if (n == 5) {\n            dp[n] = 6;\n            return dp[n];\n        }\n        int max_score = 0;\n        for (int i = 2; i <= n - 2; ++i) {\n            //分为两种情况：第一刀减在i处；剩下的那一部分可以有两种选择：不剪，或者继续剪\n            max_score = max(max_score, max(i * (n - i), i * dfs(n - i)));\n        }\n        dp[n] = max_score;\n        return dp[n];\n    }\n\n    int maxProductAfterCutting(int length) {\n        dp = vector<int>(length + 5, 0);\n        return dfs(length);\n    }\n};\n```","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"动态规划系列-礼物最大价值","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/getMaxValue.html","content":"\n在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。\n\n你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。\n\n给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？\n\n注意：\n\nm,n>0\n样例：\n\n输入：\n[\n[2,3,1],\n[1,7,1],\n[4,6,1]\n]\n\n输出：19\n\n解释：沿着路径 2→3→7→6→1 可以得到拿到最大价值礼物。\n\n\n解题思路：\n\n1. 自上而下 + 记忆化搜索\n2. 动态规划\n\n```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    int res;\n    int m;\n    int n;\n    vector<vector<int>> grid;\n    vector<vector<int>> dp;\n    \n    /*\n    void dfs(int x, int y, int sum) {\n        if (x == m - 1 && y == n -1) {\n            res = max(res, sum);\n            return;\n        }\n        \n        int dx[] = {0, 1};\n        int dy[] = {1, 0};\n        for (int k = 0; k < 2; ++k) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] >= 0) {\n                int b = grid[nxa][ny];\n                grid[nx][ny] = -1;\n                dfs(nx, ny, sum + b);\n                grid[nx][ny] = b;\n            }\n        }\n    }\n    \n    int getMaxValue(vector<vector<int>>& _grid) {\n        grid = _grid;\n        m = grid.size();\n        n = grid[0].size();\n        dfs(0, 0, grid[0][0]);\n        return res;\n    }\n    */\n    \n\n     int dfs(int i, int j) {\n        if (dp[i][i] >= 0) {\n            return dp[i][j];\n        }\n        \n        if (i == 0 && j == 0) {\n            return dp[i][j] = grid[i][j];\n        }\n        \n        dp[i][j] = grid[i][j] + max(\n                                j - 1 >= 0 ? dfs(i, j - 1) : INT_MIN, \n                                i - 1 >= 0 ? dfs(i - 1, j) : INT_MIN);\n        return dp[i][j];\n    }\n    \n    int getMaxValue(vector<vector<int>>& _grid) {\n        grid = _grid;\n        m = grid.size();\n        n = grid[0].size();\n        dp = vector<vector<int>>(m, vector<int>(n, -1));\n        dfs(m - 1, n - 1);\n        return dp[m - 1][n - 1];\n    }\n};\n```\n","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"有序矩阵查找","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/search_2d_array.html","content":"\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。\n\n请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n样例\n输入数组：\n\n[\n[1,2,8,9]，\n[2,4,9,12]，\n[4,7,10,13]，\n[6,8,11,15]\n]\n\n如果输入查找数值为7，则返回true，\n\n如果输入查找数值为5，则返回false。\n\n```cpp\nclass Solution {\npublic:\n    bool searchArray(vector<vector<int>> array, int target) {\n        if (array.empty() || array[0].empty()) return false;\n        int i = 0, j = array[0].size() - 1;\n        while (i < array.size() && j >= 0) {\n            if (array[i][j] == target) return true;\n            if (array[i][j] > target) j--;\n            else i++;\n        }\n        return false;\n    }\n};\n```\n","tags":["分治"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二分系列-概览","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/index.html","content":"\n### 关于二分\n\n二分是分治的一种；问题收敛速度最快的一种。\n\n通过每次把问题搜索空间排除一半，进而得到lgN的时间复杂度。\n\n将区间分为两部分，第一部分满足某一个特征；第二部分满足另一个特征\n\n通过二分来解决的问题包括：\n\n1. 二分查找一个数组\n2. 通过二分的方式，遍历所有可能的结果。然后判定结果是否ok。也就是把查找问题转换为判定问题。\n\n二分答案：答案具有“单调性”，外层花费$logN$的时间转化为判定性问题.\n\n答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？\n\n一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的\n\n二分出的答案一般对check的进行有所帮助\n\n```cpp\n//整数二分算法模板 https://www.cnblogs.com/smallocean/p/11913963.html\n\nbool check(int x) {return true;/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n//浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根\nbool check(double x) {/* ... */} // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l > eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n```\n\n## 二分相关题目索引\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n|| [查第一个出现的位置](getNumberOfK.html)  ||\n|| [递增找number与index相等](getNumberSameAsIndex.html)  ||\n|| [重复数字出现次数](moving_cnt.html)  ||\n|| [旋转数组找最值](find_min_in_rotated_array.html)  ||\n|| 求两个有序数组前K大的数|考虑A的中间元素m/2和B的中间元素n/2||\n|| 多路归并| 求m个有序数组前K大的数 | 维护一个大小为m的堆||\n\n参考：\n\nhttps://zhuanlan.zhihu.com/p/157779732\n\nhttps://www.dazhuanlan.com/2019/12/16/5df6e82127d88/\n\nhttps://blog.csdn.net/weixin_34355715/article/details/94465888\n\nhttps://blog.csdn.net/weixin_43626741/article/details/104364387\n","tags":["二分"],"categories":["数据结构与算法"]},{"title":"常见系统设计题系列-分布式锁","url":"/backend_knowledge_architecture/system_design/distributed_lock.html","content":"### 分布式锁应该具备哪些条件\n\n1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行\n2. 高可用的获取锁与释放锁\n3. 高性能的获取锁与释放锁\n4. 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）\n5. 具备锁失效机制，防止死锁\n6. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败\n\nps. 考虑幂等性\n\n### 分布式锁实现\n\n基于数据库\n\n基于Redis SET命令\n\n基于Memcache CAS命令\n\n基于Zookeeper\n\n### 具体参考\n\nhttps://www.jianshu.com/p/a1ebab8ce78a\n","categories":["系统设计"]},{"title":"高性能服务器设计-定时器","url":"/backend_knowledge_architecture/server/timer/index.html","content":"\n设计目标：\n\n1. 高性能，更快的找到下一个超时的Task\n2. 高分辨率，例如毫秒定时器\n\n实现方式：\n\n- 时间轮、多级时间轮\n- 堆\n- 基于排序链表 O(N)\n- 红黑树\n\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-littile's raw定律","url":"/backend_knowledge_architecture/server/concurrency_limiter/little_raw.html","content":"\n并发 = rt * qps\n\n#### N = X * R\n\nN表示系统中同时活动的用户，包括正在处理中和队列中的；X表示用户相继到达系统的速率，在平衡状态时即为系统吞吐量（到达=离开）；R表示每个用户在系统中平均的驻留时间\n\neg. 一个请求在系统中的停留时间，1s; 一秒钟平均过来100个请求（当然一秒钟也会离开100个请求）那么系统同时处理的请求数是多少？\n\n应该是1s * 100 (个/s) = 100个。\n\n#### Eric的估算公式 C = L * n / T\n\nn表示同时在线；L表示平均停留时间；T表示高峰期持续时间；C为并发用户数量。\n\neg. 一个用户在系统中的停留时间，30分钟；晚高峰5～7点，有500在线；问系统的并发用户是多少？\n\n假设系统后端维护session，那么这个session的长度即为30分钟，L=30minutes；用户活跃时长已经得知是从5点到7点共2个小时，T=2 hours；那么并发用户数C=n*L/T=500*30/(5*60)=50\n\n#### 等价性说明\n\n我们再来从另外的角度分解Eric的估算公式：\n\nC=n*L/T  可以表示为  C=(n/T)*L\n\nn/T 是不是和我们刚才在上面Little中第一步一样，是计算到达率X的。\n\n而L（session时长）不就是R（驻留时间）吗？都等同于session时间长度。\n\n也就是说C=(n/T)*L=X*R=N\n\n结论：由以上得知，Eric's 估算公式跟Little定律是等价的.\n\n参考：https://www.cnblogs.com/hundredsofyears/p/3360305.html\n\n并发  = 到达率X * 停留时间R\n\n并发 = （同时在线人数c  / 高峰期持续时长T） * 平均停留时间L\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-限流模型","url":"/backend_knowledge_architecture/server/concurrency_limiter/index.html","content":"\n服务的处理能力是有客观上限的。当请求速度超过服务的处理速度时，服务就会过载。\n\n如果服务持续过载，会导致越来越多的请求积压，最终所有的请求都必须等待较长时间才能被处理，从而使整个服务处于瘫痪状态。\n\n与之相对的，如果直接拒绝掉一部分请求，反而能够让服务能够\"及时\"处理更多的请求。 我们称这种做法为限流。限流是过载保护的手段之一，目的在于保护系统不被超过服务吞吐能力的流量（或突发）打死。\n\n常见的限流手段有固定窗口、滑动窗口、令牌桶、漏桶、BBR、brpc自适应限流等。\n\n下面挨个介绍每一种限流算法的原理以及优缺点。\n\n### 传统的基于配置的单机限流算法\n\n#### 第一，固定窗口\n\n原理：维护一个窗口的两个信息：窗口开始时间、经过窗口的请求数。如果窗口内超出限制数则拒绝。如果已经进入新的窗口，则reset计数。\n\n不足：存在临界点（窗口reset前后的瞬时）的qps会飙高，从而打死系统。\n\n#### 第二，滑动窗口\n\n原理：将总的时间窗口划分为N个小格，并单独维护每一个小格的计数。通过这种方式，可以把过去一段时间内的计数信息也用上，从而让限流的统计更精确一些。\n\n不足：窗口不可能无限划分\n\n#### 第三，漏桶\n\n原理：漏桶具有固定容量，出水速率是固定常量（流出请求）如果桶是空的，则不需流出水滴。可以以任意速率流入水滴到漏桶（流入请求）如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）\n\n不足：无法应对突发流量\n\n![20201222223148](http://cdn.b5mang.com/20201222223148.png)\n\n#### 第四，令牌桶\n\n原理：假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中。假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃。当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络。如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外。\n\n算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。\n\n![20201222223820](http://cdn.b5mang.com/20201222223820.png)\n\n### 自适应限流\n\n上面的几种算法，一定程度上确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。具体有如下几个弊端：\n\n1. 集群增加机器或者减少机器限流阈值是否要重新设置?\n2. 设置限流阈值的依据是什么?\n3. 人力运维成本是否过高?\n4. 只针对局部服务端的限流，无法掌控全局资源，\n5. 当调用方反馈限流错误时, 这个时候重新设置限流, 其实流量高峰已经过了。重新评估限流是否有意义？\n\n#### 第五，B站BBR限流\n\n底层原理：并发 = qps * latency\n\n自适应限流能动态调整服务的最大并发，在保证服务不过载的前提下，让服务尽可能多的处理请求。\n\n具体逻辑：如果cpu > 800 && inflight >  rt * max_qps，则启用限流\n\n为什么要用 CPU\\IOPS 作为启发值呢？\n\n因为自适应限流与 TCP 拥塞控制还存在不同之处，TCP 中客户端可以控制发送率，从而探测到 maxPass，但是 RPC **线上无法控制流量的速率**，所以必须以 CPU 作为标准，当 CPU 快满载的时候再开启，这时我们认为之前探测到的 maxPass 已经接近了系统的瓶颈，乘以 minRtt 就可以得到 InFlight\n\n#### 第六，BRPC自适应限流\n\n- peek_qps 峰值qps\n- nodelay_latency 系统无负载或者低负载的响应时间，理论值无法计算\n- Min_latency 用来替代nodelay_latency\n- max_cocurrent  = max_qps \\* ((2+alpha) \\* min_latency - latency)\n\n服务的noload_latency并非是一成不变的，自适应限流必须能够正确的探测noload_latency的变化。当noload_latency下降时，是很容感知到的，因为这个时候latency也会下降。难点在于当latency上涨时，需要能够正确的辨别到底是服务过载了，还是noload_latency上涨了。\n\n\n参考：\n\n[BRPC开发手册](http://www.mianshigee.com/tutorial/incubator-brpc/1778a50865eb3518.md)\n\n[B站在微服务治理中如何探索与实践](https://xueqiu.com/9217191040/139169952)\n","tags":["高性能服务器"]},{"title":"消息队列-Kafka","url":"/backend_knowledge_architecture/mq/kafka.html","content":"\n![设计思想](https://img-blog.csdn.net/20180317011215184?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n#### cosume group\n\n通过cosume group，巧妙的解决了广播问题。\n\n#### 高性能\n\nSendFile、zero copy\n\n#### 索引设计\n\nKafka为了卸载MQ本身的复杂性，为了其**真正无状态**的设计，它将状态维护机制这口锅完全甩给了消费者，因此取消息的问题就转化成了**消费者拿着一个offset索引来Kafka存储器里取消息**的问题，这就涉及到了性能。But 如何能查的更快？How？\n\n![扫描partition文件](https://img-blog.csdn.net/20180317015646335?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n但实际上，\n\n![partition](https://img-blog.csdn.net/20180317020648952?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n1. partition并不是一根文件，而是一个目录\n2. 目录下面存了很多逻辑上的segment，每一个segment物理上包括两个文件：索引文件、日志文件（每次都append)\n\n文件的命名相当于查找的稀疏索引，省去索引文件\n\n每个segment索引又是一个稀疏索引减少索引文件的大小\n\n在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。\n\n### 16.为什么Kafka不支持读写分离？\n\nKafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:\n\n(1)数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。\n\n(2)延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。\n\n#### replication\n\n2.1 消息备份\n\nKafka允许同个Partition存在多个消息副本(Replica)，每个Partition的副本通常由1个Leader及0个以上的Follower组成，产者将消息直接发往对应Partition的Leader，Follower会周期地向Leader发送同步请求，Kafka的Leader机制在保障数据致性地同时降低了消息备份的复杂度。同Partition的Replica应存储在同一个Broker上，因为一旦该Broker宕机，对应Partition的所有Replica都无法作，这就达不到高可用的效果。为做好负载均衡并提容错能，Kafka会尽将所有的Partition以及各Partition的副本均匀地分配到整个集群上。举个例，当集群中部署3台Broker，TopicA共有4个Partition，每个Partition均有3个Replica时下图就是种合理的分布方式。\n\n![](https://pics4.baidu.com/feed/d833c895d143ad4b76bc3f8833f912a7a60f06ef.jpeg)\n\nISR:In-Sync Replicas 副本同步队列\n\nISR(In-Sync Replicas)指的是个Partition中与Leader“保持同步”的Replica列表(实际存储的是副本所在Broker的BrokerId)，这的 保持同步是指与Leader数据保持完全一致，只需在replica.lag.time.max.ms时间内与Leader保持有效连接，官方解释如下If a follower hasn't sent any fetch requests or hasn't consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr,( default value =10000 )Follower周期性地向Leader发送FetchRequest请求(数据结构见下)，发送时间间隔配置在replica.fetch.wait.max.ms中，默认值为 500。\n\nAR:Assigned Replicas 所有副本\n\nISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR。\n\nISR数据同步、ACK选项（全部ack、只有一个ack）\n\nKafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。\n\n完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。\n\n而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据。\n\nkafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。\n\nleader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除\n\n#### Log End Offset\n\n当前broker收到的最新offset\n\n#### HighWatermark\n\n已经同步到其他slave中的offset\n\n#### Leader epoch\n\n由于follower的HW的更新，需要一轮额外的消息拉取，如果folloer很多的话，就需要多轮拉取Leader 副本高水位更新和 Follower 副本高水位更新在时间上是存在错配的，会导致数据的\n不一致，所以Leader epoch登场。\n\nEpoch，一个单调增加的版本号。每当leader发生变更时，都会增加该版本号。小版本号的Leader 被认为是过期 Leader，不能再行使 Leader权力。\n\n起始位移，Leader 副本在该 Epoch 值上写入的首条消息的位移类似于zookeper的leader机制，通过leader epoch的单调递增，以此避免副本宕机重启导致的消息同步错乱\n\n参考：\n\nhttps://blog.csdn.net/dog250/article/details/79588437\nhttps://www.jianshu.com/p/469ec6dcdc02\nhttps://blog.csdn.net/qq_28900249/article/details/90346599","tags":["消息队列"]},{"title":"消息队列-概览","url":"/backend_knowledge_architecture/mq/index.html","content":"\n可能的一些作用：\n\n1. 非核心逻辑异步化，追求高性能\n2. 解除耦合，Event Driven 事件驱动设计\n3. 实现广播\n4. 削峰填谷，把峰值流量缓冲下来，后面慢慢处理\n\n---\n\n具体可以用于：\n\n1. 分布式事务，单方生产，多个消费业务逻辑\n2. 数据复制：通过消息队列，将数据复制到多个目的地（多维度数据表、ES、Hadoop、搜索等）\n3. 日志同步：多个app生产日志并放入队列，然后消费队列完成日志的离线与实时处理\n4. 延迟队列：可靠的延迟队列，分布式环境定时器\n5. 广播通知：Cache失效通知\n\n---\n\n### 消息队列的缺点\n\n系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。\n\n系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已\n\n一致性问题：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。\n\n### 主流消息队列对比\n\n|  特性 | ActiveMQ | RabbitMQ |RocketMQ | kafka |\n|  ----  | ----  | ---- |----  | ---- |\n|单机吞吐量 |万级，吞吐量比RocketMQ和Kafka要低了1个数量级 |同ActiveMQ|10万级，可支撑高吞吐|10w量级|\n| topic数量对吞吐量的影响 |||topic可达几百几千，吞吐小幅下降，**一大优势**|topic从几十到上百，吞吐大幅下降；单机支持topic不宜过多，如有需要可以加更多机器|\n| MasterSlave |主-从|主-从|物理Master-Slave|逻辑上Master-Slave,按照Partition|\n|分布式消息事务 ||支持|支持|不支持|\n| 延迟消息 |||支持|不支持|\n| 消息投递实时性 |||RocketMQ使用长轮询，同Push方式实时性一致，消息的投递延时通常在几个毫秒|Kafka使用短轮询方式，实时性取决于轮询间隔时间|\n| 消费失败重试 |||RocketMQ消费失败支持定时重试，每次重试间隔时间顺延|Kafka消费失败不支持重试|\n| 消息顺序 ||RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序|支持|Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序|\n| 主从选举 |||不需要选举NameServer|KRaft选举|\n|时效性|ms|us，最大特点，延迟低|ms|ms|\n|可用性 |高，基于主从架构实现高可用性 |同ActiveMQ|非常高，分布式架构|非常高，分布式，单数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用|\n|消息可靠性|较低概率丢数据 ||经过参数优化配置，可以做到0丢失|同RocketMQ|\n|功能支持|极其完备 |基于erlang开发，所以并发能力很强，性能极其好，延时很低|MQ功能较为元善，还是分布式的，扩展性好|功能较为简单|\n|总体优劣势|早期使用，社区不活跃 |吞吐低，语言不熟，开源社区活跃，小公司|阿里品牌保障（利弊）要求技术研发力量，大公司|大数据领域|\n\nMaster/Slave概念差异\nKafka：Master/Slave 是个逻辑概念，1 台机器同时是 Master 和 Slave。\nRocketMQ：Master/Slave 是个物理概念，1 台机器只能是 Master 或者 Slave。\n\n参考：https://blog.csdn.net/wdj_yyds/article/details/123534023\n\n### 分布式消息队列评价指标\n\n#### 可靠\n\n分布式消息队列提供更好的可靠性，主要体现在：\n\n1. 消息会被持久化到分布式存储中。这样避免了单台机器存储的消息由于机器问题导致消息的丢失；\n2. 不佳的网络环境中，保证只有当消息的接收者确实收到消息时才从队列中删除消息。\n\n#### 可扩展\n\n可扩展性体现在访问量和数据量两个方面：\n\n访问量：分布式消息队列服务，会随着访问量的增减而自动增减逻辑处理服务器；\n\n数据量：当数据量扩大时，后端分布式存储会自动扩容。\n\n#### 安全\n\n安全体现在以下两个方面：\n\n1. 同时使用消息队列的业务之间不会互相干扰。如果有多个业务同时在使用消息队列，对于单机的消息队列服务，一个业务的消息操作可能会影响其他业务的正常运行。比如，一个业务的消息操作特别频繁，占据了消息队列的绝大部分服务时间，也占据了这台服务器的绝大部分网络IO，导致其他业务无法正常地与消息队列通信。而且甚至可能由于服务控制不当，导致机器崩溃，服务停止，业务也跟着停止。分布式消息队列则不会出现这个问题：\n（1）监控措施完善，系统性能指数会控制在一定范围之内，而且有任何异常也会报警；\n（2）当访问量和数据量增大时，分布式消息队列服务可以自动扩展。\n\n2. 各业务的消息内容是安全存储的，其他业务不能访问到非自身业务的数据。\n一方面是业务需要密钥来访问消息队列；另一方面，消息是被加密存储的。\n\n#### 简单实用\n\n简单实用体现在：\n\n1. 透明：接收者和发送者无需知道具体的消息队列的服务器地址，服务器的增减对接收者和发送者透明。\n2. 实用：对于两个服务之间不能通信的网络情况，消息队列为他们提供了恰到好处的桥梁。\n\n### 如何保证消息不丢\n\n#### 生产端不丢消息\n\n生产端如何保证不丢消息呢？确保生产的消息能到达存储端。\n\n如果是RocketMQ消息中间件，Producer生产者提供了三种发送消息的方式，分别是：\n\n- 同步发送\n- 异步发送\n- 单向发送\n\n生产者要想发消息时保证消息不丢失，可以：\n\n- 采用同步方式发送，send消息方法返回成功状态，就表示消息正常到达了存储端Broker。\n- 如果send消息异常或者返回非成功状态，可以重试。\n- 可以使用事务消息，RocketMQ的事务消息机制就是为了保证零丢失来设计的\n\n#### 存储端不丢消息\n\n如何保证存储端的消息不丢失呢？ 确保消息持久化到磁盘。大家很容易想到就是刷盘机制。\n\n刷盘机制分同步刷盘和异步刷盘：\n生产者消息发过来时，只有持久化到磁盘，RocketMQ的存储端Broker才返回一个成功的ACK响应，这就是同步刷盘。它保证消息不丢失，但是影响了性能。\n异步刷盘的话，只要消息写入PageCache缓存，就返回一个成功的ACK响应。这样提高了MQ的性能，但是如果这时候机器断电了，就会丢失消息。\n\nBroker一般是集群部署的，有master主节点和slave从节点。消息到Broker存储端，只有主节点和从节点都写入成功，才反馈成功的ack给生产者。这就是同步复制，它保证了消息不丢失，但是降低了系统的吞吐量。与之对应的就是异步复制，只要消息写入主节点成功，就返回成功的ack，它速度快，但是会有性能问题。\n\n#### 消费阶段不丢消息\n\n### 如何保证消息顺序\n\n消费者执行完业务逻辑，再反馈会Broker说消费成功，这样才可以保证消费阶段不丢消息。\n\n消息队列保证顺序性整体思路就是这样啦。比如Kafka的全局有序消息，就是这种思想的体现: 就是生产者发消息时，1个Topic只能对应1个Partition，一个 Consumer，内部单线程消费。\n\n但是这样吞吐量太低，一般保证消息局部有序即可。在发消息的时候指定Partition Key，Kafka对其进行Hash计算，根据计算结果决定放入哪个Partition。这样Partition Key相同的消息会放在同一个Partition。然后多消费者单线程消费指定的Partition。\n\n### 如何实现消息事务\n\n下面是RabbitMQ/RocketMQ消息事务的实现机制\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4p5f9xibq5m0.webp)\n\n1. 生产者产生消息，发送一条半事务消息到MQ服务器\n2. MQ收到消息后，将消息持久化到存储系统，这条消息的状态是待发送状态。\n3. MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件\n4. 生产者执行本地事务\n5. 如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。\n6. 如果是正常的commit，MQ服务器更新消息状态为可发送；如果是rollback，即删除消息。\n7. 如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。\n8. 如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。\n","tags":["消息队列"]},{"title":"微服务系列-服务注册与发现","url":"/backend_knowledge_architecture/micro_service/discovery.html","content":"\n集成：在服务提供端或者调用端，如何集成注册中心？应用内 OR 应用外\n\n测活：服务注册之后，如何对服务进行测活以保证服务的可用性\n\n负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？\n\n运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？\n\n可用性：如何保证注册中心本身的可用性，特别是消除单点故障？\n\n状态获取：（1）主动探测（2）心跳上报\n\n一些可能问题：\n\n- 保护机制：如果短时间内摘除的节点数量超过集群的40%，则停止摘除节点\n- 通知风暴问题（准备更多的注册中心节点；精简通知内容）\n\n目前比较流行的解决方案包括：\n\n|  对比维度 | euraka|consul   |ZK|\n|  ----  | ---- |----  |----  |\n|实现思路 | 去中心化，通过复制来同步数据，但不保证一致性。只要有一个节点可用，系统整体就可用。| 内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案 |使用ZK节点临时节点来维护服务器列表,ZK支持watch节点变更通知机制 |\n|测活     | 客户端心跳  |  TCP/HTTP/gRPC/Cmd |自研-客户端心跳|\n|负载均衡  | Ribbon  |    Fabio |自研-负载均衡|\n|雪崩保护 | 有，灾难态进入自我保护模式  |    无 |自研|\n|自动注销实例 | 支持  |  支持 |进程不可用，临时节点自动销毁|\n|访问协议     | HTTP  |    HTTP/DNS |自研|\n|监听支持     | 支持  |    支持 |WATCH NODE变更|\n|多数据中心     | 支持  |    支持 |不支持|\n|跨注册中心同步  | 支持  |    支持 |不支持|\n|框架集成     | SpingCloud继承  |  Spring、k8s集成 |无|\n|优点     | 去中心化，高可用  |  功能相对完善 |简单容易实现，适用于初创期|\n|不足     | 一致性差  |    可用性无保证 |服务可用性无保障<br>ZK跨机房集群支持不佳|\n|CAP     | AP               |CP          |CP     |\n|一致性协议 | 仅复制，非强一致  |raft|zab，一种类paxos协议|\n\n![20201222213947](http://cdn.b5mang.com/20201222213947.png)","tags":["微服务"]},{"title":"微服务系列-概览","url":"/backend_knowledge_architecture/micro_service/micro_service.html","content":"\n#### 单体到微服务\n\n为什么要转向微服务架构（收益）\n\n1. 系统扩展性不足（例如，因为DB连接问题导致无法持续扩容）\n2. 迭代效率低。如果是预估到业务在飞速增长，那就别犹豫，一定要提前考虑微服务的拆分。\n3. 系统编译、部署成本高\n4. 如果在设计架构的时候，发现需要很多异构的技术栈，那也要考虑下微服务。\n\n转向微服务架构需要克服什么困难（成本）\n\n1. 技术基础设施要求比较高（如果公司技术基础设施非常完备，对应的业务起初就设计的非常复杂，那么也别犹豫，起手就上微服务。）\n2. 工程拆分挑战比较大，实现时容易为了拆分而拆分。\n\n#### 拆分原则\n\n从单体到微服务，也许可以有一个过度：工程的拆分\n\n微服务拆分的大原则\n\n1. 单一服务内的高内聚、低耦合，单一职责\n2. 拆分粒度：先粗拆，后细拆（伴随业务复杂度的变多，或者对业务的理解程度加深）\n3. 拆分过程中，要避免影响业务的日常功能迭代--按照依赖顺序，挨个拆分\n4. 确保服务接口定义有可扩展性\n5. 避免环形依赖问题（通过分层，例如业务层、数据访问层）\n\n业务优先，组织结构，质量维度\n\nSRP Single Responsibilty 单一指责原则\nCCP Common Closure Principle 共同闭包原则，包中包含的所有类应该是同类的变化的一个集合，也就是说，如果对包作出修改，需要调整的类应该都在这个包之内。\n\n你的团队成员结构是什么样的，你的架构就会长成啥样。\n\n团队按照业务边界来拆分；确保团队不要太大\n\n因为微服务就是为了减少研发成本，而包括沟通成本。\n\n服务拆分带来的问题\n\n1. 接口调用耗时增加\n2. 如何知道调用哪个服务？服务注册中心\n3. 服务治理体系：熔断、限流、降级、超时控制等\n4. 问题排查困难（分布式链路追踪）\n\n#### 微服务组件\n\n##### API网关\n\n入口网关：隔离客户端与微服务，协议转换、安全策略、认证、限流、熔断等\n\n出口网关：调用外部API，统一认证，授权、授权、访问控制等\n\n性能：IO多路复用、异步非阻塞、线程池\n\n设计要点：性能、扩展性（责任链模式）\n\n隔离性：针对接口对线程池进行分类\n\n##### 服务注册与发现\n\nzookeeper, consul, euraker\n\n##### 负载均衡\n\nRoundRobin, Hash, Weight\n\n##### 熔断、限流\n\n##### 配置实时下发\n\n###### 客户端\n\n配置项的读取-变更推送如何实现：\n\n1. 轮询 + 摘要 （简单，实时性略差）\n2. 长轮询 + 版本号（复杂，实时性好一些）\n\nclient的高性能实现逻辑：\n\n1. DoubleBufferedData， 数据分前台和后台\n2. 读拿到自己所在线程的thread-local读写锁，执行查询逻辑后释放锁。\n3. 同时只有一个写：修改后台数据，切换前后台，挨个获得所有thread-local锁并立刻释放，结束后再改一遍新后台（老前台）。\n\n一个小原则：配置系统的旁路化，不要因为配置系统挂了，你的程序启动不了；\n可以做两层缓存：内存缓存、文件保存\n\n###### 服务端\n\n不同的配置类型：节点类型 》机房类型 》 全局配置\n\n配置项的存储-配置系统的高可用\n\n核心指标在于可用性！！！5个9？\n\n##### 对接调用链追踪 （Jager)\n\ntrace_id + span_id来标识链路的调用关系。\n\n对trace_id采样，而不要随机采样。\n\nspan 基本工作单元，一次链路调用（可以是RPC，DB等没有特定的限制）创建一个span，通过一个64位ID标识它，uuid较为方便，span中还有其他的数据，例如描述信息，时间戳，key-value对的（Annotation）tag信息，**parent_id**(基于parent_span_id来维护树形结构）等,其中parent-id可以表示span调用链路来源。\n\ntrace_id 类似于 树结构的Span集合，表示一次完整的跟踪，从请求到服务器开始，服务器返回response结束，跟踪每次rpc调用的耗时，存在唯一标识trace_id。比如：你运行的分布式大数据存储一次Trace就由你的一次请求组成。\n\nAnnotation 注解，用来记录请求特定事件相关信息（例如时间），一个span中会有多个annotation注解描述。通常包含四个注解信息：\n\n##### 监控系统\n\n![监控哪些内容](http://cdn.b5mang.com/2021320212041.png)\n\n![监控系统架构](http://cdn.b5mang.com/2021320212155.png)\n\n方案：普罗米修斯、Graphna\n\nAPM：端到端的监控体系\n\n如何防止消息被篡改：对消息体 + 消息头 进行加密，生成一个签名\n如何对数据进行加密：\n\n使用非对称加密的公钥对 “对称加密的私钥-OriginPrivate“ 进行加密，得到SecretPrivate\n然后服务端利用非对称加密的私钥，对 SecretPrivate进行解密，得到OriginPrivate\n\n然后再使用OriginPrivate对加密之后的消息体（SecretContext)进行解密，得到Contenxt\n\n监控哪些东西：网络卡顿率、做某件事情的失败率等\n\n考虑暂存 + retry来应对网络状况不佳的情况\n\n##### 自动化全链路压测系统\n\n压测的原则-尽量模拟真实情况；压测的注意点：\n（1）使用线上数据与线上数据\n（2）使用线上流量（流量拷贝）\n（3）流量应该从尽量靠近用户的CDN发起\n\n如何搭建：\n（1）流量的隔离（区分压测流量与正式流量）\n（2）风险控制（尽量避免压测对正常用户的影响）\n\n![自动化全链路压测系统](http://cdn.b5mang.com/2021320214129.png)\n\n压测数据的产生：\n  拷贝真实流量（可以从访问日志、可以抓取某个端口的数据等）\n  打上压测标签\n  放在合适的机房（尽量接近用户）\n数据隔离：\n  针对读请求，针对某些不能压测（例如推荐、数据分析等）的组件进行mock\n  对于写请求，把流量产生的数据写入影子库（数据库-拷贝一份库表和数据；缓存-加压测前缀；ES-多搞一份索引）\n压力测试的实施\n  持续放大，做好系统过载的识别（例如超时率、resp time等）\n","tags":["微服务"]},{"title":"高性能服务器设计-熔断模型","url":"/backend_knowledge_architecture/server/breaker/index.html","content":"\n## 熔断简单说明\n\n在分布式系统中，一次完整的请求可能需要经过多个服务模块的调用，请求在多个服务中传递，服务对服务的调用会产生新的请求，这些请求共同组成了这次请求的调用链。当调用链中的某个环节，特别是下游服务不可用时，将会导致上游服务调用方不可用，最终将这种不可用的影响扩大到整个系统，导致整个分布式的不可用，引起服务雪崩现象。\n\n为了避免这种情况，在下游服务不可用时，保护上游服务的可用性显得极其重要。对此我们可以通过熔断的方式，通过及时熔断服务调用方和服务提供方的调用链，保护服务调用方资源，防止服务雪崩现象的出现。\n\n使用服务熔断，能够有效地保护服务调用方的稳定性，它能够避免服务调用者频繁调用可能失败的服务提供者，防止服务调用者浪费cpu、线程和IO资源等，提高服务整体的可用性。\n\n所以，熔断设计的目的是在服务提供方不可用时保护服务调用方的资源，减少服务调用中无用的远程调用。\n\n## 常见熔断策略\n\n### google SRE 自适应熔断\n\n基于失败率\n\ndrop_ratio = $max(0, （requests - K * accepts） / (requests + 1))$\n\n算法参数：\n\n- requests：窗口时间内的请求总数\n- accepts：正常请求数量\n- K：敏感度，K 越小越容易丢请求，一般推荐 1.5-2 之间\n\n算法解释：\n\n- 正常情况下 requests=accepts，所以概率是 0。\n- 随着正常请求数量减少，当达到 requests == K* accepts 继续请求时，概率 P 会逐渐比 0 大开始按照概率逐渐丢弃一些请求，如果故障严重则丢包会越来越多，假如窗口时间内 accepts==0 则完全熔断。\n- 当应用逐渐恢复正常时，accepts、requests 同时都在增加，但是 K*accepts 会比 requests 增加的更快，所以概率很快就会归 0，关闭熔断。\n\n### brpc熔断策略\n\n在开启了熔断之后，CircuitBreaker会记录每一个请求的处理结果，并维护一个累计出错时长，记为acc_error_cost，当acc_error_cost > max_error_cost时，熔断该节点。\n\n两个小技巧：\n\n1. 利用EMA（移动平均值）策略计算接口的平均响应时间\n2. 利用双时间窗口统计来平衡短期抖动与长期错误率过高；\n\n具体见：\n[CircuitBreaker](https://github.com/apache/incubator-brpc/blob/master/docs/cn/circuit_breaker.md)\n\n### netflix 断路器\n\n![熔断器策略](https://img-blog.csdnimg.cn/20201201181047280.png)\n\n三种断路器状态：关闭、打开、半开\n\n最近一段时间内的错误率 = 错误数 / 总数\n\n最近一段时间内的错误数与总数，通过**滑动窗口**来实现，而滑动窗口又通过**环形队列**来实现。\n\n错误率超过多少，则进入打开状态，持续一段时间。\n\n持续一段时间后，进入半开状态，允许定量的请求通过，如果成功的比例足够大，则进入关闭状态，否则重新加入打开状态。\n","tags":["高性能服务器"]},{"title":"并行算法 - 概览","url":"/backend_knowledge_architecture/parallel/index.html","content":"\n\n并行排序（并行归并排序、并行快速排序）\n\n并行查找（并行的散列表，随机分为K份）\n\n并行字符串匹配（任何算法都可以，只是分割后，需要补上2m个char）\n\n并行搜索（对于BFS，使用两个队列，循环使用）\n"},{"title":"操作系统 - 线程同步","url":"/backend_knowledge_architecture/os/sync.html","content":"\n多线程问题的本质：有序性，可见性，原子性\n\n我们处理线程安全可以有几个层次：\n\n1. 能否做成无状态的不变对象。无状态是最安全的。\n2. 能否线程封闭  \n（1）栈封闭，多采用局部变量\n（2）线程局部存储（用空间换性能）\n（3）程序控制线程封闭（Hash，将同一hash val的的请求丢给同一个线程去处理）\n3. 采用何种同步技术\n\n#### 多线程同步的方式\n\n线程同步\n\n多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就是在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒;\n（在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。）\n\n(1) 信号量 semphore\n\n(2) 共享内存 shared_memory\n\n(3) 读写锁 rw_lock\n\n(4) 条件变量 condition\n\n线程间存在依赖\n\n![条件变量的使用](https://img-blog.csdnimg.cn/img_convert/edb8f67325ff3f693d58f635eeff9650.jpeg)\n\n(5) 互斥量 mutex\n\n#### 互斥锁\n\n对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。\n\n1. 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。\n2. 互斥量：为协调共同对一个共享资源的单独访问而设计的。\n3. 信号量：为控制一个具有有限数量用户资源而设计。\n4. 读写锁\n\n##### 自旋锁\n\n但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。如果等待的时间比较短，适合使用自旋锁，占用大量的CPU资源\n\n#### 锁的实现机制\n\n在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制。\n\n#### 禁中断\n\n既然只有中断才能把上锁过程打断，造成多线程操作失败。我先关中断不就得了，在加锁操作完成后再开中断。\n\n#### 普通的原子指令\n\n上面这个手段太笨重了，能不能硬件做一种加锁的原子操作呢？能，大名鼎鼎的“test and set”指令就是做这个事情的。\n\n##### 锁内存总线 + 原子指令\n\n通过上面的手段，单核环境下，锁的实现问题得到了圆满的解决。\n\n那么多核环境呢？简单嘛，还是“test and set”不就得了，这是一条指令，原子的，不会有问题的。\n\n真的吗，单独一条指令能够保证该指令在单个核上执行过程中不会被中断打断，但是两个核同时执行这个指令呢？。。。\n\n我再想想，硬件执行时还是得从内存中读取lock，判断并设置状态到内存，貌似这个过程也不是那么原子嘛。对，多个核执行确实会存在这个问题。怎么办呢？首先我们得明白这个地方的关键点，关键点是两个核会并行操作内存而且从操作内存这个调度来看“test and set”不是原子的，需要先读内存然后再写内存，如果我们保证这个内存操作是原子的，就能保证锁的正确性了。\n\n确实，硬件提供了锁内存总线的机制，我们在锁内存总线的状态下执行test and set操作，就能保证同时只有一个核来test and set，从而避免了多核下发生的问题。\n\n#### 无锁\n\n1. 无锁算法的底层实现 -- CAS\n2. 借助内存访问WORD的原子性\n\n参考：\n\nhttps://xie.infoq.cn/article/c7045d48ccb28872277445ff8\n\nhttp://jm.taobao.org/2011/12/07/1347/\n\nhttps://blog.csdn.net/heiyeshuwu/article/details/9722443\n\nhttps://www.cnblogs.com/jing99/p/11984966.html\n\nhttps://www.qbitai.com/2019/12/9895.html\nhttps://www.jianshu.com/p/d585b3938dea\n\nhttps://blog.csdn.net/ITer_ZC/article/details/40392787\n","tags":["操作系统"]},{"title":"计算机硬件-CPU高速缓存","url":"/backend_knowledge_architecture/hardware/cpu_cache.html","content":"#### 高速缓存\n\n思想：索引思想、折中思想\n\n- 直接映射ByHash\n\n主存中的一个块只能映射到Cache的某一特定块中去。例如，主存的第0块、第16块、……、第2032块，只能映射到Cache的第0块；而主存的第1块、第17块、……、第2033块，只能映射到Cache的第1块……\n\n![直接映射](https://static.oschina.net/uploads/img/201803/07163540_dO4M.gif)\n\n直接映射是最简单的地址映射方式，它的硬件简单，成本低，地址变换速度快，而且不涉及替换算法问题。\n\n但是这种方式不够灵活，Cache的存储空间得不到充分利用，每个主存块只有一个固定位置可存放，容易产生冲突，使Cache效率下降，\n\n因此只适合大容量Cache采用。\n\n例如，如果一个程序需要重复引用主存中第0块与第16块，最好将主存第0块与第16块同时复制到Cache中，但由于它们都只能复制到Cache的第0块中去，即使Cache中别的存储空间空着也不能占用，因此这两个块会不断地交替装入Cache中，导致命中率降低\n\n- 全相连映射ByAll\n\n图3-15 是全相联映射的Cache组织，主存中任何一块都可以映射到Cache中的任何一块位置上\n\n![全相连映射](https://static.oschina.net/uploads/img/201803/07163541_oEp6.gif)\n\n全相联映射方式比较灵活，主存的各块可以映射到Cache的任一块中，Cache的利用率高，块冲突概率低，只要淘汰Cache中的某一块，即可调入主存的任一块。\n\n但是，由于Cache比较电路的设计和实现比较困难，这种方式只适合于小容量Cache采用。\n\n- 组相连映射ByGroup\n\n组间直接相连，组内全相连\n\n 组相联映射实际上是直接映射和全相联映射的折中方案，其组织结构如图3-16所示。主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射。也就是说，将Cache分成u组，每组v块，主存块存放到哪个组是固定的，至于存到该组哪一块则是灵活的。例如，主存分为256组，每组8块，Cache分为8组，每组2块。\n\n ![组相连映射](https://static.oschina.net/uploads/img/201803/07163541_YspG.gif)\n\n主存中的各块与Cache的组号之间有固定的映射关系，但可自由映射到对应Cache组中的任何一块。例如，主存中的第0块、第8块……均映射于Cache的第0组，但可映射到Cache第0组中的第0块或第1块；主存的第1块、第9块……均映射于Cache的第1组，但可映射到Cache第1组中的第2块或第3块。\n\n常采用的组相联结构Cache，每组内有2、4、8、16块，称为2路、4路、8路、16路组相联Cache。\n\n组相联结构Cache是前两种方法的折中方案，适度兼顾二者的优点，尽量避免二者的缺点，因而得到普遍采用。\n\n具体参考：https://blog.csdn.net/weixin_34319111/article/details/92562285\n\n#### 一致性协议\n\nMESI 缓存一致性协议\n\nModified、Exclusive、Shared、Invalid\n","tags":["计算机硬件"]},{"title":"操作系统系列｜虚拟内存","url":"/backend_knowledge_architecture/os/vm_mem.html","content":"\n![虚拟地址转换为物理地址的本质](https://pics7.baidu.com/feed/95eef01f3a292df5ed263835cecf2b6835a8732b.png?token=d3599f2975744c1d572bd6e62b2daf04)\n\n我们知道linux采用了分页机制，通常采用四级页表，页全局目录(PGD)，页上级目录(PUD)，页中间目录(PMD)，页表(PTE)。如下：\n\n![虚拟地址转换为物理地址硬件过程](https://pics2.baidu.com/feed/728da9773912b31b18d3813af7e64172dbb4e169.png?token=c455dcb1766f6df26c45bc14d987b355)\n\n1. 从CR3寄存器中读取页目录所在物理页面的基址(即所谓的页目录基址)，从线性地址的第一部分获取页目录项的索引，两者相加得到页目录项的物理地址。\n2. 第一次读取内存得到pgd_t结构的目录项，从中取出物理页基址取出，即页上级页目录的物理基地址。\n3. 从线性地址的第二部分中取出页上级目录项的索引，与页上级目录基地址相加得到页上级目录项的物理地址。\n4. 第二次读取内存得到pud_t结构的目录项，从中取出页中间目录的物理基地址。\n5. 从线性地址的第三部分中取出页中间目录项的索引，与页中间目录基址相加得到页中间目录项的物理地址。\n6. 第三次读取内存得到pmd_t结构的目录项，从中取出页表的物理基地址。\n7. 从线性地址的第四部分中取出页表项的索引，与页表基址相加得到页表项的物理地址。\n8. 第四次读取内存得到pte_t结构的目录项，从中取出物理页的基地址。\n9. 从线性地址的第五部分中取出物理页内偏移量，与物理页基址相加得到最终的物理地址。\n10. 第五次读取内存得到最终要访问的数据。\n\n整个过程是比较机械的，每次转换先获取物理页基地址，再从线性地址中获取索引，合成物理地址后再访问内存。不管是页表还是要访问的数据都是以页为单位存放在主存中的，因此每次访问内存时都要先获得基址，再通过索引(或偏移)在页内访问数据，因此可以将线性地址看作是若干个索引的集合。\n\n### 虚拟内存管理\n\n#### Linux通过红黑树管理\n\n```cpp\nstruct task_struct {\n\n    struct mm_struct *mm;\n\n}\n\nstruct vm_area_struct {\n    struct mm_struct * vm_mm;    /* 所属的内存描述符 */\n    unsigned long vm_start;    /* vma的起始地址 */\n    unsigned long vm_end;        /* vma的结束地址 */\n \n    /* 该vma的在一个进程的vma链表中的前驱vma和后驱vma指针，链表中的vma都是按地址来排序的*/\n    struct vm_area_struct *vm_next, *vm_prev;\n \n    pgprot_t vm_page_prot;        /* vma的访问权限 */\n    unsigned long vm_flags;    /* 标识集 */\n \n    struct rb_node vm_rb;      /* 红黑树中对应的节点 */\n}\n```\n\n该结构体是一段虚拟内存，从vm_start到vm_end，他们拥有相同的权限；\nvm_prev 、vm_next 是双向链表的next与pre；\nvm_rb 是红黑树节点\n\n```cpp\nstruct mm_struct {\n        struct vm_area_struct * mmap;       /* list of VMAs */\n        struct rb_root mm_rb;/*又是红黑树的根节点*/\n        struct vm_area_struct * mmap_cache;      /* last find_vma result */\n}\n```\n\nmmap是双向链表；按照地址大小来顺序管理所有的area\n\nmm_rb是红黑树的根节点\n\n红黑树的Key-Value: 虚拟地址 => 对应的area.\n","tags":["操作系统"]},{"title":"操作系统 - PageCache","url":"/backend_knowledge_architecture/os/page_cache.html","content":"\n![linux-io](https://img-blog.csdnimg.cn/img_convert/af14c365336b91762e0818c657b29b2f.png)\n\nPage Cache 用于缓存文件的页数据，\n\nbuffer cache 用于缓存块设备（如磁盘）的块数据。\n\n页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；\n\n块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。\n\n---\n\nPage Cache 与 buffer cache 的共同目的都是加速数据 I/O\n\n写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；\n\n读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。\n\n操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。\n\n---\n\n在 Linux 2.4 版本的内核之前，Page Cache 与 buffer cache 是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。\n\n所以在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了。\n\n只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到 buffer cache 里。\n\n因此，我们现在提起 Page Cache，基本上都同时指 Page Cache 和 buffer cache 两者，本文之后也不再区分，直接统称为 Page Cache。\n\n下图近似地示出 32-bit Linux 系统中可能的一种 Page Cache 结构，其中 block size 大小为 1KB，page size 大小为 4KB。\n\n![page_cache_and_buffer_cache](https://img-blog.csdnimg.cn/img_convert/38d0c14994613a0342e0158ec82d04eb.png)\n\nPage Cache 中的每个文件都是一棵**基数树**（radix tree，本质上是Trie、多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。\n\n![page_cache_radix_tree](https://img-blog.csdnimg.cn/img_convert/a4763bd4d3d093dc7fee3da90247ba5d.png)","tags":["缓存","操作系统","数据结构"]},{"title":"操作系统 - 物理内存管理","url":"/backend_knowledge_architecture/os/physical_mem.html","content":"\n![内存访问](https://pics3.baidu.com/feed/838ba61ea8d3fd1f0c5a12495ab0521794ca5f7c.jpeg?token=dd0db40934355dcfa5bc35bec53f8b4d)\n\nTLB：MMU工作的过程就是查询页表的过程。如果把页表放在内存中查询的时候开销太大，因此为了提高查找效率，专门用一小片访问更快的区域存放地址转换条目。（当页表内容有变化的时候，需要清除TLB，以防止地址映射出错。）\n\nCaches：cpu和内存之间的缓存机制，用于提高访问速率，armv8架构的话上图的caches其实是L2 Cache\n\n### 内存命中率\n\n假设在 n 次内存访问中，出现命中的次数是 m，那么 m / n * 100% 就表示命中率，这是衡量内存管理程序好坏的一个很重要的指标。\n\n如果物理内存不足了，数据会在主存和磁盘之间频繁交换，命中率很低，性能出现急剧下降，我们称这种现象叫**内存颠簸**。这时你会发现系统的 swap 空间利用率开始增高， CPU 利用率中 iowait 占比开始增高。\n\n大多数情况下，只要物理内存够用，页命中率不会非常低，不会出现内存颠簸的情况。因为大多数程序都有一个特点，就是**局部性**。\n\n局部性就是说被引用过一次的存储器位置，很可能在后续再被引用多次；而且在该位置附近的其他位置，也很可能会在后续一段时间内被引用。\n\n### 物理内存管理\n\n![物理内存管理](https://pics7.baidu.com/feed/6609c93d70cf3bc7b0d84842bbfecda9cf112a4e.png?token=4f2dc6e2a73bddf5becd6dd924ebbded)\n\n![Buddy系统](https://pics4.baidu.com/feed/962bd40735fae6cd484f59cc7d4d782c40a70fae.png?token=4296ed176d75fde417a7b04612fe8246)\n\n对于Page级别的内存分配，通过Buddy系统来管理；TCMalloc 也是通过这种方式来管理span。\n\n对于小对象（例如task_struct、mm_struct等）通过SlabAllcator来进行管理分配。这种思路，Memcache会借鉴。\n","tags":["操作系统"]},{"title":"操作系统 - 进程与线程","url":"/backend_knowledge_architecture/os/process_thread.html","content":"### 进程与线程\n\n* 进程线程的区别\n\n线程独享：线程局部存储TLS、errno、寄存器、栈空间\n\n* 进程间通信方式\n\n* 线程的状态\n\n* 介绍死锁和如何避免\n\n线程安全\n\n（1）synchronized 方法 + 代码块\n\n（2）互斥锁lock\n\n（3） 线程局部存储\n\n（4）乐观锁\n\n\n\n### 进程调度算法\n\n多级反馈队列调度算法\n\n### 分离thread\n\n非分离线程在终止后，必须要有一个线程用 join 来等待它。否则，不会释放该线程的资源以供新线程使用，而这通常会导致内存泄漏。因此，如果不希望线程被等待，请将该线程作为分离线程来创建。","tags":["操作系统"]},{"title":"操作系统中碰到的数据结构汇总","url":"/backend_knowledge_architecture/os/os_structure.html","content":"\n#### hash\n\nhlist_head hlist_node 散列表拉链\n\n根据PID定位task：PID哈希表\n\n#### 双向链表\n\nlist_head 双向链表\n\n提高调度程序运行速度：建立多个可运行程序链表\n\n等待队列（双向链表）：用自旋锁加保护的等待队列头、等待队列链表的元素\n\n等待队列中睡眠进程的唤醒：互斥进程，非互斥进程\n\n链表维护节点；节点包括管理区【硬件限制，ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM】+ page数组\n\n动态定时器的链表组（将同一时间段内即将到时的定时器归入一组）\n\n#### bitmap\n\npid分配管理：bitmap pidmap_array\n\ninode、磁盘文件数据块\n\n#### 并发与同步\n\n##### 每CPU变量\n\n不需要同步的内核数组，为每个cpu分配数组一元素\n\n##### 自旋锁\n\n##### RCU机制\n\nRCU(读取-拷贝-更新)：只保护被动态分配并通过指针引用的数据结构\n\n何时释放旧副本？ CPU经过静止状态后，定期检测！！\n\n#### 原子变量\n\n#### 其他\n\nthread 与 thread_info 紧密挨着；根据esp 屏蔽 低13位 可以最快的获取thread_info;\n同时进程描述符指针在thread_info中的偏移为0!\n\n也就是将： OS将task_struct指针存放到了栈上（可以通过esp做简单的AND操作即可）\n\njiffies:子系统启动的节拍总数\n","tags":["操作系统","数据结构"]},{"title":"操作系统 - 概览","url":"/backend_knowledge_architecture/os/index.html","content":"\n#### 操作系统智慧\n\n懒人哲学：越简单、越傻瓜、用户使用的学习成本越低越好\n\n让困于人：当我们遇到困难时，搞不定的或者我们自己搞成本很大的，交给别人来搞(一般让操作系统来搞，其实操作系统也是别人完成的软件系统)\n\n留有余地: 可扩展性，让系统有可扩展性\n\n足够智能：一个系统最好能解决所有的问题，跟人的感觉是一个万能的解决方案，也就是操作系统的魔术师的角色\n\n时空转换：在一个纬度遇到的瓶颈，那就改变方案把瓶颈移到另外一个纬度 【内存页表太大，占用内存资源；那就页表分级，不活跃的放到磁盘】\n\n策机分离和权利分离：一个系统或者平台在主要指定规则、提供通用化的插件即可\n\n简单与美：苛求于简，归于永恒\n","tags":["操作系统"]},{"title":"计算机网络 - HTTP协议","url":"/backend_knowledge_architecture/network/http.html","content":"\n![HTTP对比](https://pic.rmb.bdstatic.com/bjh/news/6722dbdf63eabaa62b59486f2c51df6e.png)\n\n### HTTP1.0\n\n301: 永久重定向\n302: 临时重定向\n\n！默认关闭！\n在HTTP 1.0中，服务器始终在发送响应后关闭连接， 除非客户端发送了Connection: keep-alive请求标头，并且服务器发送了一个Connection: keep-alive响应标头。 如果不存在这样的响应报头，则客户端在收到响应后必须关闭连接的结束。  \n\n！默认打开！\n在HTTP 1.1中，服务器在发送响应之后不关闭连接， 除非客户端发送了Connection: close请求标头，或者服务器发送了Connection: close响应标头。 如果存在这样的响应头，则客户端在收到响应后必须关闭连接的结束。\n\n### HTTPS\n\n可以参考：https://blog.csdn.net/xiaoming100001/article/details/81109617\n\n对称加密与非对称加密相结合\n\n通信内容，通过对称加密算法来加解密；其中有一个重要的东西叫：密钥\n\n**密钥**是通过**非对称加密**算法来加密传输，客户端使用服务器的public key来加密，服务端通过自己的private key来解密。\n\n服务器的public key，浏览器如何得知呢？ **通过SSL证书**。\n\nSSL证书组织是一个树形组织，最上面的几层是hardcode在系统中的。\n\n当需要验证证书有效性时，浏览器会通过根认证组织逐层认证！\n\n### HTTP2.0\n\n服务器推送、头信息压缩、等\n\n#### 二进制分帧\n\n先来理解几个概念：\n\n帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。\n\n流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。\n\nHTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。\n\nHTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\n\n#### 多路复用\n\n在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：\n\n同域名下所有通信都在单个连接上完成。\n单个连接可以承载任意数量的双向数据流。\n数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\n#### 服务器推送\n\n服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\n\n服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\n\n#### 头部压缩\n\nHTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。\n\n为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：\n\nHTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；\n\n首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n\n每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n### HTTP3.0\n\n![HTTP23对比](https://s3.51cto.com/images/blog/202107/01/2d9b80a4cd6fadcf1e08fee31669d61a.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\nQUIC（Quick UDP Internet Connections）基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议\n\n参考：https://blog.51cto.com/u_6315133/3122045","tags":["计算机网络"]},{"title":"计算机硬件-数字的表示","url":"/backend_knowledge_architecture/hardware/number.html","content":"## 负数\n\n负数用补码来表示，补码等于数的反码 + 1\n\n## 浮点数\n\n两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数\n\n双精度浮点数类型用64位:符号位（1位） + 阶码（11位） + 尾数（52位）\n\n单精度浮点数类型用32位:符号位（1位） + 阶码（8位） + 尾数（23位）\n\n符号位：正数为0，负数为1；\n\n指数位：**阶数+偏移量**，阶数是2^(e-1)-1，e为阶码的位数，也就是指数位的位数。偏移量是把小数点移动到整数位只有1时移动的位数，正数表示向左移，负数表示向右移；\n\n小数位：即二进制小数点后面的数。\n\n### 一个例子\n\n把0.1(10)转成的二进制0.00011 0011 0011 ...(2)转成浮点数形式的二进制：\n\n（能够**精确表示**的小数为：0.5，0.25，0.125...等的自由组合）\n\n转化过程见：https://cloud.tencent.com/developer/article/1856972\n\n1、先要把小数点移动到整数位只有1，要向右移动4位，故偏移量为-4，通过指数位的计算公式2^(e-1)-1+偏移量 = 2^(11-1)-1-4 = 1019，把1019转成二进制为1111111011，不够11位要补零，最终得出指数位位01111111011；\n\n2、移位后的小数位为.1 0011 0011 ...，因为小数位只能保留52位，第50、51、52位、53位分别为0011，故对第52位进1使第51位为1，使第50、51、52位为010。\n\n注意：此处的**精度丢失**问题，有很多小数（例如本例中的0.1）在转二进制时会出现无限循环的情况，所以在位数有限的境况下，肯定需要舍弃后面的精度。这一点，就与1/3这种小数是在十进制下无限循环类似。\n\n## 定点数\n\n只能表示纯小数，例如0.999991212\n","tags":["计算机硬件"]},{"title":"计算机硬件-TLB","url":"/backend_knowledge_architecture/hardware/tlb.html","content":"\nTLB（Translation Lookaside Buffer）是一块高速缓存。\n\nTLB缓存虚拟地址和其映射的物理地址。\n\n数据cache缓存地址(虚拟地址或者物理地址)和数据。\n\n参考：https://zhuanlan.zhihu.com/p/108425561\n","tags":["计算机硬件"]},{"title":"分布式文件系统","url":"/backend_knowledge_architecture/distributed_system/fs.html","content":"\n存储的分布式化\n\n高效存储的一些考虑：\n\n1. 很长时间没有人访问的老数据，怎么办？\n2. 是不是减少副本的同时，还能还原出数据？（例如，RAID）\n3. 数据压缩，平成好压缩效果与压缩/解压速度\n4. 数据的分层存储：根据数据的冷热来选择不同的存储介质（局部性原理），内存、硬盘（SSD、SATA)\n5. 存储与计算分离（底层基础：网络IO不再是瓶颈，而CPU性能、磁盘IO性能跟不上）\n\n#### 分布式存储引擎\n\n主要解决数据如何拆分、数据如何冗余、数据如何定位的问题。\n\n（1）parititioning 方式，即数据在逻辑上怎么切分\n\n（2）localization 方式，即数据在物理上怎么分布\n\n一个系统要想拥有高可用性，有且只有一个办法 -- 副本（replication），因为物理故障是无法避免的，只能花钱做备份。\n\n主从和时效性是 replication 要考虑的两个重要问题。\n\n主从主要有单主、多主和无主三种方式。\n\n时效性主要有同步、异步、半同步三种方式。\n\n（3）rebalance 方式，即在节点数变化后，数据在物理上怎么重新分布.\n\n#### 分布式文件系统\n\n按照Block拆分文件，然后通过一个管理员来管理Block到对应及其的映射关系。\n\n新的问题：\n如果存储block的机器挂了怎么办？ 如果管理员挂了怎么办？\n\n参考：https://zhuanlan.zhihu.com/p/141775358","tags":["分布式系统"]},{"title":"分布式系统-一致性","url":"/backend_knowledge_architecture/distributed_system/high_consistency.html","content":"\n#### CAP VS BASE\n\n#### 一致性\n\n##### 强一致性\n\n保证手段：单机落磁盘、数据库事务、分布式事务等\n\n##### 弱一致性\n\n可能丢失一定的数据：异步复制、PageCache的write back\n\n##### 最终一致性\n\n带TTL的缓存\n","tags":["分布式系统"]},{"title":"分布式系统介绍","url":"/backend_knowledge_architecture/distributed_system/index.html","content":"\n### 为什么会有分布式\n\n两点：算得慢（算力不足），存不下（数据分散）。\n\n无论是线程、进程，还是协程，本质上，目的都是为了计算的并行化，解决的是算的慢的问题。\n\n因为一个CPU算不过来，而单机扩容CPU数量成本极高（有空间这个刚性限制），所以需要水平扩容，多搞几台机器。\n\n计算的分布式化：基于分治思想，出现了分布式框架。\n\nMapReduce: 分布式计算的总体思想。\n\n分布式计算框架更多尝试对资源的调度做优化。ResourceManager, yarn, k8s;\n（多租户，隔离，软隔离，租借，抢占等）\n\n### 高并发系统的三个目标与挑战\n\n高并发是一个系统的**挑战**\n\n如何衡量一个系统的并发有多高呢？ 同时在线人数\n\n高性能、高可用、可扩展是一个牛B系统**目标**\n\n#### 三者的关系\n\n为了保证高可用，需要冗余更多的相同功能机器（replication)，要求系统可扩展；\n\n为了保证高性能，必须需要更多的相同功能的机器（存储的replication、应用的无状态）或者服务于不同对象的机器（shard)，也要求可扩展；\n\n一份完整的数据，分为多个shard的过程需要可扩展；\n\n一份数据冗余了多份，前端对下游访问时用到的负载均衡策略需要可扩展。\n\n#### 如何衡量一个吞吐量有多大呢？\n\n系统的QPS，吞吐量 = 并发进程数 / 响应时间\n\n#### 如何衡量一个系统的性能有多高呢？\n\n一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：\n\n- 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？（接口响应时间，分位耗时）\n- 增加负载参数并希望保持性能不变时，需要增加多少系统资源？\n\n\n#### 如何衡量一个系统的可用性有多高呢？  \n\n平均故障间隔，平均故障恢复时间\n\n![不同可用性标准下允许的故障时间](http://cdn.b5mang.com/202132011926.png)\n\n#### 如何衡量一个系统的可扩展能力？\n\n考察一个问题：能够通过增加进程来应对更高的并发？ 如果一直加机器，我一直能线性的提高系统的处理能力吗？\n\n### 如何应对系统的挑战\n\n架构通用原则：“4 要 1 不要”\n\n(1) 数据要尽量少\n\n- 用户请求的数据能少就少\n- 系统依赖的数据能少就少\n\n(2) 请求数要尽量少\n\n例如，静态文件合并\n\n（3）路径要尽量短\n\n将强依赖的服务进行单机部署\n\n（4）依赖要尽量少\n\n系统服务分级，高等级服务尽量少依赖低等级服务\n\n（5）不要有单点\n\n服务无状态，可扩展；存储层做副本备份\n\n![主流系统架构](https://vonng.gitbooks.io/ddia-cn/content/img/fig1-1.png)\n","tags":["分布式系统"]},{"title":"设计模式-概览","url":"/backend_knowledge_architecture/design_pattern/index.html","content":"\n软件设计模式的几种分类\n\n#### 创建型\n\n创建对象时，不再由我们直接实例化对象；而是根据特定场景，由程序来确定创建对象的方式，从而保证更大的性能、更好的架构优势。\n\n创建型模式主要有：\n\n##### 简单工厂模式\n\n##### 工厂方法\n\n意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n\n主要解决：主要解决接口选择的问题。\n\n何时使用：我们明确地计划不同条件下创建不同实例时。\n\n如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n\n关键代码：创建过程在其子类执行。\n\n应用实例：\n 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 \n 2、Hibernate 换数据库只需换方言和驱动就可以。\n\n优点： \n1、一个调用者想创建一个对象，只要知道其名称就可以了。 \n2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 \n3、屏蔽产品的具体实现，调用者只关心产品的接口。\n\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n使用场景： \n1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 \n2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 \n3、设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。\n\n注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n##### 抽象工厂模式\n\n就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。\n\n意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n主要解决：主要解决接口选择的问题。\n\n何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。\n\n如何解决：在一个产品族里面，定义多个产品。\n\n关键代码：在一个工厂里聚合多个同类产品。\n\n应用实例：\n\n优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n\n缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。\n\n使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。\n\n注意事项：产品族难扩展，产品等级易扩展。\n\n##### 单例模式\n\n全局资源管理，简化访问。\n\n意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n主要解决：一个全局使用的类频繁地创建与销毁。\n\n何时使用：当您想控制实例数目，节省系统资源的时候。\n\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n关键代码：构造函数是私有的。\n\n应用实例：\n\n1、一个班级只有一个班主任。\n2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n\n优点：\n1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n2、避免对资源的多重占用（比如写文件操作）。\n\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n使用场景：\n\n1、要求生产唯一序列号。\n2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n##### 建造者模式\n\n意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n主要解决：主要解决在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n\n何时使用：一些基本部件不会变，而其组合经常变化的时候。\n\n如何解决：将变与不变分离开。\n\n关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\n\n应用实例： \n1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"。 \n2、JAVA 中的 StringBuilder。\n\n优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\n\n缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\n\n使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\n\n一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。\n\n\n注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序\n\n##### 原型模式\n\n意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n\n主要解决：在运行期建立和删除原型。\n\n何时使用： \n1、当一个系统应该独立于它的产品创建，构成和表示时。 \n2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 \n3、为了避免创建一个与产品类层次平行的工厂类层次时。 \n4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n\n如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。\n\n关键代码：\n 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 \n2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\"易变类\"拥有稳定的接口。\n\n应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。\n\n优点： 1、性能提高。 2、逃避构造函数的约束。\n\n缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。\n\n使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。\n\n注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n\n#### 结构型\n\n用于帮助将多个对象组织成更大的结构。\n\n结构型模式主要有：\n\n##### 适配器模式adapter\n\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n\n意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n主要解决：主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。\n\n何时使用： \n1、系统需要使用现有的类，而此类的接口不符合系统的需要。 \n2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 \n3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）\n\n如何解决：继承或依赖（推荐）。\n\n关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。\n\n应用实例： \n1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 \n2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。\n3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。\n\n优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n\n缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n\n使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n\n注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n##### 桥接模式bridge\n\n意图：将抽象部分与实现部分分离，使它们都可以独立的变化。\n\n主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n\n何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。\n\n如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\n\n关键代码：抽象类依赖实现类。\n\n应用实例： \n\n1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 \n\n2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\n\n优点： \n\n1、抽象和实现的分离。 \n2、优秀的扩展能力。 \n3、实现细节对客户透明。\n\n缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\n\n使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n\n注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。\n\n##### 组合器模式component\n\n意图：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n\n何时使用： \n\n1、您想表示对象的部分-整体层次结构（树形结构）。 \n2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n\n如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。\n\n关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。\n\n应用实例： \n1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 \n2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。\n\n优点： \n\n1、高层模块调用简单。 2、节点自由增加。\n\n缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n\n使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。\n\n注意事项：定义时为具体类。\n\n##### 外观门面模式Facade\n\n意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。\n\n何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。 2、定义系统的入口。\n\n如何解决：客户端不与系统耦合，外观类与系统耦合。\n\n关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n\n应用实例： \n\n1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 \n2、JAVA 的三层开发模式。\n\n优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。\n\n缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。\n\n使用场景： \n1、为复杂的模块或子系统提供外界访问的模块。 \n2、子系统相对独立。 3、预防低水平人员带来的风险。\n\n注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n\n##### 亨元模式flyweight\n\n意图：运用共享技术有效地支持大量细粒度的对象。\n\n主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。\n\n何时使用： \n\n1、系统中有大量对象。 \n2、这些对象消耗大量内存。 \n3、这些对象的状态大部分可以外部化。 \n4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 \n5、系统不依赖于这些对象身份，这些对象是不可分辨的。\n\n如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。\n\n关键代码：用 HashMap 存储这些对象。\n\n应用实例： \n1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 \n2、数据库的数据池。\n\n优点：大大减少对象的创建，降低系统的内存，使效率提高。\n\n缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。\n\n使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。\n\n注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。\n\n##### 装饰器模式decorator\n\n对已有的业务逻辑进一步的封装，使其增加额外的功能，如java中的**IO流**就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。\n\n##### 代理模式proxy\n\n代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。\n\n优点：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。\n\n缺点：\n\n由于使用了代理模式，因此程序的性能没有直接调用性能高；使用代理模式提高了代码的复杂度。\n\n举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。\n\n#### 行为型\n\n用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。\n\n行为型模式主要有：\n\n##### 解释器模式\n\n用的比较少，可能出现的地方：**语法解析**\n\n##### 中介者模式\n\n作用：\n通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。\n\n本质：\n\nComponentA,ComponentB,ComponentC 都拥有一个Mediator（拥有一个方法notify)\n\n当某一个Component执行某一个操作的时候, 除了做完自己的事情，还需要Mediator::Notify\n\nMediator有一个具体的子类叫：ConcreteMediator，他拥有所有的Component，并overwrite了Notify接口\n\n##### 命令模式command\n\n命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。\n\n应用场景：将命令者与执行者完全解耦。\n\nJava中的Runnable就是命令模式\n\n##### 迭代器模式\n\nSTL::iterator\n\n##### 备忘录模式\n\nOriginator 发起者；\nCareTaker 备忘录管理者，管理所有的备忘录快照\nMemoto 备忘录，有getState, setState两个方法\n\n一个游戏，玩一会儿，自动存档，再玩一会，自动存档。就可以考虑用备忘录模式\n\n##### 观察者模式\n\n发布订阅模式\n\n对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。Android中的**各种Listener**就使用到了这一设计模式，只要用户对手机进行操作，对应的listener就会被通知，并作出响应的处理。\n\n##### 状态模式state\n\n状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。\n\n应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。\n\ncontext 使用 State\n\nconcreteStateA，B，C继承自State\n\nconcreteStateA 可以在实现时切换状态到B\n\n##### 模板模式\n\n模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。\n\n让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。\n\n做一件事情需要1，2，3三步，父类提供了基本实现，子类也可以选择overwrite。\n\n##### 策略模式\n\n答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。\n\n优点：遵循了开闭原则，扩展性良好。\n\n缺点：随着策略的增加，对外暴露越来越多。\n\n策略模式则是以接口形式提供抽象接口。由具体实现类提供不同算法。\n\n策略模式一般由3部分组成\n\n- 一个Context持有所有策略实现类引用，提供给客户端运行\n- 一个策略接口提供\n- 具体的策略实现类\n\n通过上面可以看到，策略模式和模板模式有一个最重要的区别，即模板模式一般只针对一套算法，注重对**同一个算法的不同细节进行抽象提供不同的实现**。而策略模式注重多套算法多套实现，在算法中间不应该有交集，因此算法和算法只间一般不会有冗余代码！因为不同算法之间的实现一般不同很相近。\n\n因此我们可以看到，策略模式的关注点更广，模板模式的关注点更深。而且两种模式可以一起使用，即具体某个策略下可以通过模板减少不同步骤的冗余代码。\n\n例如：限流是服务器要实现的功能，但是实现策略有基于滑动窗口的限流策略、基于令牌桶的限流策略等。\n\n#####  访问者模式\n\n用途：文件遍历\njava.nio.file.FileVisitor接口\n类功能：一个用于访问文件的接口。这一接口的实现类通过Files.walkFileTree方法实现对文件树中每一个文件的访问。\npublic static Path walkFileTree(Path start,Set options,\nint maxDepth,FileVisitor< super Path> visitor) ，这一方法中回调了visitor的方法。\n方法实现上：访问者对每一个被访问者都有一个实现方法。每一个被访问者都有一个通用方法，输入参数为访问者，此方法用于调用访问者的方法。\n\n##### 责任链 \n\nwebserver的filter\n\n通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。\n\n参考：\n\nhttps://blog.csdn.net/sinat_34166518/article/details/89206059\n\n\n\n","tags":["设计模式"]},{"title":"分布式系统-可用性","url":"/backend_knowledge_architecture/distributed_system/high_availability.html","content":"\n系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。\n\nplan挂了之后，系统能不能活下来？ 有没有负责兜底的PlanB。\n\n造成错误的原因叫做故障（fault），能预料并应对故障的系统特性可称为容错（fault-tolerant）或韧性（resilient）。\n\n注意故障（fault）不同于失效（failure）【2】。故障通常定义为系统的**一部分**状态偏离其标准，而失效则是系统作为一个**整体**停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。\n\n## 影响可用性的因素\n\n首先我们先梳理一下影响系统稳定性的一些常见的问题场景，大致可分为三类：\n\n### 人为因素\n\n不合理的变更、外部攻击等等\n\n### 软件因素\n\n代码bug、设计漏洞、GC问题、线程池异常、上下游异常\n\n### 硬件因素\n\n网络故障、机器故障等\n\n### 可用性速降到最低的表现-雪崩\n\n两个导火索：\n\n- 下游或者本身机器故障导致latency增加\n- 上游请求qps变高\n\n实际的并发超过了最大能支持的并发（当下游变慢后，该值迅速会下降），过载就发生了。过载不可怕，如果上游不重试，系统终将恢复。\n\n## 如何提高可用性\n\n### 系统拆分\n\n拆分不是以减少不可用时间为目的，而是以减少故障影响面为目的。\n\n因为一个大的系统拆分成了几个小的独立模块，一个模块（大概率是变更导致，例如升级代码）出了问题不会影响到其他的模块，从而降低故障的影响面。\n\n系统拆分又包括接入层拆分、服务拆分、数据库拆分。\n\n#### 接入层&服务层\n\n【轻重分离】\n一般是按照业务模块、重要程度、变更频次等维度拆分。\n\n#### 数据层\n\n【轻重分离】、【冷热分离】、【读写分离】\n一般先按照业务拆分后，如果有需要还可以做垂直拆分也就是数据分片、读写分离、数据冷热分离等。\n\n把核心库与非核心库分机器部署，避免相互影响。\n\n### 解耦\n\n系统进行拆分之后，会分成多个模块。模块之间的依赖有强弱之分。\n\n如果是强依赖的，那么如果依赖方出问题了，也会受到牵连出问题，强依赖需要基于被依赖放的SLA做好超时熔断配置以及本服务自身的容量预估。\n\n这时可以梳理整个流程的调用关系，做成弱依赖调用。\n\n弱依赖调用可以用MQ的方式来实现解耦。即使下游出现问题，也不会影响当前模块。\n\n### 技术选型\n\n可以在适用性、优缺点、产品口碑、社区活跃度、实战案例、扩展性等多个方面进行全量评估，挑选出**适合当前业务场景的中间件&数据库**。\n\n前期的调研一定要充分，先对比、测试、研究，再决定，磨刀不误砍柴工。\n\n### 冗余部署&故障自动转移\n\n服务层的冗余部署很好理解，一个服务部署多个节点，有了冗余之后还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务时间。\n\n所以，又往往是通过“自动故障转移”来实现系统的高可用。即某个节点宕机后需要能自动摘除上游流量，这些能力基本上都可以通过**负载均衡的探活机制**来实现。\n\n涉及到数据层就比较复杂了，但是一般都有成熟的方案可以做参考。\n\n一般分为一主一从、一主多从、多主多从。不过大致的原理都是数据同步实现多从，数据分片实现多主，故障转移时都是通过选举算法选出新的主节点后在对外提供服务（这里如果写入的时候不做强一致同步，故障转移时会丢失一部分数据）。具体可以参考Redis Cluster、ZK、Kafka等集群架构。\n\n### 容量评估\n\n1. 每个系统，自己的最大处理能力是多少要做到清清楚楚。\n\n在系统上线前需要对整个服务用到的机器、DB、cache都要做容量评估，机器容量的容量可以采用以下方式评估：\n\n1. 明确预期流量指标-QPS；\n2. 明确可接受的时延和安全水位指标（比如CPU%≤40%，核心链路RT≤50ms）；\n\n通过压测评估单机在安全水位以下能支持的最高QPS（建议通过混合场景来验证，比如按照预估流量配比同时压测多个核心接口）；\n\n最后就可以估算出具体的机器数量了。\n\nDB和cache评估除了QPS之外还需要评估数据量，方法大致相同，等到系统上线后就可以根据监控指标做扩缩容了。\n\n### 服务快速扩容能力&泄洪能力\n\n现阶段不论是容器还是ECS，单纯的节点复制扩容是很容易的，扩容的重点需要评估的是服务本身是不是无状态的，比如：\n\n1. 下游DB的连接数最多支持当前服务扩容几台？\n\n2. 扩容后缓存是否需要预热？\n\n3. 放量策略\n\n这些因素都是需要提前做好准备，整理出完备的SOP文档，当然最好的方式是进行演练，实际上手操作，有备无患。\n\n**泄洪能力**一般是指冗余部署的情况下，选择几个节点作为备用节点，平时承担很小一部分流量，当流量洪峰来临时，通过调整流量路由策略把热节点的一部分流量转移到备用节点上。\n\n对比扩容方案这种成本相对较高，但是好处就是响应快，风险小。\n\n### 限流&熔断降级\n\n![限流](http://images.elecfans.top/uploads/20221109/491f36c6-6037-11ed-8abf-dac502259ad0.png)\n\n对于用户的重试行为，要适当的延缓。例如登录发现后端响应失败，再重新展现登录页面前，可以适当延时几秒钟，并展现进度条等友好界面。当多次重试还失败的情况下，要安抚用户。\n\n过载保护很重要的一点，不是说要加强系统性能、容量，成功应答所有请求，而是保证在高压下，系统的服务能力不要陡降到0，而是顽强的对外展现最大有效处理能力。\n\n前端系统有保护后端系统的义务，sla中承诺多大的能力，就只给到后端多大的压力。这就要求每一个前后端接口的地方，都有明确的负载约定，一环扣一环。\n\n每个系统要有能力发现哪些是有效的请求，哪些是无效的请求。当过载发生时，该拒绝的请求（1、超出整个系统处理能力范围的；2、已经超时的无效请求）越早拒绝越好\n\n中间层server对后端发送请求，重试机制要慎用，一定要用的话要有严格频率控制。\n\n当雪球发生了，直接清空雪球队列（例如重启进程可以清空socket缓冲区）可能是快速恢复的有效方法。\n\n流量整形也就是常说的限流，主要是防止超过预期外的流量把服务打垮，熔断则是为了自身组件或者依赖下游故障时，可以快速失败防止长期阻塞导致雪崩。\n\n关于限流熔断的能力，开源组件Sentinel基本上都具备了，用起来也很简单方便，但是有一些点需要注意。\n\n【自适应限流】限流阈值一般是配置为服务的某个资源能支撑的最高水位，这个需要通过压测摸底来评估。随着系统的迭代，这个值可能是需要持续调整的。如果配置的过高，会导致系统崩溃时还没触发保护，配置的过低会导致误伤。\n\n熔断降级-某个接口或者某个资源熔断后，要根据业务场景跟熔断资源的重要程度来评估应该抛出异常还是返回一个兜底结果。\n\n比如下单场景如果扣减库存接口发生熔断，由于扣减库存在下单接口是必要条件，所以熔断后只能抛出异常让整个链路失败回滚，如果是获取商品评论相关的接口发生熔断，那么可以选择返回一个空，不影响整个链路。\n\n### 过载保护\n\n异常有内外两种，一种是外部流量特别高，一种是某一个依赖故障导致系统响应变慢。\n\n这里的课题应该包括：熔断、限流、超时控制、全局超时控制、服务降级（区分核心流程与非核心流程）\n\n#### 过载保护方案\n\n这里推荐一种方案：在该系统每个机器上新增一个进程：interface进程。\n\nInterface进程能够快速的从socket缓冲区中取得请求，打上当前时间戳，压入channel。\n\n业务处理进程从channel中获取请求和该请求的时间戳，如果发现时间戳早于当前时间减去超时时间（即已经超时，处理也没有意义），就直接丢弃该请求，或者应答一个失败报文。\n\nChannel是一个先进先出的通信方式，可以是socket，也可以是共享内存、消息队列、或者管道，不限。\n\nSocket缓冲区要设置合理，如果过大，导致及时interface进程都需要处理长时间才能清空该队列，就不合适了。\n\n建议的大小上限是：缓存住超时时间内interface进程能够处理掉的请求个数（注意考虑网络通讯中的元数据）。\n\n参考：https://www.sohu.com/a/211248633_472869\n\n### 资源隔离\n\n如果一个服务的多个下游同时出现阻塞，单个下游接口一直达不到熔断标准（比如异常比例跟慢请求比例没达到阈值），那么将会导致整个服务的吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。引入资源隔离后，可以限制单个下游接口可使用的最大线程资源，确保在未熔断前尽可能小的影响整个服务的吞吐量。\n\n说到隔离机制，这里可以扩展说一下，由于每个接口的流量跟ResponseTime都不一样，很难去设置一个比较合理的可用最大线程数，并且随着业务迭代，这个阈值也难以维护。\n\n这里可以采用**共享加独占**来解决这个问题，每个接口有自己的独占线程资源，当独占资源占满后，使用共享资源，共享池在达到一定水位后，强制使用独占资源，排队等待。\n\n这种机制优点比较明显就是可以在资源利用最大化的同时保证隔离性。\n\n这里的线程数只是资源的一种，资源也可以是连接数、内存等等。\n\n### 系统性保护\n\n![](http://images.elecfans.top/uploads/20221109/494d16cc-6037-11ed-8abf-dac502259ad0.png)\n\n系统性保护是一种无差别限流，一句话概念就是在系统快要崩溃之前对所有流量入口进行无差别限流，当系统恢复到健康水位后停止限流。具体一点就是结合应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。\n\n### 4.10 可观测性&告警\n\n![](http://images.elecfans.top/uploads/20221109/496b13ca-6037-11ed-8abf-dac502259ad0.png)\n\n当系统出现故障时，我们首先需找到故障的原因，然后才是解决问题，最后让系统恢复。排障的速度很大程度上决定了整个故障恢复的时长，而可观测性的最大价值在于快速排障。其次基于Metrics、Traces、Logs三大支柱配置告警规则，可以提前发现系统可能存在的风险&问题，避免故障的发生。\n\n### 4.11 变更流程三板斧\n\n变更是可用性最大的敌人，99%的故障都是来自于变更，可能是配置变更，代码变更，机器变更等等。那么如何减少变更带来的故障呢？\n\n#### 可灰度\n\n用小比例的一部分流量来验证变更后的内容，减小影响用户群。\n\n产品特性设计和发布上，要尽量避免某个时刻导致大量用户集体触发某些请求的设计。发布的时候注意灰度。\n\n#### 可回滚\n\n出现问题后，能有有效的回滚机制。涉及到数据修改的，发布后会引起脏数据的写入，需要有可靠的回滚流程，保证脏数据的清除。\n\n#### 可观测\n\n通过观察变更前后的指标变化，很大程度上可以提前发现问题。 除了以上三板斧外，还应该在其他开发流程上做规范，比如代码控制，集成编译、自动化测试、静态代码扫描等。\n\n五、总结\n\n对于一个动态演进的系统而言，我们没有办法将故障发生的概率降为0，能做的只有尽可能的预防和缩短故障时的恢复时间。当然我们也不用一味的追求可用性，毕竟提升稳定性的同时，维护成本、机器成本等也会跟着上涨，所以需要结合系统的业务SLO要求，适合的才是最好的。\n\n### 冗余\n\n从根本上讲，解决高可用，只有一个方法，就是冗余。通过冗余更多的机器，来应对机器的硬件故障或者彼此之间的网络故障。\n\n#### 多机房部署\n\n通过多机房部署来增加冗余。\n\n多活的好处\n\n1. 响应时间短、提升用户体验\n2. 服务高可用\n3. 降低成本\n\n- 廉价的机器（非洲用户访问非洲的机器）\n- 流量的分摊（西方节日时，流量通过亚洲来分摊）\n\n如何做到异地多活（必须要解决的一些问题）\n\n1. 接入层流量控制：用户默认访问哪个DC？什么时候做切换？ 如何控制这个切换过程？\n\n2. 各DC业务逻辑一致：对于用户来说， 他的流量被调度前后，业务逻辑是一致的。 比如facebook上有一些内容对于亚洲用户是不可见的，不能因为亚洲用户的流量被迁移到了美洲机房，这个限制就失效了。\n\n3. 跨DC的实时数据同步与冲突处理：还是以fb为例， 如果访问非洲机房的用户A给访问南美洲机房的用户B的一个帖子点了赞， 那么B应该能及时收到相关的通知。这背后就依赖数据的实时同步。\n在多活情况下， 多DC的数据写入势必会引入数据的冲突， 比如facebook位于美东的的审核系统和位于东南亚的用户同时操作了一条帖子， 就会产生数据的冲突。\n\n4. 提供全球级别的强一致性\n对于大多数业务而言， 我们只需要最终一致性即可（比如点赞之类的计数）。 但是某些业务，需要全球的强一致保障(比如下\n单、支付之类的操作）。\n\n**同城多机房**：延迟1～3ms\n\n主要看接口的实现（如果有几十次的跨机房交互，这种是不可接受的）\n\n实现相对比较简单\n\n单机房写入；每一个机房近读取本机房的缓存与数据\n\n如果数据发生变更，需要做两边机房缓存的清理，一般通过canal订阅数据库变更\n\n![同城多活示意图](http://cdn.b5mang.com/202132021118.png)\n\n**国内异地多机房**:延迟50ms以内\n\n尽量减少跨机房的调用；而应该避免跨机房的数据库与缓存操作\n\n多机房写入，按照用户或者其他业务维度来进行流量分割，使得一部分流量总是请求A机房，而另外的总是请求B机房。\n\n根据业务需要，选择满足：\n(1）一致性（如果选择了一致性，那么可用性便得不到100%保障）\n(2）可用性（如果选择了可用性，那么一致性需要事后做补偿）\n\n数据同步方式有两种：\n（1）基于存储系统主从复制：同步redis、Mysql等\n（2）基于消息队列：同步缓存、HBase的数据\n\n![异步多活示意图](http://cdn.b5mang.com/20213202149.png)\n\n**跨国多机房**：延迟在100～200ms\n\n避免跨机房的调用，而只能做异步同步\n\n## 每个SLA级别需要做的事情\n\n感觉一下提高1个9，难度有多大。\n\n三个9: 非核心业务可以容忍\n\n四个9: 核心业务\n\n运维值班体系、业务变更流程、故障处理流程、更加完善的系统故障排查工具、灰度发布（确保服务可回滚）\n\n五个9: 必须让机器来自动处理恢复！\n\n尽量思考故障发生后应该怎么办\n\n考虑点：如何自动的发现故障、如何自动化的应对故障、系统运维-尽量避免故障发生\n\n具体方法：failover(故障转移)、超时控制、服务降级、熔断限流\n\nfailover:\n\n- 完全对等\n- 非完全对等（例如存在主备节点，心跳，选择paxos, raft等）\n","tags":["分布式系统"]},{"title":"内存池系列｜概览","url":"/backend_knowledge_architecture/server/memory_pool/index.html","content":"\n## 什么是内存池\n\n1.1 池化是在计算技术中经常使用的一种设计模式，其内涵在于：将程序中需要经常使用的核心资源先申请出来，放到一个池内，由程序自管理，这样可以提高资源的利用率，也可以保证本程序占有的资源数量，经常使用的池化技术包括内存池，线程池，和连接池等，其中尤以内存池和线程池使用最多。\n\n1.2 内存池（Memory Pool）是一种动态内存分配与管理技术，通常情况下，程序员习惯直接使用new，delete，malloc,free等API申请和释放内存，这样导致的后果就是：当程序运行的时间很长的时候，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。\n\n内存池则是在真正使用内存之前，先申请分配一大块内存（内存池）留作备用。当程序员申请内存时，从池中取出一块动态分配，当程序员释放时，将释放的内存放回到池内，再次申请，就可以从池里取出来使用，并尽量与周边的空闲内存块合并。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池。\n\n## 内存池解决什么问题？\n\n1. 内存碎片问题（解决glib、操作系统层面的内存碎片问题，提供内存利用率）\n2. 加速了内存的分配与回收，增加了系统性能。\n\n先说第一个，\n\n造成堆利用率很低的一个主要原因就是**内存碎片化**。如果有未使用的存储器，但是这块存储器不能用来满足分配的请求，这时候就会产生内存碎片化问题。内存碎片化分为内部碎片和外部碎片。\n\n内碎片内部碎片是指一个已分配的块比有效载荷大时发生的。(假设以前分配了10个大小的字节，现在只用了5个字节，则剩下的5个字节就会内碎片)。内部碎片的大小就是已经分配的块的大小和他们的有效载荷之差的和。因此内部碎片取决于以前请求内存的模式和分配器实现(对齐的规则)的模式。\n\n![内部碎片问题](https://images2015.cnblogs.com/blog/163084/201606/163084-20160602211318383-2024258119.png)\n\n外碎片假设系统依次分配了16byte、8byte、16byte、4byte，还剩余8byte未分配。这时要分配一个24byte的空间，操作系统回收了一个上面的两个16byte，总的剩余空间有40byte，但是却不能分配出一个连续24byte的空间，这就是外碎片问题。\n\n![外部碎片问题](https://pic1.zhimg.com/80/v2-fb5aef66f1ec634afa6999641f24da85_1440w.jpg)\n\n每一个场景都通用的解决方案 VS 为某一个场景的定制方案\n\n![底层逻辑](https://pic2.zhimg.com/80/v2-77c340491489371f7ff19532a5dd67fe_1440w.jpg)\n\n## 内存池设计\n\n总体思路：\n\n一次性向底层内存系统（依次为glibc、操作系统）申请一块大的内存慢慢使用，避免了频繁的向内存请求内存操作，提高内存分配的效率；由于向底层内存系统申请的内存块都是比较大的，所以能够降低（下一级别内存系统的）外碎片问题。\n\n值得一提是的：内碎片问题无法避免，只能尽可能的降低。甚至，本层内存池需要通过额外的内存来管理内存，从宏观上讲（对于底层内存分配系统来讲），这是对内存的一种浪费，也可以称之为一种内部碎片。\n\n例如，我每次只需要存储8个字节的数据，一共存储了1000次；显然这种的有效数据是8k; 但是实际上我管理着8k的数据，却使用了底层16k的内存，内存使用率只有50%。\n\n所以，衡量一个内存池系统很重要的一方面就是：他的内存使用效率，他多大程度上降低了内存内碎片的产生。\n\n1. 内存池只能分配特定对象(数据结构)\n2. 充分考虑释考虑内存对象的生命周期（例如apache webserver)\n3. 考虑内存地址的对齐\n4. 考虑线程局部存储来避免不必要的锁冲突\n5. 除了考虑从大块内存上高效地将小内存划分出去，还要注意内存碎片问题。\n6. 当回收内存时要注意是否需要将相邻的空闲内存块进行合并管理。\n当内存池的空闲内存到达一定的阈值时，要合理地返还系统。\n7. 在多核处理器能够 scale\n\n## 内存池的演变\n\n### 最简单的内存分配器\n\n做一个链表指向空闲内存，分配就是取出一块来，改写链表，返回，释放就是放回到链表里面，并做好归并。\n\n注意做好标记和保护，避免二次释放，还可以花点力气在如何查找最适合大小的内存快的搜索上，减少内存碎片，有空你还可以把链表换成伙伴算法。\n\n优点： 实现简单\n\n缺点： 分配时搜索合适的内存块效率低，释放回归内存后归并消耗大，实际中不实用。\n\n### 定长内存分配器\n\n定长内存分配器即实现一个 FreeList，每个 FreeList 用于分配固定大小的内存块，比如用于分配 32字节对象的固定内存分配器，之类的。每个固定内存分配器里面有两个链表，OpenList 用于存储未分配的空闲对象，CloseList用于存储已分配的内存对象，那么所谓的分配就是从 OpenList 中取出一个对象放到 CloseList 里并且返回给用户，释放又是从 CloseList 移回到 OpenList。分配时如果不够，那么就需要增长 OpenList：申请一个大一点的内存块，切割成比如 64 个相同大小的对象添加到 OpenList中。这个固定内存分配器回收的时候，统一把先前向系统申请的内存块全部还给系统。\n\n优点： 简单粗暴，分配和释放的效率高，解决实际中特定场景下的问题有效。\n\n缺点： 功能单一，只能解决定长的内存需求，另外占着内存没有释放。\n\n![定长内存分配器](https://pic1.zhimg.com/80/v2-9b82fa3f6d8649c4574760981dc0e772_1440w.jpg)\n\n### 哈希映射的FreeList\n\n池在定长分配器的基础上，按照不同对象大小(8，16，32，64，128，256，512，1k…64K),构造十多个固定内存分配器，分配内存时根据要申请内存大小进行对齐然后查H表，决定到底由哪个分配器负责，分配后要在内存头部的 header 处写上 cookie，表示由该块内存哪一个分配器分配的，这样释放时候你才能正确归还。如果大于64K，则直接用系统的 malloc作为分配，如此以浪费内存为代价你得到了一个分配时间近似O(1)的内存分配器。这种内存池的缺点是假设某个 FreeList 如果高峰期占用了大量内存即使后面不用，也无法支援到其他内存不够的 FreeList，达不到分配均衡的效果。\n\n优点：这个本质是定长内存池的改进，分配和释放的效率高。可以解决一定长度内的问题。\n\n缺点：存在内碎片的问题，且将一块大内存切小以后，申请大内存无法使用。多线程并发场景下，锁竞争激烈，效率降低。\n\n范例：sgi stl 六大组件中的空间配置器就是这种设计实现的。\n\n![哈希映射的FreeList](https://pic1.zhimg.com/80/v2-0aa79060ce43db2408093746182f4d0e_1440w.jpg)\n\n### 并发内存池\n\n第一层是Thread Cache，线程缓存是每个线程独有的，在这里设计的是用于小于64k的内存分配，线程在这里申请不需要加锁，每一个线程都有自己独立的cache，这也就是这个项目并发高效的地方。\n\n第二层是Central Cache，在这里是所有线程共享的，它起着承上启下的作用，Thread Cache是按需要从Central Cache中获取对象，它就要起着平衡多个线程按需调度的作用，既可以将内存对象分配给Thread Cache来的每个线程，又可以将线程归还回来的内存进行管理。Central Cache是存在竞争的，所以在这里取内存对象的时候是需要加锁的，但是锁的力度可以控制得很小。\n\n第三层是Page Cache，存储的是以页为单位存储及分配的，Central Cache没有内存对象(Span)时，从Page cache分配出一定数量的Page，并切割成定长大小的小块内存，分配给Central Cache。Page Cache会回收Central Cache满足条件的Span(使用计数为0)对象，并且合并相邻的页，组成更大的页，缓解内存碎片的问题。\n\n![并发内存池](https://pic2.zhimg.com/80/v2-59285244475d89d156c0900126926192_1440w.jpg)\n\n### 一些常见的内存分配策略\n\n#### 如何分配定长记录\n\n最大化内存使用率，最小化分配时间\n\n- bitmap来管理定长记录\n\n内存使用率：bitmap需要额外内存，有一定浪费\n\n时间分配效率：$O(1)$\n\n- FreeList来管理定长记录\n\n内存使用率：100%\n时间分配效率：$O(1)$\n\n#### 如何分配变长记录\n\n变长记录进行“取整”操作，带来了内存碎片问题，我们只能减少，而无可避免。\n\n为了减少内部碎片，分配规则按照 8, 16, 32, 48, 64, 80，并非2的幂次级\n\nFreeList来管理“取整”之后的定长记录\n\n内存使用率：有一定的内存碎片\n\n时间分配效率：$O(1)$\n\n以上分配方式都是基于page，当分配小于page的对象时会使用。\n\n#### 大的对象如何分配\n\n首先，每一个线程有一块ThreadCache来管理从CentralCache分配的内存\n\n由于ThreadLocal，所以从ThreadCache分配内存不需要加锁。\n\nCentralCache通过page以及span来管理内存，当需要分配内存时，会通过spinlock来加锁保护。\n\nspan关键属性：是否空闲、startPageId, pageNum\n\npage关键属性：是否空闲\n\n通过Buddy系统来管理所有空闲的page, 而分配出去的Page通过RadixTree来管理起来。\n\n通过RadixTree管理有两个好处：\n\n1. 节省内存，按需分配\n2. 查询性能也还不错，等价于树高度\n\n参考：\nhttps://www.cnblogs.com/wangshaowei/p/14287125.html","tags":["高性能服务器","内存池"]},{"title":"内存池系列｜TCMalloc分析","url":"/backend_knowledge_architecture/server/memory_pool/memcahce_for_tcmalloc.html","content":"\n实现要点\n\n1. 分层（ThreadCache, CentralCache, PageCache)\n2. 线程局部存储来管理ThreadCache\n3. 通过基于hash的freelist来管理小对象\n4. 通过radix tree来管理分配出来的obj到span的映射，如此来方便做回收【对象地址到span的映射】\n5. 通过buddy算法来管理span, 保证用来分配内存的span尽可能的大（大的**总是**可以通过分裂成为小的，小的只有在**合适的时机-内存连续**才能合并成为大的）\n","tags":["高性能服务器","内存池"]},{"title":"内存池系列｜Go内存分配","url":"/backend_knowledge_architecture/server/memory_pool/memcache_for_go.html","tags":["高性能服务器","内存池"]},{"title":"内存池系列｜MC内存分配","url":"/backend_knowledge_architecture/server/memory_pool/memcache_for_mc.html","content":"\nslab allcator的机制\n\n![memcache内存分配示意图](http://cdn.b5mang.com/2021320115717.png)\n\n综合上面的介绍，memcached的内存分配策略就是：按slab需求分配page，各slab按需使用chunk存储。\n\n这里有几个特点要注意，\n\nMemcached分配出去的page不会被回收或者重新分配\n\nMemcached申请的内存不会被释放\n\nslab空闲的chunk不会借给任何其他slab使用\n","tags":["高性能服务器","内存池"]},{"title":"内存池系列｜nginx内存分配","url":"/backend_knowledge_architecture/server/memory_pool/memcache_for_nginx.html","content":"\n![nginx内存池](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo5%2F7488f6235cda4dabaa7beed536bac0ba.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg)\n\n有几个：\n\n1. nginx_pool_s 虽然包含了 ngx_pool_data，但是nginx_pool_s本身的内存管理还是通过ngx_pool_data来进行分配的\n2. 可以理解为：nginx_pool_s是一种特殊类型的ngx_pool_data。\n3. nginx_pool_s 维护了current指针，来指向下一个用来分配内存的小内存块链表节点\n4. nginx_pool_s 维护了large指针，来指向下一个用来分配内存的d大内存块链表节点\n5. ngx_pool_data 维护了next指针 来指向下一个nginx_pool_s\n","tags":["高性能服务器","内存池"]},{"title":"内存池系列｜STL内存分配","url":"/backend_knowledge_architecture/server/memory_pool/memcache_for_stl.html","content":"\n1. 基于hash的freelist\n2. 由于STL知道分配出去的内存对象大小，所以他技巧性地用了union来减少内碎片。\n","tags":["高性能服务器","内存池"]},{"title":"设计模式-reactor模式","url":"/backend_knowledge_architecture/design_pattern/reactor.html","content":"\nReactor 模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。如果用图表示的如下：\n\n![Reactor模式](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/5/169ed823caf32d30~tplv-t2oaga2asx-watermark.awebp)\n\n其实在设计模式层面，IO多路复用也是采用 Reactor 模式的。\n\nIO 多路复用模型可以看成是 Reactor 模式在 IO 模型上的应用。\n","tags":["设计模式"]},{"title":"分布式系统-低延迟，高性能","url":"/backend_knowledge_architecture/distributed_system/high_perfermance.html","content":"\n在我看来，高性能指的是，我们的系统能够在尽可能短的时间内完成用户的请求，也就是说latency尽可能的低。\n\n如果说系统能够支撑更大的吞吐量，能够承载更多的同时在线。我们除了降低latency，还可以考虑加机器（如果还没有reach到某个系统平瓶颈的前提下）\n\n### 提高吞吐量\n\n#### 增加并发进程数\n\n注意：无限增加，不会无限提升性能(对系统的扩展性有要求)\n\n![性能拐点模型](http://cdn.b5mang.com/202132011337.png)\n\n#### 减少响应时间\n\nIO密集型：优化数据库索引、加缓存\n\nCPU密集型：优化算法时间复杂度、减少不必要运算等\n\n并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；\n\n并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。\n\n从一个架构师的角度来看，要想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则，就是要保证\n\n1. 用户请求的数据尽量少\n2. 完成这个请求的路径尽量短、依赖尽量少 =》 上游到下游的请求数尽量少\n\n也就两个大的方向：提升单次效率、减少不必要的请求\n\n1. 动静分离方案（移除无关依赖、减少请求）\n2. 热点的发现与隔离（缩短热点的服务路径）\n3. 请求的削峰与分层过滤（异步化，减少无必要的依赖）\n4. 服务端的极致优化（缩短热点的服务路径）\n","tags":["分布式系统"]},{"title":"分布式系统-可扩展","url":"/backend_knowledge_architecture/distributed_system/high_scalability.html","content":"\n## 一些概念\n\n有合理的办法应对系统的增长（数据量、流量、复杂性）\n\n一个良好适配应用的可扩展架构，是围绕着**假设**（assumption）建立的：哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。如果假设最终是错误的，那么为扩展所做的工程投入就白费了，最糟糕的是适得其反。\n\n数据库、缓存、依赖的第三方、复杂均衡、交换机带宽都是系统扩展时需要考虑的点\n\n### 分层\n\n首先要分层，分层是实现扩展的必要条件；分了层才能让系统有更好的可扩展能力；\n\n![架构分层](http://cdn.b5mang.com/2021320104242.png)\n\n我们将系统分为如下几层：\n\n#### 接入层\n\n主要负责负载均衡，要求负载均衡策略的时间复杂度要尽量简单，追求$O(lgn)$的时间复杂度，最坏不能超过$O(n)$。对于更坏时间复杂度的均衡策略，性能上会扛不住。\n\n#### 应用层\n\n业务层：按照业务拆分、按照重要性拆分（轻重分离，核心、非核心）、按照请求来源（客户端、web、内网等）--这个跑偏了，这些点主要服务于可用性。\n\n这里侧重点在于无状态，我们一定要确保我们的服务无状态。\n\n#### 存储层\n\n存储层做扩展会更麻烦一些。\n\n一般情况下，要求我们根据业务量提前估计好存储容量。根据计算出来的总的存储量，提前做足够的数据分片。\n\n换言之，对于存储层，我们的一种思路是：早做扩展，以确保将来不做扩展；\n\n另外一种思路是，添加必要的路由层（数据访问路由层）或者路由算法（数据表倍增法），来确保将来的扩展对上层不可见。\n\n#### manager层\n\n1. 抽象service层可能提供的一些原子能力\n2. 封装对第三方接口的调用\n","tags":["分布式系统"]},{"title":"高性能服务器设计-总览","url":"/backend_knowledge_architecture/server/server.html","content":"\n池化技术\n核心思想：用空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还统一管理了对象，降低了对象的使用成本。\n例子：\n（1）数据库连接池-最小数量、最大数量、如果超过最大则等待\n（2）线程池-最小数量、最大数量、有界队列（监控队列中元素的个数）\n线程池大小：区分IO密集、CPU密集\n（3）内存池\n\n超时事件管理\n\nIO模型\n\n线程模型，一般会综合考虑IO模型、超时事件如何管理、线程池、消息队列等\n","tags":["高性能服务器"]},{"title":"存储系列-概览","url":"/backend_knowledge_architecture/store/index.html","content":"\n存储模型有哪些？\n\n关系模型\n\n文档模型：数据通常是自我包含的，而且文档之间的关系非常稀少\n\n图数据模型：任意事物都可能与任何事物相关联\n\n参考：\nhttps://blog.csdn.net/heiyeshuwu/article/details/9722443"},{"title":"高性能服务器设计-IO模型","url":"/backend_knowledge_architecture/server/io_model/io_model.html","content":"\n## 5种IO模型\n\n当应用程序需要通过操作系统进行IO通信时，一共有下面5种IO模型供选择。\n\n### （同步）阻塞IO\n\n### （同步）非阻塞IO\n\n### （同步）IO多路复用\n\n复用IO的基本思路就是通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。\n\n### （异步）信号驱动IO\n\nFATAL缺点：信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知。\n\n### 异步（非阻塞）IO\n\n缺点：技术比较新，可能还有些坑没有填完；另外就是异步IO会让应用比较复杂，代码变得难以理解（异步不符合人的思考习惯）\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-Nginx IO模型","url":"/backend_knowledge_architecture/server/io_model/io_model_for_nginx.html","content":"\n端口复用，通过互斥锁来避免**惊群**效应\n\n为什么不采用多线程模型管理连接\n\n1. 无状态服务，无需共享进程内存\n2. 采用独立的进程，可以让互相之间不会影响。一个进程异常崩溃，其他进程的服务不会中断，提升了架构的可靠性。\n3. 进程之间不共享资源，不需要加锁，所以省掉了锁带来的开销。\n\n为什么不采用多线程处理逻辑业务？\n\n1. 进程数已经等于核心数，再新建线程处理任务，只会抢占现有进程，增加切换代价。\n2. 作为接入层，基本上都是数据转发业务，网络 IO 任务的等待耗时部分，已经被处理为非阻塞/全异步/事件驱动模式，在没有更多 CPU 的情况下，再利用多线程处理，意义不大。\n3. 并且如果进程中有阻塞的处理逻辑，应该由各个业务进行解决，比如 openResty 中利用了 Lua 协程，对阻塞业务进行了优化。\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-常见IO多路复用技术介绍","url":"/backend_knowledge_architecture/server/io_model/multiplex_io.html","content":"\n## select\n\n不足：\n\n1. 通过数组来管理fd，数量限制\n2. 触发方式单一，仅支持水平触发（LT)\n\n## poll\n\n优点：通过链条来管理fd，突破数量限制\n\n不足：\n\n1. 当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合（时间复杂度是$O(n)$，导致效率呈线性下降。\n2. 内核与用户态的数据拷贝\n\n## epoll\n\n特点：\n\n1. 没有最大并发连接的限制\n2. 通过红黑树管理所有的fd，时间复杂度为$O(lgn)$\n3. 更丰富的触发方式，同时支持水平触发（LT)与边缘触发（ET)\n\n---\n\nReactor模型\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.2mm6jjukluo0.webp)\n\n单线程Reactor模型\n优点：单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。\n不足：\n（1）第一个缺点，因为只有一个进程，无法充分利用 多核 CPU 的性能；【该缺点可以部署多个进程来解决】\n（2）第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；\n使用场景：CPU密集型\n例子：Redis\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4ifee5h5pqm0.webp)\n\n单 Reactor 多线程 / 多进程\n优点：能够充分利用多核CPU\n不足：\n（1）子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。\n（2）因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。\n使用场景：\n例子：?\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.45unud2y5380.webp)\n\n多 Reactor 多线程 / 多进程\n优点：克服单 Reactor 多线程 / 多进程的缺点2，主线程不会成为瓶颈；【相对上面的方案，实现更加简单一些】主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理；主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。\n不足：\n使用场景：\n例子：memcache、Netty\n\n多 Reactor 多线程 / 多进程（变种）\n思路：进一步的放大子线程/子进程的工作，把accept的工作也交给了子进程。\n使用场景：\n例子：Nginx\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-同步OR异步","url":"/backend_knowledge_architecture/server/io_model/sync_or_aysnc.html","content":"\n#### 判断使用同步或异步\n\n计算qps * latency(in seconds)【最大并发】，如果和cpu核数是同一数量级，就用同步，否则用异步。\n\neg. qps = 2000，latency = 10ms，计算结果 = 2000 \\* 0.01s = 20\n和常见的32核在同一个数量级，用同步。\n\neg. qps = 100, latency = 5s, 计算结果 = 100 \\* 5s = 500。和核数不在同一个数量级，用异步。\n\neg. qps = 500, latency = 100ms，计算结果 = 500 \\* 0.1s = 50。基本在同一个数量级，可用同步。如果未来延时继续增长，考虑异步。\n\n这个公式计算的是同时进行的平均请求数（你可以尝试证明一下），和线程数，cpu核数是可比的。当这个值远大于cpu核数时，说明大部分操作并不耗费cpu，而是让大量线程阻塞着，使用异步可以明显节省线程资源（栈占用的内存）。当这个值小于或和cpu核数差不多时，异步能节省的线程资源就很有限了，这时候简单易懂的同步代码更重要。\n\n#### 异步或bthread\n\n有了bthread这个工具，用户甚至可以自己实现异步。以“半同步”为例，在brpc中用户有多种选择：\n\n发起多个异步RPC后挨个Join，这个函数会阻塞直到RPC结束。（这儿是为了和bthread对比，实现中我们建议你使用ParallelChannel，而不是自己Join）\n启动多个bthread各自执行同步RPC后挨个join bthreads。\n哪种效率更高呢？显然是前者。后者不仅要付出创建bthread的代价，在RPC过程中bthread还被阻塞着，不能用于其他用途。\n\n如果仅仅是为了并发RPC，别用bthread。\n\n不过当你需要并行计算时，问题就不同了。使用bthread可以简单地构建树形的并行计算，充分利用多核资源。比如检索过程中有三个环节可以并行处理，你可以建立两个bthread运行两个环节，在原地运行剩下的环节，最后join那两个bthread。过程大致如下：\n\n```cpp\nbool search() {\n  ...\n  bthread th1, th2;\n  if (bthread_start_background(&th1, NULL, part1, part1_args) != 0) {\n    LOG(ERROR) << \"Fail to create bthread for part1\";\n    return false;\n  }\n  if (bthread_start_background(&th2, NULL, part2, part2_args) != 0) {\n    LOG(ERROR) << \"Fail to create bthread for part2\";\n    return false;\n  }\n  part3(part3_args);\n  bthread_join(th1);\n  bthread_join(th2);\n  return true;\n}\n```\n\n这么实现的point：\n\n- 你当然可以建立三个bthread分别执行三个部分，最后join它们，但相比这个方法要多耗费一个线程资源。\n- bthread从建立到执行是有延时的（调度延时），在不是很忙的机器上，这个延时的中位数在3微秒左右，90%在10微秒内，99.99%在30微秒内。这说明两点：计算时间超过1ms时收益比较明显。如果计算非常简单，几微秒就结束了，用bthread是没有意义的。尽量让原地运行的部分最慢，那样bthread中的部分即使被延迟了几微秒，最后可能还是会先结束，而消除掉延迟的影响。并且join一个已结束的bthread时会立刻返回，不会有上下文切换开销。\n","tags":["高性能服务器"]},{"title":"高性能服务器设计-负载均衡模型","url":"/backend_knowledge_architecture/server/load_balance/index.html","content":"\n### round-robin\n\n总是选择列表中的下一台服务器，结尾的下一台是开头，无需其他设置。比如有3台机器a,b,c，那么brpc会依次向a, b, c, a, b, c, ...发送请求。注意这个算法的前提是服务器的配置，网络条件，负载都是**类似**的\n\n### Weighted Round Robin\n\n根据服务器列表配置的权重值来选择服务器。服务器被选到的机会正比于其权重值，并且该算法能保证同一服务器被选到的结果较均衡的散开\n\n不足：\n\n1. 无法快速摘除有问题的节点\n2. 无法均衡后端负载\n3. 无法降低总体延迟\n\nnginx的WRR算法原理如下：\n\n每个服务器都有两个权重变量：\n\na：weight，配置文件中指定的该服务器的权重，这个值是固定不变的；\n\nb：current_weight，服务器目前的权重。一开始为0，之后会动态调整。\n\n每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。\n\n遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total。\n\n![nginx_WRR](https://img-blog.csdn.net/20160731092902416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n### 动态感知版的Weighted Round Robin\n\n动态感知的WRR\npeer.score = success_rate /(lantency * cpuUsage)\n\n具体做法：\n\n1. 利用每次RPC请求返回的Response夹带CPU使用率\n2. 每隔一段时间整体调整一次节点的权重分数\n\n不足：\n\n自动刷新权重值，但是在刷新时无法做到完全的实时，再快也不可能超过一个 RTT，都会存在一些信息延迟差。当后台资源比较稀缺时，遇到网络抖动时，就可能会把该节点炸掉，但是在监控上面是感觉不到的，因为 CPU 已经被平均掉了。\n\n#### best of two random choice\n\nrepsonse中附带cpu使用率，信息滞后造成了严重的羊群效应\n\n计算权重分数，每次请求来时我们都会更新延迟，并且把之前获得的时间延迟进行权重的衰减，新获得的时间提高权重，这样就实现了滚动更新\n\n![带系数的滑动平均值](http://cdn.b5mang.com/2020123022446.png)\n时间衰减系数的滑动平均值：伴随时间，老的均值，权重越来越小，新的response time，越来越高\n\n### randomized\n\n随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。\n\n根据随机算法，将请求随机分配到后端服务器中，请求的均匀请求依赖于随机算法，该实现方式较为简单，常常可以配合处理一些极端的请求，例如热点请求情况。不适合对命中率有要求的场景。\n\n### consistent-hashing\n\nHash哈希是根据Source IP、 Destination IP、URL、或者其它，算hash值或者md5，再采用取模，相同的请求会请求到同一个后端服务器中。该算法无法解决热点请求，会把某个时间段的热点请求路由到某个单机上，造成雪崩效应，同时在扩充和节点宕机时发生命中率急剧降低的问题（hash算法导致），该策略适合维护长连接和提高命中率。Consistanct Hash是对Hash 算法的优化，可以有效的解决宕机和扩充造成的命中率急剧降低的问题。\n\n一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0~2^32-1（即哈希值是一个32位无符号整形）。\n\n整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。\n\n下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。\n\n### brpc locality-aware\n\n优先选择延时低的下游，直到其延时高于其他机器，无需其他设置\n\n在DP 2.0中我们使用了一种新的算法: Locality-aware load balancing，能根据下游节点的负载分配流量，还能快速规避失效的节点，在很大程度上，这种算法的延时也是全局最优的。基本原理非常简单：\n\n以下游节点的吞吐除以延时作为分流权值。\n\n比如只有两台下游节点，W代表权值，QPS代表吞吐，L代表延时，那么W1 = QPS1 / L1和W2 = QPS2 / L2分别是这两个节点的分流权值，分流时随机数落入的权值区间就是流量的目的地了。\n\n一种分析方法如下：\n\n稳定状态时的QPS显然和其分流权值W成正比，即W1 / W2 ≈ QPS1 / QPS2。\n根据分流公式又有：W1 / W2 = QPS1 / QPS2 * (L2 / L1)。\n故稳定状态时L1和L2应当是趋同的。当L1小于L2时，节点1会更获得相比其QPS1更大的W1，从而在未来获得更多的流量，直到其延时高于平均值或没有更多的流量。\n\n具体见：\n\n[Locality-aware](https://github.com/apache/incubator-brpc/blob/master/docs/cn/lalb.md)\n\n任务：子任务\n自然任务NatureTask，用户任务, TaskKey 用户邀请别人点赞达到10，自己去下单金额超过100（考虑逆向）\n\n状态机（根据规则引擎的判定结果，决定状态机往哪边走）\n\n变与不变，不变的部份，通过代码落地下来；变的部份，通过规则引擎来处理。\n\n不变的部份：事件是可以枚举的，奖励是可以枚举的；\n变的部份：任务参数会变，活动周期会变，累加规则会变，事件奖励的各种组合\n\n写别样的代码...\n\nPM运营沟通，让他们尽量少提没有通用性的需求；\n熟悉业务的同时，给出自己的技术方案\n给大家打鸡血，协同大家一起完成1.0版\n\n救火案例2\nB站微博系统，","tags":["高性能服务器"]},{"title":"高性能服务器设计-常见线程模型","url":"/backend_knowledge_architecture/server/thread_model/thread.html","content":"\n### 单线程模型\n\n代表：Redis\n\n基本原理：\n\n单一线程，依次socket->bind->listen，然后epoll_wait分别进行accept以及读写事件\n\n优点&使用场景：\n\n简单、没有并发锁问题；适用于短耗时的计算密集型服务\n\n缺点：\n\n不能支持耗时较长的事件，尤其是IO密集型\n\n### 单线程(listen+accept+epoll_wait) + 1队列通知 + n线程(读写处理) 模型\n\n代表：thrift-nonblocking-server\n\n基本原理：\n\n1. 在这种模型中，有1+n个线程\n2. 有1个线程执行端口的listen并把listen_fd加入该线程的epoll_set，然后循环去做如下事情：\n\n    2.1 epoll_wait监听新连接的到\n\n    2.2 调用accept获得新到的fd\n\n    2.3 把fd放入队列\n\n    回到2.1，继续epoll_wait\n\n3. 另外有n个工作线程，从队列里面获取文件描述符，然后执行：1）读取数据，2）执行任务\n\n优点：\n\n- 模型不算复杂\n- 并发能力强，能够充分利用多核\n- 天然支持负载均衡（每个工作工作线程完成任务之后就会去队列里主动获取文件描述符）\n\n缺点：\n\n队列可能是性能瓶颈，尤其是当业务逻辑耗时本身极其短的情况下\n\n### 单线程(listen+accept+epoll_wait) + n队列通知 + n线程(读写处理) 模型\n\n代表：memcache\n\n基本原理：\n\n- 这种模型基本类似于上一种模型，区别在于把1个队列换成n个队列，每个工作线程绑定一个队列，每个工作线程从自己的队列消费数据，其他的保持一致\n\n- LISTEN线程往PIPE里写入一个哨兵，通知WORKER线程队列可读\n\n优点：\n\n并发能力更强。相比于单队列的模型，多队列的好处是减少了队列的锁竞争。对于短耗时任务能得到比较多的提升，很适合缓存类应用\n\n缺点：\n\n有可能导致负载不均。因为监听线程是不会去根据不同线程的处理速度决定把任务分配给哪个线程的，如果每个任务的耗时不均衡，那么就可能导致有些线程累死，有些线程饿死。\n\n单线程listen, 在处理高速率海量连接时，单线程可能会成为瓶颈\n\n### 单进程(listen) + n进程(accept + epoll + 读写处理) 模型\n\n代表：nginx\n\n基本原理：\n\n1. master进程监听新连接的到来，并让其中一个worker进程accept。这里需要处理惊群效应问题(加锁、SO_REUSEPORT)\n2. worker进程accept到fd之后，把fd注册到到本进程的epoll句柄里面，由本进程处理这个fd的后续读写事件\n3. worker进程根据自身负载情况，选择性地不去accept新fd，从而实现负载均衡\n\n### 单线程(listen) + n线程(accept + epoll + 读写处理 + 协程) 模型\n","tags":["高性能服务器"]},{"title":"高性能服务器系列-libsvrkit RPC框架","url":"/backend_knowledge_architecture/server/thread_model/libsvrkit.html","content":"\n1. 同时只有一个worker来accept接受新的连接请求。一个连接上的所有请求都是由同一个worker来处理。\n\n2. 通过iovec来接收输入, iovec可以直接交给pb来解析。\n\n3. 如果是一个新的请求包，则开启一个co由它来进行处理。\n\n4. 如果是一个回复包，则根据回复包的seqno, 查询map， 找到对应的co， co_resume， 执行原来的业务逻辑。\n\n5. 通过时间轮来管理所有的超时时间。\n\n6. epoll_wait的timeout 是 min(1ms, 下次超时时间)\n\n7. 通过pipe来进行线程同步。\n","tags":["高性能服务器"]},{"title":"缓存简要说明","url":"/backend_knowledge_architecture/cache/index.html","content":"\n高速缓存服务器(Cache Server)是软硬件高度集成的专业功能服务器，主要做高速缓存加速服务，一般部署在网络边缘。\n\n根据加速对象不同，分为客户端加速和服务器加速\n\n客户端加速Cache部署在网络出口处，把常访问的内容缓存在本地，提高响应速度和节约带宽;\n\n服务器加速Cache部署在服务器前端，作为Web服务器的前置机，提高Web服务器的性能，加速访问速度。\n\n---\n\n缓存有哪些类型？\n\n- 服务器LocalCache （有状态）\n\n将缓存内容放到服务器的本地内存或者磁盘；\n\n无法及时更新，一般都是设置一个合理的过期时间，让其自动过期；适用于实时性要求不高的场景；\n\n优缺点：本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。\n\n特例：数据库缓存\n\n- 分布式缓存（无状态）\n\nredis\\memcache\\tair\n\n- 客户端缓存（有状态）\n\n具体有哪些：\n浏览器cookie；浏览器本地缓存；flash本地存储；html5的本地存储；native app 本地缓存\n\n缓存系统对比与选型\n\n---\n\n在Web应用领域，Web缓存大致可以分为以下几种类型：\n\n#### 浏览器端缓存\n\n浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。\n\n客户端浏览器缓存主要是通过在http头部增加\nLast-Modified,If-Modified-Since,Expires,Cache-Control等标识，和服务器进行协商，是否是采用客户的本机缓存来实现。\n\n其中这里面也会分为三种方式\n\n1 通过Last-Modified，If-Modified-Since方式和服务器通信，客户发出http请求中包含If-Modified-Since，如果服务器端代码没有修改，服务器端返回302响应代码的请求响应头（内容不返回）客户端则直接用本机缓存的内容缓存显示结果。相\n当于节省了服务器执行代码时间以及数据传输时间。\n\n2 通过Expires,Cache-Control控制，客户端发现如果上次请求的页面还未过期，通过Expires或者Cache-Control进行辨别，则直接显示本机缓存的内容，不与服务器进行通信。\n\n#### 服务器端缓存\n\n##### CDN缓存\n\nCDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。\n\n##### 代理服务器缓存\n\n代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等\n\n##### Web应用层缓存\n\n应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。\n\n##### 数据库数据缓存\n\nWeb应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached等。\n\n总结一下：\n一般的高并发的应用程序，都在web层采用了以上几种缓存，一般静态资源（图片，js，css）都会采用nginx反向代理+客户端缓存来实现\n对于门户网站，尤其是首页的新闻，一般都会缓存起来，可以通过反向代理也可以通过应用程序缓存实现方式\n对于下载或者视频网站，由于数据传输比较大，直接采用浏览器本地缓存实现。\n\n---\n\n业务需求可能涉及的缓存组件要求：\n\n##### 容量\n\n需要存储什么类型的内容？ 存储量多大？\n\n##### 并发（qps)\n\n缓存的读写比例以及qps如何？\n\n##### 响应时间\n\n更高的qps可以通过扩容来解决，但是一次响应的时间是有限制的，例如跨机房访问延迟0.5ms，就决定了响应时间不可能低于0.5ms;\n\n反过来，如果业务上要求的resp time必须小于0.5ms， 那么该缓存就一定满足不了我们的要求。\n\n##### 使用成本\n\n分为两部分：\n\n1. 首先服务端，主要包括：运维成本、机器成本\n2. 第二，客户端，主要包括程序员研发成本：单一的库依赖、简洁的配置和人性化的API丰富的文档和技术支持\n\n##### 扩展性要求\n\n在某方面出现瓶颈（qps或者容量）时，能否通过增加机器来快速在线扩容；这个主要涉及到系统的负载均衡能力；\n\n##### 容灾能力\n\n缓存数据丢失；不同的系统有不同的容灾能力；一定要结合业务需求\n","tags":["缓存"]},{"title":"MC缓存必知必会","url":"/backend_knowledge_architecture/cache/memcache.html","content":"\nmemcached作为高速运行的分布式缓存服务器，具有以下的特点:\n\n（1）协议简单，文本协议\n\n（2）基于libevent的事件处理，对服务器的连接数增加，也能发挥O(1)的性能\n\n操作：\n\n（1）set， get， del\n\n（2）多key查询\n\n（3）原子自增，自减\n\n### memcache内存分配\n\nSlab Allocator的基本原理是按照预先规定的大小，将分配的内存分割成特定长度的块，以完全解决内存碎片问题。但是存在内存浪费问题！！（外碎片没有了，但是当分配大小超过实际要用大小时，产生内部碎片）\n\n### memcache删除机制\n\nLazy Expiration\n\n基于LRU(Least Recently Used)算法自动删除不使用的缓存\n\nmemcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过期。这种技术被称为lazy（惰性）expiration。因此，memcached不会在过期监视上耗费CPU时间。\n\n当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。\n\n1.4以前：\n\n维护一个双向链表，当被访问时，移动到head； 当需要淘汰时，从尾巴开始扫描，找到已经过期的item淘汰掉。\n\n1.5以后：\n\n维护子LRU（HOT\\WARM\\COLD),有点类似多级队列。\n\n## 哈希算法\n\nmemcached不互相通信的分布式，由客户端来实现\n\n### 根据余数计算分散\n\n数据的分散性也相当优秀，但也有其缺点。那就是当添加或移除服务器时，缓存重组的代价相当巨大。\n添加服务器后，余数就会产生巨变，这样就无法获取与保存时相同的服务器，从而影响缓存的命中率。\n\n### 一致性Hash\n\n但Consistent Hashing中，只有在continuum（统一连续体）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。Consistent Hashing最大限度地抑制了键的重新分布。\n\n而且，有的Consistent Hashing的实现方法还采用了虚拟节点的思想。使用一般的hash函数的话，服务器的映射地点的分布非常不均匀。\n\n因此，使用虚拟节点的思想，为每个物理节点（服务器）在continuum上分配100～200个点。这样就能抑制分布不均匀，最大限度地减小服务器增减时的缓存重新分布。\n\n### hash表扩容\n\n基于双缓冲思想的扩容方案\n\n启动一个后台线程，监控hash表大小，如果快满了，则拷贝到新的hash表【扩大容量】\n","tags":["缓存"]},{"title":"数据库必知必会-事务篇","url":"/backend_knowledge_architecture/db/acid.html","content":"\n##### 事务的特性\n\n- A 原子性(Atomicity)，要么执行要么不执行\n- C 一致性(Consistency)，事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。（事务的acid不是完全正交的，尤其是一致性，可能跟原子性、隔离性都有一定关系。一致性是一个更宏观的要求。）\n- I 隔离型(Isolation)，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable\n- D 持久性(Durability)，一旦事务提交，对数据的改变就是永久的，即便系统故障也不会丢失\n\n#### 事务同时运行可能出现的问题\n\n- 脏读，事务B读到事务A还没有提交的数据\n- 不可重复读，一行被SELECT两次，返回的结果不一样\n- 幻读，两次读取返回的集合不一样\n\n##### 事务的四种隔离级别\n\n- 读未提交，在该隔离级别，会出现脏读、不可重复读、幻读等问题。\n- 读已提交，该隔离级别解决了脏读的问题，依旧会出现不可重复读、幻读问题。\n- 可重复读，该隔离解决进一步解决了不可重复读的问题，会出现幻读问题。（但是对于InnoDB存储引擎，通过间隙锁解决了该问题，不会出现幻读现象）\n- 串行，该隔离级别把所有操作都串行化了，没有并发访问，解决了以上所有问题。\n\n![数据库各隔离级别会出现的问题](https://images.gitbook.cn/d9fd08e0-a1b6-11ea-bf38-950ba54cfedc)\n\n![Mysql_InnoDB引擎各隔离级别会出现的问题](https://img-blog.csdnimg.cn/20210126002636194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTA4ODM4,size_16,color_FFFFFF,t_70)\n\n虽说希望你了解，但是友情提示一波：线上高并发应用，尽量**不要用事务**！\n","tags":["数据库"]},{"title":"数据库必知必会-存储引擎与数据库索引篇","url":"/backend_knowledge_architecture/db/engine_index.html","content":"\n数据库索引一些经常考察的知识点\n\n#### mysql数据库索引\n\n1. Mysql 数据库有哪些索引以及他们各自的特点？InnoDB为什么选择用B+树作为索引，而不用B树？  \n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| hash索引  | 散列表实现，等值查询效率高，不能排序,不能进行范围查询 | 不需要范围查询，仅需等值查询时，可以考虑使用|\n| BTree索引  | B+树实现，支持范围查询 |默认|\n| RTree索引  | 仅支持地理位置类型，RTree空间树实现，相比Btree有更好的范围查询性能 |有按照地理位置检索需要的场景|\n| FullText索引  | 分词加倒排索引实现 |有类似like的全文检索类型的查询|\n\n相比B树，B+树索引支持范围查找。\n\n索引匹配原则：左前缀匹配原则\n\n#### 聚簇索引、非聚簇索引\n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| 聚簇索引（clustered index）  | 数据按照索引顺序存储，叶子节点存储真实的数据 | InnoDB索引|\n| 非聚簇索引（secondary index，non-clustered index）  | 叶子节点存储指向真正数据行的指针 |MyISAM|\n\n![聚簇索引与非聚簇索引](https://img2018.cnblogs.com/i-beta/1464190/201911/1464190-20191106145143172-1760681728.png)\n\n#### 数据库回表\n\n数据库回表是怎么回事？如何避免？\n\n在查询辅助索引时，如果要查询的字段已经全部在索引中了，那么就不需要额外再查询主索引了；反之，如果要查询的字段当前索引无法覆盖，那么Mysql需要额外查询主索引去获取要查询的字段，访问索引的次数多了一次，我们称刚才的过程为回表。我们通过增加全覆盖索引可以避免回表。\n\n##### InnoDB索引与MyISAM索引的区别\n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| InnoDB索引  | InnoDB的主索引的叶子节点就是数据本身，而辅助索引的叶子节点是主键ID| InnoDB索引|\n| MyISAM索引  | InnoDB的主索引与辅助索引没有区别，叶子节点存储都是指向真实数据行的指针|MyISAM|\n\n1. 索引为什么要用B+树来实现？\n    首先，相比红黑树、AVL等二叉平衡树，B+树更加矮胖，这样子索引查找便能够更好的访问磁盘IO，从而有更好的查询性能；另外相比B树，B+树在叶子节点之间维护了一根链表，借助该链表，范围查找性能更加稳定。\n\n    ![MysqlB+树索引展示](https://images.gitbook.cn/b480a130-a1b6-11ea-97df-0d0e3bd6b465)\n\n2. 两种存储引擎区别与各自使用场景\n  \n|  存储引擎   | 特点  | 使用场景|\n|  ----  | ----  | ---- |\n| MyISAM  | 不支持外键，表锁，插入数据时锁定整个表，查表的总行数不需要扫表，索引与数据分开 | 不需要支持事务，绝大多数请求为读操作，系统崩溃后数据丢失可接受|\n| InnoDB  | 支持外键，行级锁，事务，查表的总行数时需要扫表，必须有唯一索引，索引与数据在一个文件中 |需要支持事务，读写相当，不可接受数据丢失|\n\n3. 为什么说数据表超过2000W就会变慢？有理论依旧吗？\n\n磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。\n\n![最小存储单元](https://pic1.zhimg.com/80/v2-ac5c2c389a4d39dac6cd324d6ba71f34_1440w.jpg)\n\n非叶子节点由索引值和指针构成：主键假设8字节；指针8字节；所以一个页最多有多少个指针呢？ 16k / 16 = 1000左右。\n\n叶子节点直接存数据，假设数据大小为1k，那么一个叶子节点存了16条记录。\n\n所以，B+树树高为1的话，存的记录最多为16 * 000； 高为2的话，1000 * 1000 * 16 = 1600w左右。\n\n在内存有限的情况下，多加一层，就意味着要多一次磁盘IO，性能便会急剧下降。","tags":["数据库"]},{"title":"数据库必知必会","url":"/backend_knowledge_architecture/db/index.html","content":"\n### 自增ID\n\n1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？\n\n(1) 如果表的类型是 MyISAM，那么是 18\n\n因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大ID 也不会丢失\n\n（2）如果表的类型是 InnoDB，那么是 15\n\nInnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进OPTIMIZE 操作，都会导致最大 ID 丢失\n\n### 字符串索引\n\n还有没有其他方式帮助字符串建立索引\n\n比如能够给确定业务需求里面只有按照身份证等值查询的需求，需要给身份证加索引，有没有什么办法，占用更小空间，也能达到相同的查询效率。\n\n第一种方式是使用倒序存储\n\n【基础假设】存储的字符串**后半部分的区分度相对更高**\n\n身份证最后 6 位，没有重复逻辑，因此最后 6 位可能提供了足够的区分度。\n\n先倒序存储，然后再创建前缀索引。\n\n如果存储身份证的时候倒过来存，每次查询的时候,可以这样：\n\nselect field list from t where id card reverse('input id card string);\n第二种方式使用 hash 字段\n\n可以使用表上再创建一个整数字段，来保持身份证的校验码，同时在这个字段创建索引。\n\nalter table t add id card crc int unsigned, add index（id_card_crc);\n每次插入新记录的时候，都同时使用 crc32 这个函数 得到校验码填到这个新字段，校验码可能存在冲突，也就是两个不同的身份证通过 crc32() 函数得到的结果可能是相同的，查询要查询语句  where 部分判断 id_card 的值是精确相同的。\n\n### 排序\n\n全字段排序 VS row_id排序\n\nMySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。 对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。\n\n如果数据量很大，内存中无法存下这么多，就会使用磁盘临时文件来辅助排序，称为外部排序；\n外部排序，MySQL会分为好几份单独的临时文件来存放排序后的数据，一般是磁盘文件中进行归并，然后将这些文件合并成一个大文件；\n\n参考：\nhttps://blog.csdn.net/qq_29066329/article/details/90036836","tags":["数据库"]},{"title":"数据库必知必会-InnoDB存储引擎","url":"/backend_knowledge_architecture/db/innodb.html","content":"\n我们通过几个问题来介绍InnoDB存储引擎\n\n#### LBCC VS MVCC\n\nLock Based Concurrency Control（LBCC）\n\n保证前后两次读取数据一致，那么我读取数据的时候，锁定我要操作的数据，不允许其他的事务修改就行了。如果仅仅是基于锁来实现事务隔离，一个事务读取的时候不允许其他时候修改，那就意味着不支持并发的读写操作，而我们的大多数应用都是读多写少的，这样会极大地影响操作数据的效率。\n\nMVCC Multi Version Concurrency Control（MVCC)\n\nMVCC是InnoDB存储引擎为了实现事务的隔离级别而引入的一种乐观锁机制。\n如果要让一个事务前后两次读取的数据保持一致，那么我们可以在修改数据的时候给它建立一个备份或者叫快照，后面再来读取这个快照就行了。\n\nMVCC的目的在于：我可以查到在我这个事务开始之前已经存在的数据，即使它在后面被修改或者删除了。在我这个事务之后新增的数据，我是查不到的。\n\n#### Undo Log\n\nUndo log: 是什么？ 通过它解决了什么问题？ 数据的多个版本，临时写在undo log中，并通过链表管理起来。\n\nInnoDB为数据库中的每一行添加了三个隐藏字段：DB_TRX_ID(事务版本号)、DB_ROLL_PTR(回滚指针)、DB_ROW_ID(隐藏ID)。\n\n- DB_TRX_ID：记录了创建/更新这条数据的事务版本号（版本号会递增）。\n- DB_ROLL_PTR：记录了一个指向undo log中历史版本的数据指针。（用来支持回滚操作）\n- DB_ROW_ID：一个自增的隐藏行ID。\n\nInnoDB基于事务版本号、回滚指针这两个字段，可以在undo log中形成一个单向链表，最新版本的数据放在链表头部，历史数据通过DB_ROLL_PTR指针进行关联。如下图所示\n\n![undo list](https://pic1.zhimg.com/80/v2-85a123161b23631a22e89313e76caa2c_1440w.jpg)\n\n#### MVCC\n\n一致性读视图包括：视图数组（活跃的事务） + 高水位（已经创建过的事务ID + 1）\n\nInnoDB在事务开启后执行第一个查询时，会创建一个快照（下文称之为ReadView），这个ReadView包含了以下信息\n\n- m_ids: 活动事务id列表（活动事务指的是已经开始、尚未提交/回滚的事务）\n- min_trx_id: 最小活动事务id\n- max_trx_id: 最大活动事务id\n- creator_trx_id:当前事务id\n\n紧接着InnoDB会通过查询语句定位到最新版本的数据行，并根据以下规则获取到可以访问的数据版本。\n\n- 如果被访问版本的trx_id，与readview中的creator_trx_id值相同，表明当前事务在访问自己修改过的记录，直接返回该版本的数据；\n- 如果被访问版本的trx_id，小于readview中的min_trx_id值，表明生成该版本的事务在当前事务生成readview前已经提交，直接返回该版本的数据；\n- 如果被访问版本的trx_id，大于或等于readview中的max_trx_id值，表明生成该版本的事务在当前事务生成readview后才开启，此时该版本不可以被当前事务访问，需要通过隐藏的回滚指针从undo log中读取历史版本；\n- 如果被访问版本的trx_id，在readview的min_trx_id和max_trx_id之间，则需要判断trx_id值是否在m_ids列表中？\n(1)如果在：说明readview创建时，创建该版本数据的事务还未提交，因此需要通过回滚指针读取历史版本并返回。\n(2)如果不在：说明readview创建时，创建该版本数据的事务已经提交，所以直接返回该版本的数据；\n\n#### InnoDB如何解决各种隔离问题\n\n第一、InnoDB是如何解决脏读问题的？\n\n如果是读已提交，那么事务每一个语句执行前都会重新计算出新的视图，也就解决了脏读问题。\n\n第二、InnoDB是如何解决不可重复读问题的？\n\n如果是可重复读，那么事务开启时创建一次访问视图。同一个事务中后续所有的查询共用一个ReadView，由此便解决了不可重复读的问题。\n\n第三、InnoDB是如何解决幻读问题的？\n\n快照读、锁定读：了解这两种读取方式的发生时机以及如何实现的？\n\n快照读是指通过MVCC实现的非阻塞读，常见的快照读操作如下：\n\nselect xxx from xxx\n\n当前读也叫加锁读，每次读取数据都是读取数据的最新版本，并且会对其进行加锁。常见的当前读操作如下\n\n- select xxx from xxx lock in share mode (共享锁/读锁)\n- select xxx from xxx for update （排它锁/写锁）\n- update 、delete、insert\n\n为什么要区分这两种读操作呢？因为MVCC并不能解决幻读的问题。即使是在可重复读级别，通过当前读依然会出现幻读问题。\n\n此问题最终是通过间隙锁（next-key lock)来解决的。\n\n#### InnoDB是如何解决事务的持久性问题\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.55syz9b6quo0.webp)\n\nredo log buffer (内存中)是由首尾相连的四个文件组成的，它们分别是：ib_logfile_1、ib_logfile_2、ib_logfile_3、ib_logfile_4。\n\n- write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。\n- checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。\n- write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。\n- 如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。\n- 有了 redo log，当数据库发生宕机重启后，可通过 redo log将未落盘的数据（check point之后的数据）恢复，保证已经提交的事务记录不会丢失，这种能力称为crash-safe。\n\nRedo log是什么？ 通过它解决了什么问题？\n\nredo log是InnoDB存储引擎为了解决事务持久性而引入的WAL技术。借助redo log，InnoDB存储引擎将事务的commit提交简化为一次内存操作与一次磁盘写入操作。如果磁盘页中的数据发生了丢失，也就是在崩溃恢复过程中，存储引擎会通过重做redo log中的操作来进行数据恢复。\n\nbinlog又是什么？他是干什么用的？ 了解主从同步原理。\n\nbinlog是Mysql server层为了解决主从数据同步而引入的一套日志系统。binlog中记录的是一个数据行发生了什么操作。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6y92ucy02380.webp)\n\nRedo Log与binlog的两阶段提交\n\n- prepare阶段，先写入rede log（状态为准备中）\n- 写入binlog（状态为已提交）--- TX_ID\n- commit阶段，写入redo log（状态为已提交）\n\n而两阶段提交就是让这两个状态保持逻辑上的一致。redolog 用于恢复主机故障时的未更新的物理数据，binlog 用于备份操作。两者本身就是两个独立的个体，要想保持一致，就必须使用分布式事务的解决方案来处理。\n\n为什么需要两阶段提交呢?\n\n如果不用两阶段提交的话，可能会出现这样情况\n先写 redo log，crash 后 bin log 备份恢复时少了一次更新，与当前数据不一致。\n先写 bin log，crash 后，由于 redo log 没写入，事务无效，所以后续 bin log 备份恢复时，数据不一致。\n两阶段提交就是为了保证 redo log 和 binlog 数据的安全一致性。只有在这两个日志文件逻辑上高度一致了才能放心的使用。\n在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。\n\n#### InnoDB的几个关键特性\n\ninsert buffer、double write、自适应hash索引、异步写等\n\n参考：\nhttps://blog.csdn.net/hahazz233/article/details/125372412","tags":["数据库"]},{"title":"数据库必知必会-锁篇","url":"/backend_knowledge_architecture/db/lock.html","content":"\n数据库中涉及到锁的一些经常考察的知识点\n\n![数据库锁](https://images.gitbook.cn/c347e4d0-a1b6-11ea-97df-0d0e3bd6b465)\n\n##### 悲观锁 VS 乐观锁\n\n首先悲观锁（Pessimistic Lock）、乐观锁并不是两种锁，而是两种思想，两种用于实现并发控制的思想。\n\n其中，悲观锁指的是对数据被外界修改持悲观态度，认为数据大概率会被他人修改，所以在我准备修改数据时，我会对该数据加锁以避免其他人对该数据进行并发访问。\n\n而乐观锁指的是对外部修改数据持乐观态度，认为数据不会修改，所以我会直接对数据进行修改，在修改的以后再进行冲突的检查。如果修改失败了，我再决定如何去做。\n\n悲观锁适合**写多读少**的场景，而乐观锁适合**读多写少**的场景。\n\n悲观锁一般通过数据库锁来实现，而乐观锁一般是通过CAS来实现。\n\n##### 意向锁\n\n意向锁是什么？ 为什么需要意向锁？\n\n意向锁是实现多粒度锁的一种方式，是表锁，分为意向排他锁、意向共享锁；\n\n意向锁之间是兼容的；意向锁与表级别的共享锁、拍他锁是可能互斥的；\n\n意向锁与行级的互斥锁、共享锁是兼容的；\n\n实现意向锁的目的有两个：第一，让多粒度锁共存；第二，加快是否可以加锁的判定效率。\n\n考虑一种场景，事务A尝试修改一条数据，此时事务B需要加表锁。 如果没有意向锁，数据库系统需要怎么做？ - 系统需要扫描对所有的行加锁。\n\n意向锁也不会和数据行共享锁S、排它锁X发生冲突。\n\n那这玩意干啥的？\n\nupdate new_table set user_id = 911 where id = 1;\n假设我们执行这么一条语句，innodb除了在id=1的这条记录上增加了行级X锁之前，还对所在表添加了一个意向排它锁。\n\n这个时候如果我们有针对 new_table 的表级锁操作，如：alter table、drop table、lock table 的操作时，会先检查对应表是否存在意向排它锁，若存在则等待锁释放。\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 表级共享锁 | 兼容|互斥|\n| 表级互斥锁 | 互斥|互斥|\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 行级共享锁 | 兼容|兼容|\n| 行级互斥锁 | 兼容|兼容|\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 意向共享锁  | 兼容 | 兼容|\n| 意向互斥锁 | 兼容|兼容|\n\n##### next-key lock\n\nRecord lock、gap lock、next-key lock\n\n- record lock, 行锁， 锁直接加在索引记录上面，锁住的是key。\n- gap lock, 间隙锁，用来解决幻读问题\n- next-key lock， gap lock + reocrd lock\n\n关于next-key lock的两个原则、两个优化、一个bug:\n\n- 原则1: 加锁的基本单位是next-key lock, 前开后闭区间，（A, B]\n- 原则2: 查找过程中遇到的对象才会加锁(延迟加锁)\n- 优化1: 索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁\n- 优化2: 索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock退化为gap lock\n- bug: 唯一索引的范围查找会访问到不满足条件的第一个值为止。\n\n参考：https://blog.csdn.net/zwx900102/article/details/106544634?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control","tags":["数据库"]},{"title":"计算机网络必知必会","url":"/backend_knowledge_architecture/network/index.html","content":"\n\n-------User-----\n\napplication    write(fd,buf.len)\n\n-------Kernel-----\n\nFile        Validate file descriptor.\nSockets     Copy/append buf to **socket buffer**.\nTCP         Create TCP segment according to TCP state, Compute checksum.\nIP          Add IP header,perform IP routing. Compute checksum.\nEthernet    Add Ethernet header,perform ARP.\nDriver      Tell NIC to send the packet.\n\n-------Device-----\nNIC        Fetch the packet from host memory and send it. Interrupt the host when send is done.\n\n缓冲区被塞满\n\n如图所示，物理介质上的数据帧到达后首先由NIC（网络适配器）读取，写入设备内部缓冲区Ring Buffer中，再由中断处理程序触发Softirq从中消费，Ring Buffer的大小因网卡设备而异。当网络数据包到达（生产）的速率快于内核处理（消费）的速率时，Ring Buffer很快会被填满，新来的数据包将被丢弃；\n\n报文mac地址丢包\n\n一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据，如果报文的目的mac地址不是对端的接口的mac地址，一般都会丢包，一般这种情况很有可能是源端设置静态arp表项或者动态学习的arp表项没有及时更新，但目的端mac地址已发生变化（换了网卡），没有更新通知到源端（比如更新报文被丢失，中间交换机异常等情况）；\n\n## 长链接 VS 短链接\n\n长连接：\n\n长连接多用于操作频繁，点对点的通讯（尤其是需要下行消息的场景，例如**即时通信**），而且连接数不能太多的情况。\n\n短连接：\n\nweb网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。\n\n像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。\n\n## TCP与UDP的区别\n\n流模式 VS 数据报模式、连接 VS 无连接、可靠性\n\n### TCP与UDP应用\n\nTCP:对效率要求低，对准确性要求较高 (如文件传输、重要状态的更新等)\n\neg.  STMP, TELNET, HTTP, FTP\n\nUDP:对效率要求高，对准确性要求较低 (如视频传输、实时通信等)。\n\neg.  DNS,TFTP,RIP,DHCP,SNMP\n","tags":["计算机网络"]},{"title":"计算机网络 - TCP协议","url":"/backend_knowledge_architecture/network/tcp.html","content":"## TCP状态迁移图\n\n![TCP状态迁移图](https://img-blog.csdn.net/20171214152607931?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGliYWluZXUyMDA0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3b988wbfquw.webp)\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.40pqw0597va0.webp)\n\nFIN 段是可以携带数据的，比如客户端可以在它发送的最后一块数据块中“捎带” FIN 段。当然也可以单独发送FIN。不管 FIN 段是否携带数据，都需要消耗一个序列号。\n\nTCP三次握手的缺陷：Sync Flood攻击\n\n## 确认机制与超时重传\n\nTCP通过确认机制 ( acknowledge ) 保证了信息的成功发送。\n\n发送的数据编号被称为序列号(Sequence Number - SN)\n\n确认的数据编号被称为确认序列号(Ackonwledge Sequence Number - ASN)\n\nTCP协议正是通过序列号保证了传输顺序\n\nASN = 填写要接收的下一个字节的数据(本次收到的数据的最后一个字节的下一个)\n\nTCP是有发送缓冲区的，用于暂时保存已发送，未应答的数据，为什么要进行保存，因为TCP为了保证数据确切地被对方接收到，需要对方发送的ASN，如果对方没有应答，就需要重发，如果不对数据进行保存，就没有办法重发了，所以发送缓冲区主要也是为了保证可靠性而存在的\n\nTCP有接收缓冲区，这与UDP协议一致，因为接收到的信息，不一定马上就能被应用层取走使用\n\nTCP规定，SYN报文段不能携带数据，但要消耗一个序号；ACK报文段可以携带数据，但如果不携带数据则不消耗序号\n\n客户端在收到第三次挥手的FIN 报文之后，再次收到服务端的数据包会怎么处理\n\n客户端如果收到乱序的 FIN 报文，会将FIN包加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。等收到前面被网络延迟的数据包时，重组报文得到完整顺序的数据包之后，发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。\n\n\n### 关于TIME_WAIT存在的必要性\n\nMSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n1）为实现TCP全双工连接的可靠释放\n\n由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。\n\n2）为使旧的数据包在网络因过期而消失；防止lost duplicate对后续新建正常链接的传输造成破坏。\n\nlost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。\n\n另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。\n\nlost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。\n\n大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000, len=1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。\n\n通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。\n\n## TCP拥塞控制\n\n流量控制(狭义)：根据对方的接收能力来调节发送流量\n拥塞控制：根据网络的承载能力来调节发送流量\n\n接收窗口大致 = 接收缓冲区大小 - 已用大小(接收的数据，暂时没被应用层读走)\n\n发送窗口 = min(接收窗口, 拥塞窗口)\n\n核心：拥塞窗口 cwnd\n\n第一阶段：慢开始、拥塞避免\n\n**快重传**要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n\n第二阶段；快重传、快恢复\n\n快重传配合使用的还有**快恢复**算法，有以下两个要点:\n\n①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n\n②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n![快恢复](https://img-blog.csdn.net/20130801220615250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2ljb2ZpZWxk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n","tags":["计算机网络"]},{"title":"内容分发网络","url":"/backend_knowledge_architecture/cache/cdn/index.html","content":"\nCDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。\n关键技术\n\n（1）内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；\n\n（2）内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；\n\n（3）内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；\n\n（4）性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。\n","tags":["缓存"]},{"title":"模型系列-目标、原则、方法","url":"/模型/目标原则方法.html","content":"\n当你决定做某件事情之前，应该\n（1）先确定目标（目标制定，要符合SMART原则）\n（2）再明确原则（原则制定，不要模棱两可）\n（3）最后去找实现目标的方法（方法制定，要切实可行）\n\n#### 先说目标\n\n坦言之，要明确一件事情的目标，很难。其实很多事情，都会有至少两种解法，一种是长期的，收益会更大一些，但是需要的时间更长一些；一种是短期的，收益小一点，但是耗时短。这时候，我们的目标如何设定呢？其实特别考验一个人（领导者）的判断力，洞察力。\n\n判断力的话，体现在一个人（领导者）需要能够**预判业务将来的需要**，从而决定这件事情的目标应该瞄准长期还是短期。\n\n洞察力的话，体现在领导者能否看透这件事情的本质。我们的解法自然需要事情的本质相匹配。如果我们的目标解法跟事情的本质不匹配，耗时再短，这个目标也是不合理的（因为他的解法与本质不匹配，将来一定会出现冲突，一定需要推翻重来）\n\n#### 再说原则\n\n关于原则有以下几点：\n1）原则要符合公司、团队、个人的价值观\n2）我们需要沉淀某些做事情的原则，避免重复纠结。\n\n这些原则应该是我们团队达成的共识，是团队高效率协作的基础。\n\n#### 最后说方法\n\n在符合原则的基础上，能够达成目标的方法有很多。关于这点，我的原则是：不设限，任其自由生长。\n\n但是事后一定要复盘，要总结。无论方法成功还是失败，都要复盘、分析、总结、分享。\n"},{"title":"跨界能力｜商业力（Business）","url":"/core/商业力/关于商业力.html","content":"\n### 商业\n\n自己定义：在交换的过程中，给消费者创造价值，同时自己获取利润的过程。\n\n商业的几个关键要素：交易、交易成本、阻力（信息与新人不对称）\n\n### 商业模式\n\n商业模式，是利益相关者的交易结构。更优秀的商业结构，会有更低的交易成本。\n\n商业模式，是一个企业**满足消费者需求**的系统，这个系统组织管理企业的各种资源（资金、原材料、人力资源、作业方式。销售方式信息、品牌和知识产权、企业所在的环境、创新力又称输入变量）形成能够消费者无法自力而必须购买的**产品和服务**（输出变量），因而具有自己能复制且**别人无法复制**或者自己在复制中**占据市场优势地位**的特性。\n\n九宫图，可以清晰的罗列商业模式的关键点呢？分为四大类\n\n客户方面：客户细分、客户关系、渠道通路\n\n价值方面：价值定位\n\n基础设施方面：关键活动、核心资源（你想对其他人有哪些优势）、重要伙伴\n\n财务方面：描述运营这个模式引入的成本、收入来源\n\n![20210730082154](https://i.loli.net/2021/07/30/DkZPnVShcvINFUd.png)\n\n换成几个问题：\n\n1. 真实的用户是谁？ 选择什么的细分市场标准？ 空间如何？\n2. 怎么样触达用户？是直销还是经销？ 线上还是线下？\n3. 提供什么样的核心服务？ 核心价值？痛点何在？如何定价？如何收费？\n4. 资源支撑？核心资源是什么？ 需要什么样的伙伴或者上下游？\n5. 财务状况？收入与成本？现金流状况？可持续性？\n\n产业链，从原材料到最终用户的整个链条。\n\n产业链，颗粒度选择；当宏观拆到微观：\n\n1. 通过细粒度拆分才能明确到细分人群\n2. 通过拆分才能够各环节的价值占比，有效防止风险（例如手机行业的芯片）\n3. 通过拆分才能够反映出竞争的格局与壁垒（新能源汽车 =》 燃料电池 =》 交换膜）\n\n市场规模\n\n潜在市场规模 = 目标用户群数量 X 客单价 X 目标渗透率 （对于消费品，需要考虑复购率和频次）\n\n市场规模 = 市场空间 * 当年渗透率（伴随市场会变的）\n\n### 商业目标\n\n商业目标是怎么产生？ 商业目标源于愿景，使命。\n\n什么是增长的商业目标？\n遵循**商业指向**和**业务需求**而制定的目标；在做增长的过程中，有**明确的结果导向**。\n\n增长中的北极星指标：OMTM(One Metrics That Matters)\n\n北极星指标怎么设定？\n\n1. 能反映出你的产品的核心价值的指标\n2. 能让用户价值得以体现的指标\n3. 团队都能理解并息息相关的指标\n\n北极星指标的拆解\n\n输出型指标（负责最终产出的结果展示，更宏观、滞后性）  VS 输入型指标（负责知道我们更细节的执行，更落地、引导型）\n\nOutput Metrics = N 个 Input Metric = N^2 Input Metrics = M X Task\n\n![20210727134715](http://cdn.b5mang.com/20210727134715.png)\n\n公式化思维拆目标\n\n1. 加法：指标指向的业务能否平行拆分为多个渠道来源\n2. 乘法：指标能够拆为一个“量”，乘以一个“率”\n3. 用公式化思维，对一些指标持续持续拆解下去\n\nMECE分析问题：不重不漏\n\n"},{"url":"/core/运营力/电商营销.html","content":"http://www.woshipm.com/pd/2663713.html\nhttp://www.woshipm.com/marketing/3857526.html\n\n核心：\n支持快速试错的通用营销产品模型\n\n营销体系至少包含：\n效果广告投放、用户画像、标签系统、个性化推送、营销工具、分渠道流量效果统计\n\n数字化营销体系要满足三个特点：\n营销策略体系化、营销方式工具化、效果统计数据化。\n\n真核心：\n数据\n\n营销手段：\n\n比较简单的营销玩法：\n\n领取优惠券\n购物返现\n\n一些比较复杂的、可自成体系的营销策略：\n\n社交电商的裂变玩法\nMGM（顾客介绍顾客）\n淘客模式\n外部渠道裂变\n"},{"title":"从底层学科我们可以学到什么","url":"/底层思维/底层学科带给我们的思维升级.html","content":"\n从各种底层学科中，我们可以学到什么？\n\n我们可以学习到很多的概念，以及概念之间的联系。这些我们称之为知识。\n\n学习更多的知识对于我们的生活，有两大作用：\n1）提升我们的认知思维水平，也就说学了一门学科，能够升级你的思维。改变你对一个物体、一件事情甚至一个系统的看法。\n2）提升我们某些方面的技能，例如心理学为平常的日常沟通提供了理论基础。\n\n模型，是对世界某些事情的简化。当我们通过一个模型去描述一件事情，会阉割掉了很多冗杂的细节，让我们的思考更接近事情的本质。\n\n拿互联网产品举个例子\n\n我为什么要去学习一些互联网产品的文章呢？\n我的目的是什么：\n1）能够辅助产品同学做出更好的产品决策，让业务发展的更好\n2）能够看清楚一个需求是否合理，他的收益是否足够高，从而可以将研发资源投入到投入产出比更高的需求中去\n\n基于以上两个目的，\n1）升级我的认知（之前我对产品的理解是错误的，最起码是不完整的，或者没有触及本质的）\n2）总结出自己的做好产品的方法论\n当你对互联网产品有了正确的思维认知以后\n\n哲学\n\n数学\n\n---\n心理学\n\n元认知\n\n![NLP逻辑层次图](http://cdn.b5mang.com/2021415231611.png)\n\n---\n\n物理学\n\n---\n熵与热力学\n\n熵：状态数、可能性\n封闭系统\n耗散系统：需要为你的系统不停的注入信息、能量\n\n伴随时间增加，封闭系统的熵总是会增加。\n\n感知 + 选择 =》 逆熵\n\n生命以逆熵为食\n\n![20210630135341](http://cdn.b5mang.com/20210630135341.png)\n\n---\n\n生物学\n"},{"title":"一文搞懂企业管理相关的核心概念","url":"/团队管理能力/核心概念.html","content":"\n愿景与使命\n\n原则\n\n要认识到：（1）影响好决策的最大威胁是有害的情绪；（2）决策是一个两步流程（先了解后决定）\n\n决策过程分两步：先选择作为决策基础的知识，既包括相关事实（“是什么”），也包括你对事实背后的因果机制的宏观理解；然后根据这些知识来确定行动计划（“怎么做”），这需要你反复权衡不同的可能性，以设想如何实现符合你愿望的目标。\n\n“你必须躲过不良决策的第一个陷阱，就是先在潜意识驱使下做一个决策，然后挑选与决策相符的数据。”\n"},{"title":"成为一个出色的工程师，做到这几点就够了","url":"/专业技能/成为一个出色的工程师，做到这几点就够了.html","content":"\n本文我们探讨如何成为一个出色的工程师？\n\n按照SKA模型，我的答案会分为三大块：\n\n- 第一，正确的态度(Attitude)或者思维方式。\n  当遇到问题时，你会用什么样的态度去应对处理它？当你尝试去解决一个问题时，你又是如何思考的？\n- 第二，尽可能娴熟的必要技能(Skill)。\n  当你知晓了如何去思考问题之后，我们需要借助很多技能去把问题解决。例如，沟通协作技能、编程能力、问题排查能力等。\n- 第三，尽可能完备的知识(Knowledge)体系。\n  很多时候有些人知道问题的答案或者解决方案,仅仅是由于他知道一块我们不知道的知识。\n\n<!-- more -->\n## 态度 & 思维方式\n\n### 清晰的价值观\n\n首先，你应该明晰你的价值观，确保与领导或者公司的价值观保持一致。尝试着回答以下这些问题：\n你的价值观如何？ 你如何看待你现在这份工作？或者说你如何看待这份工作打给你的价值？ 相对你付出的诸多成本（时间成本、各种机会成本），价值是不是足够大？\n\n我个人对工作的看法：\n\n- 于私，工作给我提供了足够多的机会，去打磨我的心智（例如工作中会遇到一些挫折，我们需要应对！），去强化我的技能（例如大型合作项目，需要去跟别人协作沟通），去完善自己的知识体系（通过对工作内容的反思、总结、分享，将经验内化为知识）\n- 与公，工作是一个媒介，我通过工作给公司创造价值。我给公司带来的业务价值的多少，直接决定了公司对我的价值定位，进而决定了自己的职位与薪酬。\n\n综上，你是否会呆在一个公司，直接取决于：公司带给我的收益 与 我付出的成本 的**平衡**\n\n- 公司能够带给我的收益：我的薪资收入（我给公司带来的价值；公司本身、行业甚至国家对公司的影响；公司管理者的员工价值观等）、无形收益（影响力、荣誉感）、工作带给我的能力提升\n\n- 我付出的成本：我付出的时间成本、我放弃的机会成本（新工作带给你的收益 - 跳槽的机会成本）\n\n综上，我们可以把价值观比喻为：\n\n- 定海神针（你明确了自己为什么在这，明确了公司可以带给你什么，才能够不轻易为外部所动）\n- 决策价值的标尺（做决策一定会涉及到价值的考量，价值观不同的人做出的决策一定是不同的）\n- 做事目标的指北针（以终为始，做事情一定得先有目标。价值观作为目标制定的指北针，确保目标与**真正有价值的目标**不背道而驰）\n\n### 强大的责任心\n\n在职场很多年，你肯定遇到下面这些场景，当时的你是怎么处理这些事情的呢？\n\n- 当你负责的服务有告警时\n- 当你们团队的服务有告警时\n- 当别人咨询了你一个并不是你负责的模块的问题时\n- 当客服群有人反馈你所负责的业务有bug时\n\n责任从哪里来，责任源于角色。你身处团队之中，你是团队的角色之一，所以你在你的团队中有责任。而你的责任心则直接决定了你如何看待你的责任，看待你的“份外之事”，看待超越你职责范围内的工作。\n\n自己可能负责哪些东西：\n\n- 老板分配给你，让你跟进的问题、让你owner的业务项\n\n  有始有终，借助PDCA循环把老板交代给你的问题做好。\n  \n- 你负责的业务模块\n\n  需要非常熟悉模块的内部细节、外部协作细节、后续迭代优化方向等；如果对自己负责的模块不是最熟悉的话，是严重不负责任的表现。\n  \n- 你负责的业务\n\n  除了完成PM交代给自己的业务需求外，我们还需要积极思考业务的本质、业务在公司的定位、公司在行业的定位等，主动为消费者负责、为社会负责、为业务负责，为公司负责。\n\n能力（技术能力）与责任心谁更重要呢？\n\n都重要。如果一个新人有培养的潜力，那么责任心就更重要。两个人，第一个技术能力很强，但责任心很差，对项目的事情也不上心；第二个能力差些，但责任心强，是自己的问题一定负责到底，即使自己不能解决也能主动询求帮助。我觉得前者对项目的危害更大，特别是项目紧要时期，因为能力强的人一般负责的是比较复杂、困难的功能，别人上手也需要时间，这个时候如果摞担子，bug也不修，那么就很为难了。\n\n不负责任的典型表现就是扯皮、甩锅：这不是我的bug、不关我的事。有协作的地方更容易出现问题，比如前端与后端、各个部门之间。\n一个有强大责任感的人，会主动承担灰色地带。如果不清楚到底是谁的问题，也会很主动的帮助排查、跟进。\n\n### 强烈的好奇心\n\n有知发现无知，无知求索真知。好奇心是“有知者”探索未知世界的原动力，是创造性人才的特质，是成为出色工程师的必要条件。\n\n当你调试代码跟踪到框架底层的时候，你是否有动力继续深入下去，看看框架是怎么实现的？\n\n当你听到协程有多牛B、多好用时，你是否想知道它到底应该如何实现？\n\n当你学习操作系统学习到虚拟内存、物理内存时，你是否想去深入了解Linux可能会如何管理内存，缺页中断是怎么回事？\n\n当你从PM那边接收到一个产品需求的时候，你会不会去思考这个需求的底层原理是什么？它是为了解决那些用户的什么问题？\n\n如果没有好奇心的驱使，你永远只是一个普通的程序员，永远只会是一个CRUD BOY。\n强烈的好奇心，会驱使你去了解事物的本质；在了解本质的路上，你有机会发现更多；了解更多的案例，获取更多的经验，归纳演绎出更多接近事物本质的知识。\n\n### 出色的工程师思维\n\n什么是工程师思维呢？在我看来，工程师思维是通过计算机来解决现实问题的一系列思维方式和方法的汇总：\n\n- 不安于现状，讨厌单调的重复工作\n\n  例如每天都要执行多次的诸多命令，考虑写一个批处理脚本？\n  \n- 经典的计算机与数据结构、算法思维\n\n  TradeOff思想、空间换时间思想、局部性原理、COW思想、二分思想、分治思想、回溯思想等\n  \n- 永远乐于去寻求问题的最优解\n\n  程序代码、服务架构的极至优化\n  \n- 从信息的角度去解决现实问题\n\n  首先尝试用常人的思维去剖析问题，尽量触及问题的本质；然后把问题的解决抽象为信息的传递与处理。\n  你的问题的了解越深入，得到的信息处理模型便更加接近“真理”，写出来的代码也更具扩展性。\n\n### 高效能人士的几种思维方式\n\n高效能人士应该有的几种思维方式：\n\n- 积极主动：\n- 以终为始\n- 要事第一\n- 双赢思维\n- 知彼解己\n- 统合综效\n- 不断更新\n\n### 用跨界思维重新审视问题\n\n通过前面提到的工程师思维，自然可以相对优雅地解决某一个既定问题。\n\n但是这个问题本身合理吗？这个问题的解决会给用户或者说给社会带来多少价值呢？\n\n要回答上面这两个问题，你就算有再出色的工程师思维都没有用，我们只有跳出某个既定的圈子（我们的工程师思维会给我们的思维圈上一个圈），从更高的层次去重新审视问题，才有可能给出比较理想的答案。\n\n![跨界思维](http://cdn.b5mang.com/202151015576.png)\n\n下面是一些我个人觉得比较重要的跨界思维，供参考：\n\n- 物理学思维\n\n  每一个封闭的知识系统的结论都是在一些基础假设的基础上通过逻辑推理演绎出来的。\n  我们将这个基础假设叫做这个系统的基石假设。将这种不断地刨根问题去问为什么的思考方式，称之为第一性原理思维。\n  \n- 系统动力学思维\n\n  “普通的人改变结果，优秀的人改变原因，顶级优秀的人改变模型。”\n  \n  洞察力：透过现象看本质、然后改变模型的能力。通过学习系统动力学，可大幅提升自己对事物的洞察力。\n  \n  在系统论中，系统 = 关键要素（又叫变量） + 要素之间的连接（又叫关系）\n  \n  变量：增量改变存量，存量改变世界\n  \n  连接：关键因果链、正反馈回路、负反馈回路、滞后效应\n  \n- 复杂性系统思维\n\n  熵增定律：热力学第二定律，从有序到无序。\n  \n  耗散系统：开放系统，通过与外界交换来对抗熵增。\n  \n  自组织系统：涌现\n  \n  分型系统：自相似\n  \n- 哲学思维\n  亚里士多德四因说 - 质料因：为什么事物在运动中持存；形式因：为什么事物运动具有特定的方式；动力因：为什么事物开始运动；目的因：为什么事物要运动。\n  \n  整体论 VS 还原论（组合创新的思维起点）\n  \n  归纳与演绎\n  \n  批判性思维\n  \n- 心理学思维\n\n  马洛斯需求模型\n  \n  诸多偏见、不理性\n  \n- 数学思维(数学带给我们的一些启发)  \n\n  公理化思维，欧氏几何，基于5大公理，演绎出整个几何大厦\n  \n  抽象思维，从具体的数字到抽象的函数\n  \n  从特例到普遍，从标量到向量再到更具有普适性的矩阵\n  \n  本质思维，函数的本质是什么？ 矩阵的本质是什么？\n  \n  极限思维，从有限到无限，从无穷大到无穷小，从最初量的变化到最终质的变化\n  \n  变化延迟效应，从加速度（距离的二阶导数）到速度（距离的一阶导数）再到距离，变化的延迟发生，事情造成影响的滞后性\n  \n  博弈思维，从零和博弈到非零和博弈，从双赢到双输\n  \n  概率思维，某种程度上概率的反直觉性；常见的概率分布模型：二项分布、正态分布、泊松分布等\n  \n- 互联网思维\n\n  互联网的本质：从本质上看，其实互联网并不产生实质上的经济，而它做的只是让信息更快、更便捷地流通，从而帮助实体的资源更快、更便捷地流通和兑换，减少了成本和加速资金流动。\n  \n  互联网产品的本质：核心能力是资源整合，寻找事物存在的优化空间 VS 实体产品\n  \n- 产品思维（想象自己是一个PM）\n\n  思考做产品要解决的根本问题：从更人性化的角度去帮助用户识别和解决问题，从而给用户创造价值。\n  \n  整合现有市场的资源（或者寻找需求）根据产品定位做好相应配套和流程优化\n  \n- 运营思维（想象自己是一个互联网运营）\n\n  产品运营的核心目标：告诉所有人（或目标人群）产品的价值；\n  \n  优化宣传渠道，尽量减少对用户的骚扰，在用户最需要你产品的时候看到你，想到你；\n  \n  提升产品利润和用户流量及产品的转化率；\n  \n  优化运营管理，让用户能即时反馈问题；\n  \n  减少宣传销售成本；\n  \n  了解用户使用产品中的难题，帮助提成产品的体验和品质。\n  \n  思考做运营要解决的根本问题：如何花更少的钱去做更多的事情\n  \n- 经济学思维（想象自己是一个理性经济人）\n\n  成本与收益思维，ROI投产比\n  \n  成本思维，考虑成本时考虑要额外考虑时间成本、机会成本\n  \n  如何看待效率与公平\n  \n  优势与分工\n  \n- 金融思维（想象自己是一个银行家或者投资人）\n\n  借债产生利息，导致破产轻松 VS 技术债导致维护成本，导致重构\n  \n  储蓄产生资本积累，导致增长 VS 定期进行重要的技术重构\n  \n- 商业思维（想象自己是一个企业家）\n\n  企业的护城河 VS 个体或者团队的不可替代性\n\n## 技能\n\n这里我把技能分为两大类：通用技能、专业技能\n\n先说工程师的专业技能\n\n- 需求的理解与编码实现能力\n\n  1. 深入理解需求，梳理出需求涉及到的存储与外部交互方\n  2. 输出数据流图，搞清楚数据流与信息流的流向\n  3. 以存储为中心，对系统进行模块划分，如有必要引入缓存、分库分表、异步等性能优化手段\n  4. 编码实现\n\n- 问题排查能力：当自己的负责的业务出现问题（用户反馈，或者有监控告警）时，有能力尽快对问题进行止损、排查定位、修复\n\n  1. 掌握必要的知识：操作系统提供了哪些工具，这些工具分别可以用来定位哪一类问题？\n  2. 掌握必要的知识：问题根本原因的分类：代码逻辑bug、IO异常（容量不足、硬件故障？）\n  3. 优先考虑回滚止损（是否新发布了代码、上游流量是否有增加、下游依赖吞吐量是否发生变化等）\n  4. 借助日志、抓包等工具，对问题的发生范围进行二分定位（上游、服务本身、下游）\n  5. 重复步骤4），直到定位到问题的根因，然后问题修复（扩容、修复逻辑bug、更换硬件等）\n  6. 事后问题复盘\n\n- 优秀的编码能力&编码习惯：高性能、可扩展好、可维护性强\n\n  1. 带着工程师思维去编码（代码的本质在于：它对信息进行加工，这里的加工包括：反序列化、追加额外的信息、信息格式转换、删除额外的信息、把信息通过容器管理起来、序列化）\n  2. 建立公司、团队统一的编码规范\n  3. 掌握必要的知识：设计模式、面向对象编程、表格式编程等\n  4. 结对编程，用更高的标准去互相review，相互提高\n  5. 两点认知：一般情况下，代码越少，便越容易理解。当代码可理解性与代码性能有冲突时，一般情况下，选择可理解性；底层高频代码除外。\n\n- 架构设计能力\n\n  1. 微观上，去学习一些底层系统的设计思路，例如操作系统、数据库、Redis、MC、Nginx等\n  2. 宏观上，去了解更多的分布式海量系统设计思路，例如搜索、Feed、Hadoop、分布式存储、评论系统、ID生成器等\n  3. 借助项目给予自己的机会去练习、实践上面学到的设计技巧\n\n然后再说说普通工程师的通用技能\n\n- 沟通表达能力\n\n  沟通的本质：建立你与待沟通对象的沟通**通道**，把需要沟通的**内容**传递给对方（并影响对方），从而达到自己的沟通的**目的**\n  \n- 团队协作能力\n\n  对于普通个体而言，团队协作的能力一般表现为与团队内其他个体的沟通表达能力\n  \n  区分事实与观点\n  \n- 快速学习能力\n\n  库博学习圈：从行动归纳出经验，从经验升华为规律，用规律来指导行动。\n  \n- 时间管理能力\n\n  紧急重要四象限、收益影响四象限\n  \n- 事项管理能力\n\n  Get Things Done: 事务的收集、处理、回顾\n\n最后说说核心/骨干工程师需要的通用技能\n\n- 跨团队协作能力\n\n  同理心、影响力、双赢思维\n  \n- 谈判能力\n\n  在公司内部，更多的需要的是团队协作能力\n  \n- 目标管理能力\n\n  OKR对组织目标进行拆解、SMART原则、KPI量化指标\n  \n- 演讲能力，不是你在讲，而是他在听\n\n  1. 按照人的思考线索，而不是知识的树状结构来演讲\n  2. 无可否认的事实 + 无可辩驳的逻辑\n  3. 用幽默感，让认知的路上满是风景\n\n## 知识\n\n这里提到的知识，我们也分为两类：前人总结的知识、自己沉淀总结的知识\n\n- 前人总结的知识\n  \n  前人总结的知识，可以参考[个人博客](http://www.b5mang.com/knowledge.html)\n\n  为什么需要学习那么多的知识呢？知识变来变去，但万变不离其宗。系统设计时，确实是有很多套路可循的。这些套路就出自前人之手。\n\n- 自己沉淀总结的知识\n\n    1. 首先你需要有一种意识：我对之前那种低效的重复工作厌倦了，我想要提升效率。我相信其他人肯定也会有这种诉求。\n    2. 你需要准确的去描述你要去解决的问题（抽象问题本质的能力）\n    3. 借助搜索引擎去检索自己的问题\n    4. 总结，内化成自己的知识经验\n    5. 分享给大家\n"},{"title":"更好的自己","url":"/团队管理能力/better_myself.html","content":"\nSMART 是原则\n\nKPI 是工具 关键绩效指标\n\n工作手册\n\n技术管理手册\n\n“怎么做团队建设呢？”\n“怎么提升团队凝聚力呢？”\n“怎么做向上沟通和向上管理？”\n“怎么做员工激励？”\n“怎么应对低绩效员工呢？”\n\n如何提高自己的沟通技能？\n\n如何提高自己的业务理解能力？\n\n如何培养自己的梯队？\n\n---\n\n![202141521017](http://cdn.b5mang.com/202141521017.png)\n\n你也可以不断拓展自己**项目管理能力和带团队的能力**，这样你会成为越来越高级的技术管理者，也可以去创业公司做技术合伙人。当你越来越关注**行业发展、商业逻辑、公司经营**，就慢慢拥有了职业经理人和公司创始人的视角；当越来越关注**资本运作和资本产生的价值**，就会从投资人的角度去看待各行各业和整个社会。\n\n---\n\n判断力，资源配置效率最大化\n\n技术判断力：结果评估（目标明确，以终为始）、可行性评估（ROI足够高）、风险评估\n\n产品判断力：\n\n---\n\n**领导风格**，因势而变\n\n指令式管理：重事不重人，关注目标和结果，喜欢发号施令但不亲力亲为。（唯一熟悉，需要强制性）\n支持式管理：重人不重事，希望带头冲锋亲力亲为，特别在意团队成员的感受，并替他们分担工作。（项目攻坚时）\n教练式管理：重人也重事，关注全局和方向，并在做事上给予教练式辅导和启发。（需要培养骨干，梯队搭建时）\n授权式管理：不重人也不重事，关注目标和结果，不关心过程和人员发展。（团队梯队搭建完成，成员需要发挥空间）\n\n---\n\n角色认知（思维转换,Attitude）管理沟通（最重要的Skill)\n\n看方向-管理规划\n\n职能、目标、团队、路径\n\n带人-团队建设\n能力与激励、分工与协作、文化与梯队\n\n做事-任务管理\n轻重缓急、有效执行、流程机制\n\n---\n\n角色认知\n\n首先对自己身份（“自己是谁”）要有清晰的认知，否则价值观（为什么）、能力（怎么做）、行为（做什么）都无从谈起\n\n角色，赋予了你责任，告诉你应该去做什么？\n\n之前你是工程师，现在你是管理者\n\n![工程师到管理者的角色转换](http://cdn.b5mang.com/2021415232051.png)\n\n职责使命\n思维方式与看待问题的视角\n工作内容&目标（工作从哪里来？工作有哪些？工作要达成什么目的）\n工作完成手段（靠团队、靠合作）\n\n当没事可干时，不应该**过程导向、被动执行**，应该**主动规划，目标导向**\n当小伙伴做事情做的不好时，不应该**大包大揽、唯我最强**，应该**梯队建设，激励成长**\n不应该**带头大哥、当家保姆**，应该**公司立场，把控方向**\n当遇到一个问题很难解决时，不应该**单一视角、固化思维**，应该**通过用更加立体的思维方式去解决问题**\n当与别人合作不顺利时，不应该**自扫门前雪、固守边界**，应该**项目为主，扩大自己影响力**\n\n---\n\n管理规划\n\n你团队是干什么的？ 例如我们团队试图通过XXX产品来帮用户创造价值\n你团队想做出什么成果？\n你依靠什么样的团队？\n你需要投入哪些资源？\n\n想清楚一个问题：你想要什么目标（目标取决于团队的职能），以及你需要投入什么资源（核心资源就是团队）\n\n你了解你的团队是干什么的吗？你能用简单的话来表述吗？ 你的小伙伴能说出吗？\n\n1. 公司为什么要给我这批资源（指这个团队）？是希望我产出什么？\n2. 这个团队存在的独特价值是什么？\n3. 你用什么维度来衡量团队的价值高低？\n\n如何设定团队的职责与使命：\n1）收集信息（与老板沟通、与团队沟通、与兄弟部门沟通、结合自己对业务的理解）\n2）提炼和升华（提炼规则、升华使命-结果性描述 VS 过程性描述、确认衡量指标）\n3）确认与主动\n\n---\n\n团队目标\n\n具体原则：SMART原则\n\n根据是否可以量化，目标可以分为两类：\n容易量化的目标：KPI，截止某个时间点，某个指标达到什么值\nOKR：截止某个时间点，完成某件事情，具体包括哪几个关键结果\n\n目标设定的四类问题：\n（1）基于现有资源做目标，而不是基于远方的目标往前推\n    “以终为始” 从上级的角度来讲，你的团队需要保证哪几项重要的结果，然后再看看如何调配和补充资源\n（2）目标不明确\n    结果导向，而不要过程导向\n（3）目标未传达或者拆解到团队成员\n（4）目标经常变化-需要靠专业目标来增强团队的定力\n\n根据目标的业务属性，可以分为：\n（1）业务目标（一般会伴随业务改变而改变）\n（2）专业目标设定（！！团队的定力，不会因为业务目标变而变！！）的核心步骤就两步：\n    第一，选择你要提升的关键维度；\n    第二，设定目标，可以是量化的 KPI，也可以是非量化的 KRA\n\n每一个团队都有自己最核心的评价维度（最能体现团队核心能力及价值），这是由团队职能决定的，比如：\n服务端团队的稳定性和性能\n数据团队的准确性和安全性\n功能迭代团队的高效和质量这些维度是的\n\n---\n\n团队规划\n\n三个角度来看：\n第一，团队目标设定：截止到某个时间点，团队要长成什么样子（规模、分工、梯队）\n第二，资源角度：成本意识，为什么找那么多人，能给公司带来多少价值？\n    根据你对业务的理解以及要达成的目标，去进行资源的估算\n    行业资源配比\n第三，人才培养角度：新人帮带问题\n    老人足够多吗？会多大程度上影响业务产出\n    新人培养机制完善吗？\n\n最终产出：\n（1）组织结构图--树形\n（2）资源盘点情况--按照职级来罗列清单，总共需要多少，当前多少，新增多少\n（3）梯队培养计划--谁来负责哪一块，带几个人\n\n---\n\n资源申请\n\n（1）资源的多样性\n除了人、资金预算以外，别忘了：\n时间资源（是否给我足够多的时间去做成某件事情）、信息（公司信息、业务信息、人员信息）、权限（绩效沟通、奖金分配）\n（2）手段的多样性\n![20214170723](http://cdn.b5mang.com/20214170723.png)\n（3）人力资源持久性\n不是所有的人，招了来，就能留得住～ 业务真的有这种人才的需求，才需要去招更牛的人\n\n---\n\n带团队\n\n一个目标：团队战斗力\n三个视角：个体、个体间、团队\n六个维度：能力（能力培养）、意愿（员工激励）｜分工、协作｜梯队建设、团队文化\n\n能力培养\n\n你的认知升级：\n（1）珍视差异\n（2）价值观相同，优势互补\n（3）激励在平时\n\n个体战斗力 = 个体能力 * 个体意愿\n\n第一个问题：要提升哪些能力？\n\n分法1:\n态度（用心去感受学习、更重要的是思维方式）、技能（需要去重复连续）、知识（需要用脑子去记忆）\n\n分法2:\n通用能力、专业能力、人格力量（与一个人的性格有关，作为管理者需要的是去发现）\n通用能力有很多\n普通员工｜最基本（及格）的：沟通能力、协作能力、学习能力\n核心员工｜优秀的：目标管理、沟通协作等\n\n第二个问题：如何达成学习目标呢？\n\n10%靠自学，20%靠交流讨论，70%靠工作实践\n\n第三个问题：如何提升大家的学习意愿？\n\n推，给压力，推着大家学～\n拉，给方向，引导他们学\n放手，给发挥空间，让他们自主学习\n\n---\n\n如何提升员工的工作意愿（更好的激励员工）\n\n有三个问题：\n1）激励认知不系统（不知道激励有哪些套路）\n2）激励手段不太足\n3）激励效果不明显\n\n针对第一个问题，我们需要对激励有更完备的认知\n1）驱动力1.0 满足最基本的生存需求\n2）驱动力2.0 外部驱动（胡萝卜 + 大棒）\n    寻求激励-晋升、调薪、表扬（具体、公开、及时）\n    避免惩罚-罚款、批评\n3）驱动力3.0 自驱\n    自主性（工作时间与地点有一定自由度、工作内容自主、工作方法自主）\n    专精（目标明确、工作略有挑战、发挥自己的长处）\n    使命&价值\n\n第二个问题，激励手段不足\n\n管理者需要给员工“画饼” 画能够兑现的饼\n\n第三个问题，激励方案要定制（根据团队特点、根据员工特点去定制）\n\n---\n\n如何高效分工\n\n首先为什么有分工？\n1）分工是为了规模化（分工一定会带来低效；分工是为了能够做大事！如同架构分层、拆分服务一样）\n2）分工是为了协作（分工是手段，协作是目的）\n3）分工是为了专精\n\n分工有两种方式：\n1）矩阵式--横向按职能切， 2）BU式--纵向按业务切\n\n几个原则：\n分工要边界清晰（只有边界清晰了，才有所谓的边缘地带，大家才有归属感、责任感；大家才会去主动承担更多）\n分工要尽量稳定（分工稳定了才能够专精，才能够有归属感）\n分工要结合员工的优势\n\n---\n如何高效协作\n\n分工是基础，如何协作更重要！更体现一个管理者的水平！\n\n提升协作 = 硬件靠流程机制（流程制度建设后面再提） + 软件靠团队凝聚力\n\n提升团队凝聚力，有四个方面：\n1）团队成员应该有共同目标，甚至是公共使命\n    自己笃定的使命愿景；重复给员工听！\n2）让成员在团队中有自己的位置，有归属感！\n事对：给他一个位置，一个职责（不只是压力，还是归属，内心渴望承担更多）给他分配事情，明确这件事情的意义所在\n人对：志同道合的同事\n味对：价值观要匹配，不匹配的会被筛选掉；匹配的会被留下\n3）让团队成员相互了解\n4）一起迎接挑战--一起抗过枪的兄弟！\n\n---\n\n团队梯度建设\n\n梯度建设 = 选人 + 育人\n育人 = 对其目标 + 充分授权 + 反馈\n\n选人，分两点：一致性、差异性\n一致性体现在三方面：\n1）能力与业务需要相匹配（如果业务需要强沟通、协调，那么外向社交性的同学可能会更合适）\n2）协作能力强（擅长于各部门打交道）\n2）认可公司的文化、价值观\n\n差异性主要体现在：你要提拔的人，最好是跟你可以优势互补，尽量少提拔那些工作能力跟你很相似的人。\n\n对其期待，达成共识-IDP（个人发展计划）\n\nIDP + 绩效计划 通常会结合在一起：\n1）绩效计划，占比80%， 个人成长是以完成绩效目标为基础\n2）个人成长，占比20%，在一个考核周期内，“把那几件事情做到什么标准”\n\n不承诺原则\n1）晋升靠的是自己的影响力\n2）即使培养失败，也不致于散伙\n\n提供机会和发展空间，作好授权\n\n1）事前：\n    审视初衷（你授权给某人，是为了得到什么？是“项目人手不足”导致的被动授权，还是“某人需要学习和锻炼”的主动授权？\n    明确期待（对其目标，SMART原则，让被授权者了解你对他、对这个项目的期待）\n    听其思路（了解下被授权者打算怎么做，他的主要思路是什么？把控下整体风险）\n    重要约定（定期汇报进度，有风险时汇报）\n2）事中\n    了解进展（在对方汇报进度时，了解进度，评估风险）\n    给予支持（结合问题，引导对方启发式思考）\n    评估结果（针对每次授权，给予有理有据的评价 以及 及时的反馈）\n3）事后\n    洞察优势（了解对方的优势：特别谨慎周密、特别有责任心、思路特别灵活、特别善于合作、善于沟通表达）\n    积极反馈（积极给出更多的正向反馈，并反馈给对方）\n    一条改进（如果不足很多，也仅给出一条改进建议-最重要的一条）\n\n建立反馈机制\n1）周期性沟通机制\n2）review idp\n3）安排第二导师，给予支持和反馈\n\n---\n\n团队文化\n\n约定俗成的工作方式（例如每天都工作到21:00）和是非判断（赶工期 还是 保质量？ 不可兼得，二选一）。\n在这个团队中，即便没有人告诉你什么是对的、什么是错的，你大体上也清楚什么该做、什么不该做。\n它虽然不像规章制度那么带有明确而强制性的约束力，却也能引导和规范团队成员的言行举止，我们把这种潜移默化的行为准则和工作作风称为团队文化。\n\n价值观，文化，用来针对一些模棱两可的问题，给出明确的答案。\n\n文化的作用\n1）效率：文化秩序性；约定俗成，不用跟老板或者peer确认，自然协作效率便提高了。\n2）空间：文化导向性；文化约定了团队的价值导向；在符合价值观导向的前提下，员工的工作可以有更高的自由度，而不用局限于某种做事方法、做的事情的内容等\n3）归属：文化筛选性；把无法融入团队的人筛出去，留下的人，更有归属感，因为他认可团队的文化、价值观\n4）耐力：文化延续性；什么时候算团队散了？ 文化没了才算，而不是某一些员工的离开。\n\n如何打造团队的文化呢？\n1）命名它\n\n避免拿来主义，要结合你的团队，从你（团队负责人）的身上去提炼！\n不是越简单越好，要容易记忆\n\n2）主张它\n\n在合适的时机（季度会、周会、1:1沟通）告知给大家\n\n3）追求它\n\n不是刻意的组织团建活动，而是在平常。\n\n你在和员工约定绩效方案的时候，有没有体现团队文化和价值的内容？\n你在评优和表彰员工的时候，有没有明确体现团队文化价值观？\n你在选拔新人导师的时候，有没有和团队文化挂钩？\n你在项目成功发布的时候，有没有总结团队文化？\n你在辅导和教导员工的时候，是否有提及团队文化？\n\n如何与低绩效员工沟通\n\n沟通绩效的目的是什么？\n1）对齐--与他对齐针对某些事情的看法、例如，对文化、价值观有没有不认可的地方？\n2）辅导--跟员工一起回顾过去的工作，启发他更多的思考\n3）激励--让他重燃斗志\n\n如何沟通？\n\n1）绩效沟通的目的不是在于谈，而是在于绩效管理全过程的完整性\n    绩效计划或绩效评估方案的制定。即，你未来给员工打绩效的依据是什么。！！不要把工作内容放在绩效计划中，而应该是你要达成什么成果！！！！\n    和员工确认绩效计划。即，你和员工都要认同这个评估手段，所以很多公司的绩效计划都是要员工签字的。\n    归档并维护。可能会因为员工工作内容的重大调整，中期会有一些更新。\n    绩效评估。你需要对员工在本次绩效周期内的工作表现进行评估和打分。\n    绩效沟通。就绩效评估结果和员工进行沟通，达到对齐共识、辅导和激励的效果。\n\n2）摆正自己的心态\n    你是为整个团队负责，而不是站在对方的对立方\n\n3）谈绩效承上启下，着眼未来\n\n团队建设活动（TeamBuilding)\n\n第一个关于团建的误区：认为团建活动是万能的\n\n团队建设的初衷：\n1）以团队需要为初衷（期望通过团队建设，提升团队凝聚力、增强员工归属感等 打造团队文化价值观）\n2）以员工需要为初衷（调节放松或者打打鸡血，重点项目开工或者完工）\n3）以个人需要为初衷（管理任务，纯个人需要）\n\n以团队建设作为初衷的互动才是团队建设活动\n\n初衷不明晰表现在：\n\n1）初衷模糊--没有理清此次活动的目的（有了目的，才可以评判合不合适）\n2）初衷期望过高（团队建设六要素中，活动顶多对协作、文化有帮助；其他的例如个人能力、分工、梯队没有作用）\n\n第二个关于团建的误区：认为团建活动理所应当有好的效果\n\n应该结合你的团建目标，去好好的设计规划你的活动。\n\n第三个团建的误区：认为团建活动是HR、行政部门的工作\n\n1）团建的目标是你的团队的，不是HR团队的。收益归团队\n2）团建本身是有成本的（好多员工放弃了自己休息的时间来参与）\n\n“团建活动四问法”：\n\n第一问，关乎初衷：你是想做团建活动，还是调节放松，或是其他？\n第二问，关乎角色：是你想做团建活动，还是只想配合一下助理、HR 或行政的工作？\n第三问，关乎目标：你想达成团建的什么效果？默契还是文化？\n第四问，关乎手段：活动方案和你的目标匹配吗？\n\n---\n\n做事\n\n如何把事情做好，我们分三块：事前、事中、事后\n\n事前-轻重缓急\n\n重要紧急四象限，新的问题：如何判断一个事情重不重要、紧急不紧急\n\n重要：看收益，如果做了收益越大，越重要；紧急：看损失，如果不做，损失越大，越紧急。\n\n规划中，突发事件\n\n---\n\n事中-有效执行\n\n---\n\n事后-流程规范\n\n---\n商业的本职\n\n（1）吴晓波带你解读影响商业的50本书\n\n首先，你应该有完整的专业技术体系～\n\n知识\n\n技能\n\n态度\n\n如何打造一个优秀的组织\n\n个人能力篇\n\n1）沟通能力\n\n2）谈判能力\n\n3）演讲能力\n\n教养：对内的克制力，对外的分寸感\n\n职业化：商业世界有教养\n\n事实与观点\n\n行动 习惯 规律 行动\n\n知识层面\n\n管理 = 规划 + 带团队 + 做事\n    明确目标\n    了解你的团队或者小组\n    协调整合资源\n\n技能层面\n\n态度层面\n\n我为什么要需要\n\n（1）产品、运营、营销等方面的知识\n\n我们需要了解一件这些事情的本职，只有了解了本职，才能够更加聚焦。\n\n（2）心理学、消费心理学\n洞察人性\n在商业社会中，充分利用人性，来达成自己的商业目标\n在社会中，避免被别人套路，做出一些非理性的行为\n\n（3）国际形势、宏观经济、行业发展\n覆巢之下，焉有完卵？ 点线面体\n增长、\n\n（4）底层思维-哲科思维\n\n系统论\n变量 存量 增量\n关系：加强回路、调节回路、滞后效应、因果链\n\n逻辑学\n概念、三段论、同一律、矛盾律、排中律等\n\n结构性\n\n奋斗 挣扎\n\n原始舒适区 = 零认知\n\n自由 不等于 自在\n\n无知即极乐，有知即痛苦\n\n逃避自由，回归母体\n\n认知：认出世界的真实性和虚幻性\n\n给思维一个支点：问题不可能由导致这个问题的思维方式来解决。\n\n认知越狱 双环学习（单环学习）\n\n表述的不是世界，而是自己的世界观。\n\n思维模式的投射，自然而然，毫无觉察，左右着我们自己，\n\n提问题的能力，让我们避免掉进陷阱的一个很重要的前提条件\n\n提问，猜测，反驳\n\n正确的提出问题之前，答案是不存在的。\n\nmatrix: 矩阵，线性多一个维度\n\n矩阵式认知 洞穴比喻\n\n认知优势，极大的竞争优势\n\n商业：最经典的商业概念 （一个人与企业外部）\n\n    消费心理学\n    行为经济学\n\n    商业社会的5个基本逻辑\n\n    互联网的5个基本定律\n\n    宏观经济学/微观经济学\n\n    一家企业的具体商业行为：产品、定价、营销、渠道\n\n管理：最有效的实战管理方法（一个人与企业内部）\n\n    管理的人：人性、心理\n\n    如何招人\n\n    如何培养优秀员工\n\n    如何有效激励\n\n    如何把业绩目标拆为可以执行的任务分配下去\n\n个人：如何让自己变得更值钱（一个人与自己）\n\n    时间管理\n\n    快速学习\n\n    职业化习惯\n\n    演讲/写作\n\n工具：如何借助外力，提升前三者\n\n### 01丨商业篇：消费心理学(5讲)\n\n消费心理学主要研究消费者在消费活动中的心理现象和行为规律。它的目的是研究人们在生活消费过程中，在日常购买行为中的心理活动规律及个性心理特征。\n\n一起商业的问题，都是人的问题。\n\n（我想学习心理学的其中一个目的就在于此，与其说我想学习心理学，我更想学的是消费心理学）\n\n01 心理账户：从最有钱的那个心理账户花钱\n\n概念\n\n心理账户：分门别类的存放在不同的账户中\n\n案例：音乐会丢门票\n\n运用：场景（巧克力卖给爱人、装修方案帮用户省了4、5个平方）\n\n小结：改变顾客对你商品的认知，让他从不愿意花钱的心理账户，转移到愿意为此付费的那个心理账户中去。\n\n02 沉没成本：不要为打翻的牛奶哭泣\n\n概念\n\n沉没成本\n\n对沉没成本的损失厌恶\n\n案例：英法造飞机\n\n运用：场景（买衣服讨价还价、办豪华的婚礼、交定金）\n\n小结：沉没成本，无好坏；我们要利用其他人对沉没成本的厌恶来增加对自己有利的交易的成功率；并且尽量去客服这种心理，去做出更加理性的商业判断\n\n03 比例偏见：贵和便宜，是相对的\n\n概念：人们对比例的感知，比对数字的感知更加敏感\n\n小结：\n促销：价格低的商品打折-； 价格高商品用降价\n换购，用1块钱换购50元的郭，比例是500%  PK 买1000元的东西，送50快\n比较：\n\n04 规避损失：得到100元，可以弥补失去100元吗？\n\n损失规避：负面效应 是 正面效应的 2.5倍\n\n配送费 pk  包邮 +20元的价格\n\n以旧换新：对旧的东西的损失规避\n\n换购 替代 打折； 无理由退货：拥有了害怕损失；\n\n05 价格锚点：拉个垫背的，显示你便宜\n\n80元一小时 PK 105元1天（完胜！！）\n\n避免极端； 权衡对比\n\n### 02丨商业篇：五大基础逻辑(5讲)\n\n进入商业世界，你必须了解的五大基础逻辑：流量之河、倍率之刀、价量之秤、风险之眼和规则之缝。\n\n01 流量：比电商更先进的零售方式是什么？\n\n流量成本 = 流量价格 / 潜在用户数\n\n现在伴随着商户的增多，广告成本（不竞价排名，根本就就无流量）已经成为流量成本的大头，流量成本已经已经很高了\n\n其实除了电商，还有更多的流量涞源：直播带货、线下复购、私域流量、社群等，这些可能都比开网店便宜\n\n02 倍率：哪有什么一分价钱一分货\n\n定倍率：定价/成本\n\n化妆品：20～50； 鞋子衣服：5～10倍\n\n创新的话，就可以把定倍率定高；如果是效率的话，就把定倍率降低（出版设）\n\n03 价量：该把货卖得更贵，还是卖得更多？\n\n04 风险：风险可以买卖，但你必须有一双风险之眼\n\n05 规则之缝：黄牛，商业世界的黑客？\n\n### 03丨商业篇：五大基本定律(5讲)\n\n进入互联网世界，必须要学习的五大基本定律：信息对称、网络效应、边际成本、长尾理论和免费。\n（跟互联网产品、创业等紧密耦合）\n\n01 信息对称：在美国，你会吃麦当劳吗？\n\n02 网络效应：互联网与生俱来的洪荒之力\n\n03 边际成本：理论上，你可以服务全人类\n\n04 长尾理论：商业的未来是小众市场？\n\n05 免费：所有的免费，都是“二段收费”\n\n#### 04丨商业篇：行为经济学(5讲)\n\n行为经济学是将行为分析理论与经济运行规律、心理学与经济科学有机结合起来。听起来可能有些抽象，但实际上它的基本理论很简单：人类不是机器人。\n\n01 结果偏见：抓住老鼠的就是好猫？\n02 适应性偏见：为什么我们会喜新厌旧？\n03 鸡蛋理论：为什么妈妈们喜欢在朋友圈晒娃？\n04 心理概率：全世界一半的娃，都丑到了平均水平以下\n05 凡勃伦效应：不买最好，只买最贵\n\n05丨商业篇：微观经济学(5讲)\n\n微观经济学的研究方向：微观经济学研究市场中个体的经济行为，亦即单个家庭、单个厂商和单个市场的经济行为，以及相应的经济变量。\n\n01 供需理论：看见那只看不见的手\n02 边际效用：为什么麦当劳的可乐免费续杯？\n03 机会成本：你到底是赚了，还是赔了？\n04 激励相容：自私是共同获益的原动力\n05 交易成本：企业的边界在哪里？\n\n06丨商业篇：宏观经济学(5讲)\n\n宏观经济学，是以国民经济总过程的活动为研究对象，主要考察就业总水平、国民总收入等经济总量，因此，宏观经济学也被称做就业理论或收入理论。\n\n01 节约悖论：居民越节约，国家越贫穷吗？\n02 看得见的手：张维迎和林毅夫在辩论什么？\n03 人口抚养比：4亿人不工作后，你打算怎么办？\n04 泡沫经济：用20年的积蓄，买几朵郁金香\n05 再分配：你赞成给全中国人民无条件发钱吗？\n\n07丨商业篇：金融和法律(5讲)\n\n金融是一种交易活动，传统金融的概念是研究货币资金的流通的学科。而现代的金融本质就是经营活动的资本化过程。\n\n01 风险投资：最疯狂的心，和最冷静的脑\n02 合伙人制度：资本和人才，哪一个更重要？\n03 商品证券化：可以只买LV两个字，不买包吗？\n04 庞氏骗局：金融界的万骗之祖\n05 互联网金融：金融的本质，是风险买卖\n\n08丨商业篇：产品(5讲)\n\n产品是指能够供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。\n\n01 企业能量模型：你陪客户喝酒，是因为做产品没有流汗\n02 品牌容器：不被消费者优先选择的，不叫品牌，叫商标\n03 爆款：长尾爆款，才是真正的未来\n04 用户代言人：转身，成为用户的代言人\n05 最小可用品：用最快的速度、最低的成本犯错\n\n09丨商业篇：定价(5讲)\n\n定价策略，通常是影响交易成败的重要因素，同时又是市场营销组合中最难以确定的因素。\n\n01 渗透定价法：把自己逼疯，把对手逼死\n02 撇脂定价法：为什么手机越卖越便宜？\n03 组合定价法：自己装配汽车花的钱，能买12辆整车\n04 价格歧视：让有钱人为同一件商品多付钱\n05 消费者定价：定价权，能交给消费者吗？\n\n\n10丨商业篇：营销(5讲)\n\n市场营销是指，企业发现或挖掘准消费者和众多商家需求，从整体的营造以及自身产品形态的营造去推广、传播和销售产品，主要是深挖产品本身的内涵，切合准消费者以及众多商家的需求，从而让消费者深刻了解该产品进而购买的过程。\n\n01 定位理论：占领市场之前，占领心智\n02 饥饿营销：金杯银杯，不如排队的口碑\n03 技术采用生命周期：跨越死亡之井\n04 危机公关：撒硬谎，道软歉，就是作死\n05 独特销售主张：只溶在口，不溶在手\n\n11丨商业篇：渠道(5讲)\n\n渠道通常是指商品销售路线，是商品的流通路线，所指为厂家的商品通向一定的社会网络或代理商而卖向不同的区域，以达到销售的目的。\n\n01 深度分销：进入市场的毛细血管\n02 销售激励：如何把销售变成虎狼之师？\n03 全渠道营销：把一切的触点，发展为渠道\n04 社区商务：离消费者越近，越有价值\n05 反向定制：根治“库存”顽疾的最有效方法\n\n12丨商业篇：互联网营销(5讲)\n\n互联网好比是一种“万能胶”将企业、团体、组织以及个人跨时空联结在一起，使得他们之间信息的交换变得“唾手可得”。市场营销中最重要也最本质的是组织和个人之间进行信息传播和交换。\n\n01 社群经济：自带高转化率的流量\n02 口碑经济：自带流量的粉丝\n03 单客经济：终生免费的流量\n04 引爆点：像病毒一样传播\n05 红利理论：会冲浪的人，必须也要会游泳\n\n13丨商业篇：商业视野(11讲)\n\n如何在现实生活中熟练使用前面学到的商业知识，是我们要修炼的内功。因为每一件事情背后，都有其商业逻辑。\n\n01 对赌基金：每一件事情背后，都有其商业逻辑\n02 雇佣客户：让客户帮你管理员工\n03 农耕式经营：你是在狩猎，还是在农耕\n04 打开慧眼：美国有没有互联网思维\n05 社会责任：用商业的理念做公益的事业\n06 去中心化：商业的世界，必须要有一个中心吗？\n07 零边际成本社会：未来会不会所有商品都免费？\n08 人工智能：你的工作，会被人工智能取代吗？\n09 奇点临近：据说2045年，“奇点”将要临近？\n10 基因技术：如果你能活120岁，你打算如何规划人生？\n商业篇总结｜70个即学即用的商业套路，全在这儿了\n\n14丨管理篇：管理的本质(5讲)\n\n管理是一种有价值和道德取向的工具，它的对象是人所进行的工作，因此管理者一定要与人打交道，他们必须面对包括他们自己在内的人性的善与恶。\n\n01 激发善意：尽力来自于本份，尽心来自于善意\n02 设计系统：分钱，花钱，赚钱\n03 知人善用：把合适的人，放在合适的位置上\n04 反求诸己：发而不中，行有不得，反求诸己\n05 面向业绩：梦想归梦想，绩效归绩效\n\n15丨管理篇：组织和激励(10讲)\n\n激励机制是指通过特定的方法与管理体系，将员工对组织及工作的承诺最大化的过程。\n\n01 马斯洛需求理论：激励就是发现需求，满足需求\n02 双因素理论：从“应得的”到“太好了”\n03 期望理论：“跳一跳，够得着”的奖励，才是激励\n04 X-Y理论：左手激励 ，右手压力\n\n胡萝卜加大棒\n\n坚守底线（有些错误可以犯，但有些例如道德缺失这种不可容忍）\n提高要求（工作目标，必须要跳一跳才能够够得到；工作任务，一定要好好管理好时间才可以完成）\n    松弛的工作状态，轻松的目标，容易让人懈怠松散\n赏罚分明，赏罚要及时，当众\n\n05 公平理论：工资是否应该透明？\n\n员工的激励程度源于自己和参照对象的报酬和投入的比例的主管比较的感觉。\n\n内部公平\n    建立专业的薪酬福利体系（薪资对应责任、奖金对应绩效、股权对应潜力）\n    仅制定规则，不具体分配奖励\n外部公平\n    同时保证内外不公平很难，薪资倒挂问题\n个人公平\n    规则清晰，赏罚分明，把权利锁在笼子里\n\n总之，用严明的规则，给员工公平感和安全感。\n\n06 责权利心法：老板做员工的事，员工讨论国家大事\n\n在任何一个管理单元上，权利、责任、利益，这三件事情必须要同时、对等的发生在一个主体身上。\n\n权利独大，将会导致权力寻租（不带责任的徇私舞弊）\n利益独大，就会引发内耗冲突（肥缺，抢资源，分业务）\n责任独大（权力小、利益小===》 消极怠工）\n\n07 分权机制：考核结果，还是考核行为？\n\n美国，联邦制国家，中央政府下的每一个州，又是一个独立的主权单位（不违背宪法），对州的“最终结果”负责。---联邦分权\n每一个州政府下面，立法、行政、司法三权分立。每一个部门对自己职能范围内的“自身行为”负责。---职能分权\n\n职能分权：执行简单，容易专注，效率很高，但是对管理要求高\n联邦分权：考核简单，容易激励，主动性高，但是对员工要求高 ----- 独立的电商失业部门\n\n自身行为与最终结果的因果关系是否明显，有没有必然的因果关系\n如果明显，很容易根据结果反推行为，那么采用职能分权制\n如果不明显，采用联邦分权制，例如销售，分地区，分行业。\n\n08 组织模式：羽毛球双打、足球队、交响乐队，还是军队？\n\n组织模式：把职能分权、联邦分权两个基本单元组合在一起的方式。\n\n羽毛球双打：联邦分权制，信任\n足球队：职能分权制，战略打法\n交响乐队：职能分权制，人数很多，上百人，靠的是流程\n军队：职能分权制，人数更多，靠的是奖惩\n\n09 阿米巴模式：内部市场化的组织模式\n\n内部定价的管理体系：需要有一个类似于发改委的机构，尽量公允的给每一个部门的服务定价\n基于职能部门的利润和总的工作时间，计算出单位时间利润，作为核算制度\n利润之心，员工收益与公司整体利益挂钩，而不是完全与阿米巴的绩效挂钩\n\n10 手表定律：一个员工，不能有两个老板\n\n手表定律，不知道听谁的\n\n设计组织的两个原则：\n（1）一个上级原则-创业中一定要有绝对控制人\n    超级指挥，领导的领导找你干事。\n（2）一致管理原则\n    不仅受流程管理，还受流程（流程执行平等）、绩效指标  的管理；所以切莫有冲突\n\n16丨管理篇：知人善用(20讲)\n\n企业的组织结构设计实质上是一个组织变革的过程，它是把企业的任务、流程、权力和责任重新进行有效组合和协调的一种活动。\n\n01 变招为抢：找人，是天底下最难的事情\n\n抢人、求人\nCEO（COO成熟期运营，CSO转型期战略，CHO初创期人才)\n转变心态，变招为抢\n\n02 套娃现象：不用比自己优秀的人，企业将走向衰落\n\n善用比我们更优秀的人\n为什么喜欢招不如自己的人：\n（1）不安全感，担心自己被替代（2）容易沟通，容易高效率的做低效效果的事\n\n如何解决：\n（1）给人以安全感\n（2）解决制度问题\n    直属经理的上级参与面试，做最终决策\n    设定用人标准，高于团队平均水平\n    直属经理连续两次选人失误（新进员工垫底10%），则扣除奖励\n（3）解决自身问题（CEO是最大的套娃）\n\n03 态度和能力：鱼头美女身，美女头鱼身，你选哪一个？\n\n想干 X 能干  = 态度 X 能力 = 绩效\n态度决定一切（改变态度的难度要远远大于改变能力）\n\n![态度能力四象限](http://cdn.b5mang.com/2021217232054.png)\n\n04 拒绝面霸：面试的巨人，行动的矮人\n\n面试官的三个心理缺陷：\n首因效应（避免让面霸先入为主）、光环效应（避免“以貌取人”、“以简历取人”，避免以偏概全）、近因效应（对最后一个或者说面试的最后部分印象最强烈）\n\n（1）岗位说明书（职责是什么、需要的能力是什么）\n（2）制度（多轮面试、罗列每一项能力需要的题目，避免面试官随意发挥）\n（3）面试培训\n\n05 面试公关：你们说回去等消息，后来给消息了吗\n\n有面必答、尽量委婉、期待未来、统一回复\n\n为什么招聘 \n（1）短期、解决业务/运营或者技术问题\n（2）中期、实现业务/运营或者技术目标\n（3）长期，确认业务/运营或者技术远景\n\n基于业务倒退，需要什么组织和岗位，以及什么样的经验（必须的）与能力（基于经历与成就来推断）\n\n06 蘑菇定律：谁跟我谈战略，我开除谁\n\n培养新人\n\n1. 做务实的事情（从最基本的事情做起）\n2. 给足够的养分（选择合适的小蘑菇，然后有计划的轮岗培训）\n\n年轻的基层新员工，能力不强，自视清高。\n\n07 师徒制：有人敢欺负你，就报我的名字\n\nmentor让你更快的融入公司\n\n（1）严格设计制度\n\n08 情境管理：他是钉子你用锤子，他是螺丝你用改锥\n09 鲶鱼效应：用危机和竞争，激活团队\n10 贝尼斯定理：让员工的脚步，跟上你的思路\n11 不值得定律：你是想卖一辈子糖水，还是改变世界\n12 懒蚂蚁效应：懒，是因为勤奋到没时间\n13 热炉法则：把自己的权力关进笼子里\n14 拜伦法则：你那不叫授权，你那叫授责\n15 波特定律：扔掉心中的错误放大镜\n16 员工流失率：没解雇过员工，不是好管理者\n17 职业生涯：你的公司有“户口制度”吗？\n18 酒与污水定律：给你的组织，装一个净水器\n19 离职面试：多一个朋友，少一个敌人\n20 前员工：你的公司有“前员工俱乐部”吗？\n\n17丨管理篇：反求诸己(15讲)\n\n管理之道惟在用人。人才是事业之根本，可以说得人才者得天下，失人才者失天下。\n\n01 古狄逊定律：人生中的第一个管理问题\n02 权力接受论：权力不是领导给的，权力是员工给的\n03 任务分解：不会把目标翻译成任务，要你何用？\n04 推功揽过：打妖怪你去，背黑锅我来\n05 刺猬法则：亲密，但是不能无间\n06 独立损益表：你的部门，有必要存在吗？\n07 奥卡姆剃刀定律：如无必要，勿增实体\n08 管理六字真言：抓大、放小、管细\n09 关键绩效指标：坐进你的管理驾驶舱\n10 目标管理：不但要锁死目标，更要锁对目标\n11 企业三法宝：愿景、使命、价值观\n12 战略思考：不要用战术的勤奋，掩盖战略的懒惰\n13 组织：就是信息流动的方式\n14 决策理论：如何做出好的决策\n15 平衡艺术：这不是一个坏问题，但我没有一个好答案\n\n18丨管理篇：面对业绩(5讲)\n\n管理者如果要提高组织的效率，首先要有具体的效率标准作为衡量的依据，主要包括管理队伍的规模、素质和结构。\n\n01 项目三角形：优质、快速或廉价，只能选两样\n02 六西格玛：变态的质量，源自于变态的过程管理\n03 财务报表：能用数字讲故事的三张报表\n04 风险管理：悲剧里挖出来的学问\n05 向上管理：你敢管理你的老板吗？\n\n19丨管理篇：管理误区和企业周期(11讲)\n\n创业管理不同于传统管理。它主要研究企业管理层的创业行为，研究企业管理层如何延续注入创业精神和创新活力，增强企业的战略管理柔性和竞争优势。\n\n01 破窗效应：无序邀请无序，混乱引发混乱\n02 旁观者效应：责任除以二等于零\n03 帕金森定律：“大企业病”有得治吗？\n04 彼得原理：别把晋升当激励\n05 墨菲定律：只要可能出错，就一定出错\n06 企业生命周期：向着悬崖狂奔\n07 管理阶段：别把正确的方法，用在了错误的阶段\n08 共同体：降一半工资，委以重任，你干吗？\n09 创业管理：因为你是微软的，所以减一分\n10 永续经营：长生不老，不如养儿防老\n管理篇总结｜65个最有效的实战管理方法，都在这儿了\n\n20丨个人篇：高效能养成(15讲)\n\n好的习惯\n\n01 思维转换：你可能连杯子都要换掉\n    改变自己的思维方式\n02 成熟模式图：独立，是不成熟的表现\n    作为个体，我们需要从依赖父母，成长为独立个体\n    作为社群团体，我们需要与团体中的他人，互赖\n03 积极主动：别让消极，把你拉入海底\n    选择态度的自由，不要把问题归结为外部（环境、他人）\n04 以终为始：别把追求成功的梯子，搭错了墙\n    目标、原则、计划\n05 要事第一：我不忙，我只是时间不够\n    事情的重要性、优先级\n06 双赢思维：我要赢，你也要赢，否则就别干\n    非零和博弈，可以双赢\n07 知彼解己：先理解别人，再被别人理解\n    了解别人，让别人舒服；站在对方的去思考\n08 统合综效：天啊，太棒了，居然还可以这样\n    最终的结果，1 + 1 > 2? \n09 不断更新：把优秀，变成一种习惯\n10 思维习惯：从狭窄的5%，跨度到广阔的95%\n    大多数靠反射，小部分靠思考； 我们需要可以联系，让好的行为成为习惯。\n11 时间成本：到底是花时间做，还是花钱买？\n    你需要意识到，时间是有成本的；机会成本\n12 GTD:让大脑用来思考，而不是用来记事\n    Get Thing Done. 通过知识管理工具来管理所有事情，大脑只是用来思考\n    把事情分为六大类：删除/素材/代办/？\n13 猴子理论：多问一句“你觉得呢？”\n    权责利，不要让所有的事情，都堆在你身上。\n    不要让下属把责任甩到你身上，你只是负责做选择。\n14 三八理论：人生的不同，是由第三个8小时创造的\n    时间粒度30分钟，还是分钟（比尔盖茨）\n15 番茄工作法：人，真的可以三头六臂吗？\n    无打扰时间的稀缺\n\n21丨个人篇：职业素养(6讲)\n\n01 微信礼仪：再问“你好，在吗”，我就拉黑你\n02 邮件礼仪：这辈子，你们只会在邮件里“见字如面”\n03 时间颗粒度：是一个人的职业化程度\n04 事实和观点：事实有真假，观点无对错\n05 职业化：就是商业世界的教养\n专题总结：如何快速实现职业化的转变？\n\n22丨个人篇：学习能力(5讲)\n\n01 幸存者偏见：看不见的弹痕最致命\n02 库伯学习圈：知识，是经验的升华\n03 知识技能态度：为什么人类不擅长谈恋爱？\n04 私人董事会：作为自己的CEO，你有“私人董事会”吗？\n05 快速学习：如何用20小时，快速学习？\n\n23丨个人篇：逻辑思考力(10讲)\n\n01 六顶思考帽：从对抗性思考，到平行思考\n02 批判性思维：大胆质疑, 谨慎断言\n03 全局之眼：冻死在那个不存在的冬天\n04 逆向思维：电吹风的反面，是吸尘器\n05 正向思维：做一个“因果逻辑收集者”\n06 同一律：白马到底是不是马？\n07 矛盾律：理发师的头是谁理的？\n08 排中律：生存，还是毁灭，没有中间状态\n09 三段论：一眼识别诡辩的五个方法\n10 归纳法：几乎所有的知识，都始于归纳法\n\n24丨个人篇：谈判策略(10讲)\n\n01 定位调整偏见：自己先开价，还是让对方先开价？\n02 权力有限策略：你的这个要求，我要请示一下\n03 谈判期限策略：女生为什么会逼婚？\n04 出其不意策略：击穿对手的心理防线\n05 双赢谈判：我多拿一元，你就必须少拿一元吗？\n06 同理心：千般能力的共同心法\n07 自我认知：不偏不倚的自我认知\n08 自我控制：自律即自由\n09 自我激励：真正优秀的人，都自带鸡血\n10 人际关系处理：你的情感账户余额不足，请充值\n\n25丨个人篇：沟通演讲(10讲)\n\n01 认知台阶：你不是在讲，你是在帮助他听\n02 画面感：用画面感，增加语言的带宽\n03 开场和结尾：精彩绝伦的开场，和余音绕梁的结尾\n04 即兴表达：现场组织语言能力，是你的厨艺\n05 演讲俱乐部：从对着镜子，到对着活人\n06 快乐痛苦四原则：我有一个好消息，一个坏消息，你先听哪一个？\n07 写作心法：如何写出一篇好的专栏文章？\n08 电梯测验：大WHY，小WHAT，和一带而过的HOW\n09 如何开会：开会，是一个用时间换结论的商业模式\n10 精准提问：是沟通界的C2B\n\n26丨个人篇：创新与领导力(11讲)\n\n01 减法策略：灵感，其实就在你的盒子里\n02 除法策略：冰箱和空调，可以变成一个产品吗？\n03 乘法策略：空气清新剂 x 2 = 提神清新剂\n04 任务统筹策略：向《火星救援》，学创新套路\n05 属性依存策略：给属性装上一根进度条\n06 专注：藏在“威胁、此刻、重要”后的大猩猩\n07 集中：你是小公司里的胖子，还是大公司里的瘦子？\n08 变革：透过时间轴、概率轴、和博弈轴看世界\n09 快速：天下武功，唯快不破\n10 远见：是尽可能接近未来的推理能力\n个人篇总结｜65个“让你更值钱”的习惯养成方法，都在这儿了\n\n27丨工具篇：战略工具(10讲)\n\n君子性非异也，善假于物也。\n\n01 MECE法则：透过结构看世界\n\nMECE: 不重不漏\n几个原则：谨记分解的目的（分解是在哪一层进行的），避免层次混乱，借鉴已有成熟模型\n\n02 波特五力模型：一家小龙虾餐厅面对的五种竞争作用力\n\n直接竞争对手：现在的竞争对手多吗？是不是已经过度竞争了？\n顾客：顾客形成联盟，会对商家带来巨大的谈判压力，从而压缩自己的谈判空间\n供应商：自己在供应商那里是否足够重要，越重要，议价空间越大\n潜在新进公司：储值卡，增加用户迁移成本\n替代性产品\n\n03 波士顿矩阵：你的公司有现金牛，明星，问题，和瘦狗吗？\n\n公司想要成功，必须拥有市场增长率与市场份额各不相同的产品组合\n\n![波士顿矩阵](http://cdn.b5mang.com/2021218181032.png)\n\n发展战略、保持战略、收割战略、放弃战略\n\n04 SCQA架构：你不是没有重点，你是没有结构\n\n结构化表达工具-情景（Scene）-冲突（Complication）-问题（Question）-答案（Answer）\n\n05 通用电气矩阵：打不赢你，那我就怼死你\n\n![通用电气矩阵](http://cdn.b5mang.com/2021218185227.png)\n\n06 正态分布&幂律分布：你喜欢倒钟型行业，还是尖刀型行业？\n07 PEST模型：趴下来仰视微观之前，先站起来俯视宏观\n08 平衡计分卡：你想要鹅下蛋，还是吃鹅肉？\n09 SWOT分析：如何用科学的方法，追到女神\n10 商业模式画布：商业模式就是“你怎么挣钱”吗？\n\n28丨工具篇：博弈工具(10讲)\n\n为什么要学习博弈工具呢？\n\n01 纳什均衡：明明可以“共赢”，为什么他们“损人不利己”？\n    制度设计 来打破 纳什均衡（非帕累托最优）寡头的价格同盟\n    信息不对称、信任不对称\n02 囚徒困境：向香港电影学习如何破解“囚徒困境”\n03 智猪博弈：不懂搭便车，你连小猪都不如\n04 公地悲剧：三根救命毫毛，为何只给孙悟空？\n05 重复博弈：诚信是一种与这个世界重复博弈的心态\n06 不完全信息博弈：你有你的“空城计”，我有我的“木马计”\n07 拍卖博弈：让时间最不值钱的旅客下飞机\n08 博弈游戏：博弈游戏，有时也是吃人的陷阱\n09 零和博弈：吃着碗里的，看着锅里的，想着田里的\n10 一报还一报：用惩罚回报恶行，用善行回报善行\n\n29丨工具篇：决策、管理、思考(15讲)\n\n决策是什么？决策是在多个选项中选择最优的过程（最优：短期最优、长期最优、效用的量化）\n要结合目标、价值观等\n\n关于目标：\nOKR的本职是一个工具\n如何确保我们的目标能够完成？每一个人都知道自己下一步要做什么？我们需要OKR，让大大家形成合力\n\nSMART本质上是一个原则，用来衡量目标好坏的原则；避免对一个目标的看法千人千面。\n\n需要完成一件事情时，我们可以有PDCA模型来帮我们\n关于质量（出现了各种各样的问题，我们需要按照某一个节奏解决）\nPDCA，确保可以持续改进，让质量越来越好；\n\n思考工具：\n头脑风暴（当思考遇到了苦难，不知道如何进行下一步时，发散思维）\n思维导图（思考如何达成一个目标，而没有特定思路时）\n5W2H 思维不够缜密时（找到问题） + 5WHY（分析问题）\n二维四象限图\n\n01 决策树：如何用决策树来选择相亲对象？\n    决策树（是否，有哪些选择）、概率树（结合概率与期望）\n02 德尔菲法：70年前发明的高科技：人脑云计算\n    群体观点的收敛，例如概率树中提到的概率和数字等（可不能拍脑袋想出来）\n    进行各种预测活动时，可以考虑使用该方法（给出自己的预测值、以及原因；多次收敛）\n03 KT法：把决策的艺术，变成一门技术\n    当你遇到一个问题，想要解决这个问题时\n    状况分析（了解现实与预期的差距）、问题分析（3W1E法，是..而不是..)决策分析（做出假设，利用矛盾律，排除不可能的假设）、潜在问题分析\n04 麦穗理论：如何选择人生中最大的那支麦穗？\n    基本最满意原则（最初1/3时间观察，中间验证，最后决策--越到的最好）\n    37%理论（一个长时间的报价项目，如何找到将来的最低价？）\n05 基于数据决策：决策，就是与这个世界的博弈\n    数据：信息的载体；用数据来说话，数据分析\n    统计来获取显性数据；调查来获取隐形数据\n\n06 OKR：KPI是秒表，OKR是指南针\n    目标管理工具-主要确保目标可以完成（聚焦，拆解，量化）\n    OKR是目标管理工具，主要目的在于让一个无法用数字考核的团队，通过层层分解的目标与关键任务，向同一个方向前行。\n    Objective KeyResult\n    OKR不是绩效考核工具，并不能解决绩效考核问题。\n    KPI是绩效考核工具，但他不是万能的；因为有些绩效是不可量化的，只能主观评分，比如360度环评。\n    360度环评：通过多方均衡，让主管评分，尽量接近客观。\n\n    实施OKR的四个关键：\n    （1）目标要有野心，关键结果要可衡量\n    （2）最多五个目标，每一个目标最多5个关键结果，要聚焦\n    （3）从公司到团队到个人层层分解\n    （4）所有OKR公开、透明\n\n    https://xueqiu.com/7279068449/148626561\n\n【技术】《聊聊后端程序员的知识体系》\n【技术】《成为一个出色的工程师，做到这几点就够了》\n【思维】《高效能人士的7个习惯》\n与团队成员进行1v1沟通，了解成员性格与团队需求\n\n07 SMART原则：有“OKR”这把刀，更要有“SMART原则”这套刀法\n\n    示例：O（目标）：打造业务最好的产品\n    KR1(关键结果1)：持续提高产品质量\n    KR2(关键结果2)：不断创新，增加新功能\n    KR3(关键结果3)：听取最终用户意见，提升满意度\n\n    针对以上OKR打分，不同的人会给出不同的评分，原因在于目标不符合SMART原则\n\n    KR1(关键结果1)：持续提高产品质量\n\n    目标一定要Specific(具体的)，不可模棱两可\n    问题：什么叫产品质量？没有具体的界定，就无法评判、衡量与执行。\n    新的KR: 消灭致命缺陷数；降低严重的产品缺陷数；提高应用商店app评分\n\n    目标一定要Measurable（可衡量的），对标准不可有争议\n    问题：提高多少评分，降低多少数量？\n    新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app评分从4.0提升到5.0\n\n    目标一定要Attainable（可实现的），目标不能不切实际，跳一跳要能够得着\n    问题：评分5分的app存在吗？\n    新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app评分从4.0提升到4.5\n\n    目标一定要Relevant（相关的），目标不能与自己的工作无关\n    问题：app提升到5分，一定和产品质量提高有关系吗？是不是其他新功能或者外观导致呢？应用质量与app评分有相关性，但是不够强。\n    新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app store的差评中，汇报产品缺陷的比率减少50%\n\n    目标一定要Time-Based（有时间限制的），目标不能无限拖延\n    问题：完成上面的目标需要多久呢？1年吗？还是几个月？\n    新的KR：致命缺陷数保持为0；严重缺陷数在三个月内减少50%；app store的差评中，汇报产品缺陷的比率在三个月内减少50%\n\n08 PDCA循环：交待给你的事办完了，就不能回个话么？\n    Plan-Who Do What by When, Do, Check, Act(未解决新出现的问题，归入下一个循环)\n    如何去色的完成一件事情：质量管理，持续改进\n09 项目复盘：把所有的经验教训，都变成组织能力\n    回顾目标：准确客观的目标 + 阶段性的里程碑\n    评估结果：准确、客观；可以分为两个方面\n    原因分析：成功：客观原因；失败：主观原因\n    总结规律：隐形知识显性化（经验+分析=》规律=》TODO/NotTODO）\n\n10 MBTI：MBTI是算命，娱乐，还是性格测试？\n    某种性格测试，用来了解自己、了解员工；从那些维度来看：\n    心理能量的获取（独处OR社交）信息获取（真实OR抽象）决策方式（逻辑客观OR情感）生活态度（积极OR消极）\n\n11 头脑风暴：用数量带动质量，用点子激发点子\n    自由思考、延迟批评、以量求质、结合改善\n\n12 思维导图：你是用它记笔记，还是把它当作思考工具\n    先从目标开始，自由天马行空\n\n13 5W2H法：集齐七个问题，让思维更缜密\n    步骤化清单化（What， Where, When, WHo, How Musch, Why)\n\n14 5WHY法：追问5个为什么\n    找到正确的问题（根因）区分原因与借口（客观原因、主观借口）\n\n15 二维四象限：太极生两仪，两仪生四象\n    非此即可的二分法 =》从两个对立统一的重要属性作为依据，分情况讨论\n    让思维更加完整、辩证\n\n30丨工具篇：沟通工具(5讲)\n\n当沟通效率低下时，我们针对沟通效果不好进行拆解，可以归结为以下原因：\n传达不畅通(1v1, scrum)\n传达失真 (视觉会议，一些图表工具)\n沟通无法聚焦（罗伯特议事规则）\n沟通效率低下（地理位置、时间上的错配，导致沟通效率不足）\n01 一对一会议：请把和下属的1:1会议，放入日程表\n    核心点：定期沟通、自下向上，倾听为主\n03 Scrum：\"死磕自己\"是种精神，但更是种方法\n    本质上这是一种项目管理流程，用于来冲刺完成某些关键项目！\n    也是一种沟通方式，通过这种沟通方式，来定期同步每一个sub item遇到的一些问题（进度延误、遭遇困难等）\n02 罗伯特议事规则：如何用“十二原则六步法”开好一个会\n    会议：用时间换效率（达成结论、信息广播周知）当开会的沟通效率很低时，可以参考。\n    会议，是一种特殊的沟通方式-一种类似于广播的沟通方式\n04 视觉会议：让右脑一起来开会\n    尽可能的用图表（逻辑结构、时间顺序、思维的发散过程）来呈现要表达的内容，来减少沟通中发生的歧义曲解\n05 作战指挥室：外部越是剧烈变化，内部越要集中办公\n\n31丨工具篇：高效率工具(11讲)\n\n01 白板：如何随时随地、无边无际地思考？\n02 移动办公：整个世界都是你的办公室\n03 电子书：你每年读的书，有100本书吗？\n04 知识管理：用软件帮助收集篮“大肚能容”，吃尽知识\n05 云服务：任何时候任何地点，通过任何设备，访问任何文件\n06 搜索工具：人生80%的问题，早就被人回答过\n07 邮箱日历联系人：把基本功，耍得虎虎生风\n08 协同软件：如何避免与懒惰握手言和？\n09 休息运动：如何最高效地休息，和运动？\n10 我的一天：君子性非异也，善假于物也\n工具篇——50个让你提高效率的工具，都在这儿了\n"},{"title":"量化交易","url":"/invest/quota_os.html","content":"\n如何选股：\n一种方法就是你觉得哪个公司产品好，你就重点的去考虑哪个公司的股票。\n"},{"title":"知识体系","url":"/底层思维/knowledge_arch.html","content":"\n用一年的时间去为将来的创业作准备\n\n创业需要什么？\n\n1. 靠谱的团队\n2. 优秀的产品\n3. 过硬的管理\n\n所以，我们需要通过**有目的的**去学习如何去做好下面几点：\n\n1. 如何去做一款优秀的产品？\n\n2. 如何去做好管理工作？\n\n3. 如何才能快速搭建自己的团队？\n\n4. 如何去更好的理财？\n\n<!-- more -->\n\n以上问题，我们应该有自己的行动准则、方法论；同时，要知道每一个方法论的底层理论。\n不抽象，就无法深入思考；不还原，就无法看清真相。\n\n让自己有能力去管理一个团队，去带一块业务。\n\n首先需要去了解业务\n\n创业靠的是什么？\n\n每天花一个小时\n去反思：每天做的事情，哪些事情可以不做，哪些事情一定要去做。\n去沉淀：每天所学的东西，将每日所学纳入自己的知识体系。\n\n每日思考得以进行的前提：\n\n1. 已经有自己的知识体系\n2. 有自己的价值观体系\n\n理想中的自己是怎样的？\n\n跨界思维\n\n## 知识管理\n\n我们可以把自己平常接触到的知识，按照知识浓度，分为四种：经历、经验、方法、理论\n\n“低水平勤奋陷阱”\n\n读书方法的升级：在新旧知识间建立联系。\n\n大脑的记忆，靠的是将信息与旧经验联系起来。\n\n我的临界知识：\n\n复利效应\n\n经济学原理：\n\n以物易物：人们不通过货币中介，彼此直接交换物品和服务。\n稀缺：人的欲望超过能满足欲望的可用资源。稀缺是普遍存在的事实，从而要求人们进行交换。\n取舍：由稀缺导致的不尽如人意的现实，鱼和熊掌不可兼得。VS CAP理论中的取舍？ 架构中的取舍\n\n有目的的行动， 无意识的行为\n大脑 不同于 意识\n\n公理化证明，欧几里得的几何学\n\n1. 基于某个公理，通过演绎推理，得出结论\n2. 不需要通过实践去校验\n\n经济学推理的基本假设：社会事件是由人有目的的行动驱使的；\n\n社会科学 自然科学\n研究对象的自主意识，很难做控制实验\n\n只有个人才行动；\n偏好是主观的，是一种排序，不能量化；不同人的偏好不能相加\n人们利用世界的一部分来达到自己的目的。哲学家将此描述为：人们使用手段来达到目的。经济学家的描述则是：人们利用物品和服务来满足偏好。\n效用：用来描述人从一件物品或者服务中获得的价值\n\n必须先弄明白他有哪些资源可以利用。我有哪些资源？我在公司有哪些资源？公司有哪些资源？\n管理才能：经济的使用稀缺的资源（稀缺性的最显著特征是涉及取舍）\n\n东西object 如何 变为 物品good，需要三个条件：\n\n1. 某个东西能够帮助人达成目的\n2. 人希望达到某个目的\n3. 人知道条件1\n\n消费品\n生产品：生产要素、生产资料，具体细分：\n\n1. 土地和自然资源（大自然）（永久性、损耗型）\n2. 劳动力（休闲、劳动、劳动的负效用）只有当通过劳动能间接地达到更重要的目的时，人们才原意牺牲休闲来进行劳动\n3. 资本品（由人创造出的生产要素）\n\n劳动的负效用：经济学家的术语，用来描述人更愿意休闲而不是劳动的事实。人之所以会去劳动是为了获得间接的回报\n\n生产率：一件生产要素在一段时期内的产量，通常特指劳动力。\n\n收入：人在一定时期内获得的新增消费品与服务的产出\n储蓄：如果人的消费量少于其全部收入，即产生储蓄，所谓“量入而出”。\n投资：当生产要素被用于生产未来的收入，而不用于生产当前消费时，即产生投资\n\n边际效用：物品按单位估价：\n人们评估物品的价值，不是按照物品的整个类别，而是按照物品的单位来进行。用经济术语来说，人们对物品的估价基于边际效用。\n\n收益 超过 成本\n机会成本，它被定义为主体为了某项选择，而不得不放弃的次优选择带给他的价值\n\n一切行动都是由预期（信念 和 偏好）引导的。预期是指他对未来的预测。当然，预期可能是错的。\n\n交换：满足每一个人的偏好\n"},{"url":"/smart/bit_mouse.html","content":"## 脑筋急转弯\n\n脑筋急转弯，1000桶牛奶，1桶有毒，用10只小白鼠试出来。其实就是二进制，网上有答案，提示：2^10 = 1024"},{"url":"/ai/recommend/common_recommend.html","content":"向量空间-推荐\n\n欧式距离\n\n基于相似用户的推荐\n\n收集了用户A足够多的资料后，给他推荐跟他最相似的人B使用的产品中，A没有用过的；\n\n如何判断人的相似？ 类聚问题\n\n基于相似歌曲的推荐\n\n如何判定两个歌曲相似呢？ 如果听A的人，与听B的人查不多，那么A跟B查不多。"},{"title":"领域驱动设计","url":"/backend_knowledge_architecture/design/ddd.html","content":"### 领域驱动设计目的\n\nDDD帮助我们拆解需求，并建立一个***灵活性高、可扩展***的业务系统\n\n领域驱动设计中的领域是什么？我理解的是一个比行业更加细分的方向，比如互联网做电商业务是电商领域，电商中有专注交易的交易领域，做电子支付叫支付领域。领域范围可大可小，领域知识表示某些具有相关相关性知识的合集。\n\n领域驱动设计是通过领域知识构建的领域模型来控制业务的复杂性，通过领域模型反映领域知识，构建更易维护的系统。解决软件难以理解，难以演化的问题。\n\n---\n\n在做架构设计时，一个好的架构应该需要实现以下几个目标：\n\n独立于框架：架构不应该依赖某个外部的库或框架，不应该被框架的结构所束缚。\n\n独立于UI：前台展示的样式可能会随时发生变化（今天可能是网页、明天可能变成console、后天是独立app），但是底层架构不应该随之而变化。\n\n独立于底层数据源：无论今天你用MySQL、Oracle还是MongoDB、CouchDB，甚至使用文件系统，软件架构不应该因为不同的底层数据储存方式而产生巨大改变。\n\n独立于外部依赖：无论外部依赖如何变更、升级，业务的核心逻辑不应该随之而大幅变化。\n\n可测试：无论外部依赖了什么数据库、硬件、UI或者服务，业务的逻辑应该都能够快速被验证正确性。\n\n### 领域驱动设计的核心价值\n\n『领域的边界划分不断演绎，只要发现复杂性凝聚的地方，就划定为有界上下文，割裂它与其他系统的关系，并派出精兵强将专门对付。』\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdGEyLWltZy5jbi1oYW5nemhvdS5vc3MtcHViLmFsaXl1bi1pbmMuY29tLzZlMGM3OTEwZDgwYmE3ZDUyNWNjYzM5ZmUwMmI0MmYyLnBuZw)\n\n领域驱动设计的核心目标是基于特定业务范围，通过统一业务概念（统一语言），将系统参与各方整合在一起，从而减少不同角色和环节的信息熵减问题。\n\n领域模型是领域驱动设计的核心产出，它不仅能描述真实的业务逻辑和业务场景，也是系统实现的表达方式。领域模型的适应性能直接反应系统的扩展性上，能否使系统在增大时仍然保持敏捷。\n\n领域驱动设计之所以更加流行，**很大因素是领域驱动设计提供的方法论上与近些年流行的微服务有很好的匹配性**，通过领域驱动设计方法清晰地**识别业务边界，以此来指导微服务的拆分**。 领域驱动设计提供的领域划分方法可以指导我们对微服务的拆分，以及对于演进式架构有很强的助力。\n\n![概念的涵盖范围](https://noogel.xyz/resource/img/2021-12-12-18-59-11.png)\n\n### 方法论\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdGEyLWltZy5jbi1oYW5nemhvdS5vc3MtcHViLmFsaXl1bi1pbmMuY29tLzNkMTYxNTlkOTUxNTYwYmQwMDA2Y2ZlNzEwODNlNjdiLnBuZw)\n\n复用性是告诉我们When（什么时候该下沉了），即有重复代码的时候。内聚性是告诉我们How（要下沉到哪里），功能有没有内聚到恰当的实体上，有没有放到合适的层次上（因为Domain层的能力也是有两个层次的，一个是Domain Service这是相对比较粗的粒度，另一个是Domain的Model这个是最细粒度的复用）。\n\n## 总体架构\n\n![四层架构](https://noogel.xyz/resource/img/2022-01-19-00-07-56.png)\n\n![overview](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBNfJR6ibV1m3J4Xdtvd0VFZ6nOytMkmuuGicOAme3bTc1S3ACMt2thUDw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 接口层\n\ninterface[service]\n\n规范：Interface层的HTTP和RPC接口，返回值为Result，捕捉所有异常\n规范：一个Interface层的类应该是“小而美”的，应该是面向“一个单一的业务”或“一类同样需求的业务”，需要尽量避免用同一个类承接不同类型业务的需求。\n\n![web](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBCcCumAibDlffTuRD1UiaPyOYaM3VueCDT09UX5ZmYSgQEZayH5Kkb13g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 应用服务层\n\napplication[Service]\n\n原有的TransferService不再包括任何计算逻辑，仅仅作为组件编排，所有逻辑均delegate到其他组件。这种仅包含Orchestration（编排）的服务叫做Application Service（应用服务）。\n\n规范：CQE对象的校验应该前置，避免在ApplicationService里做参数的校验。可以通过JSR303/380和Spring Validation来实现\n规范：Application层的所有接口返回值为DTO，不负责处理异常\n\nApplication层的几个核心类：\n\nApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑\n\nDTO Assembler：负责将内部领域模型转化为可对外的DTO\n\nCommand、Query、Event对象：作为ApplicationService的入参\n\n返回的DTO：作为ApplicationService的出参\n\n我们可以看出来，ApplicationService的代码通常有类似的结构：AppService通常不做任何决策（Precondition除外），仅仅是把所有决策交给DomainService或Entity，把跟外部交互的交给Infrastructure接口，如Repository或防腐层。\n\n一般的“套路”如下：\n\n准备数据：包括从外部服务或持久化源取出相对应的Entity、VO以及外部服务返回的DTO。\n\n执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。\n\n持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。\n\n如果涉及到对多个外部系统（包括自身的DB）都有变更的情况，这个时候通常处在“分布式事务”的场景里，无论是用分布式TX、TCC、还是Saga模式，取决于具体场景的设计，在此处暂时略过。\n\n![Application](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBu1M0GnnGyl9jia9jUhl9SbzQWRTA9X4vw2DWSm91uJBOzliaq9gkM9Rg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 领域层\n\n#### 领域模型（DomainModel)\n\n#### 领域服务(DomainService)\n\n上面我们讲述了各个要素对于资源和行为的封装，业务逻辑的实现代码应该尽量放在聚合根边界内。但是总会遇到不适合放在聚合根上的业务逻辑，而此时领域服务就需要承载编排组合领域对象、资源库和防腐接口等一系列要素，提供对其它上下文的交互接口。\n\ndomain[Service]\n\n单对象（可以把service传入entity，只读，无副作用)\n\n跨领域对象（同时操作多个entity)\n\nAccount   本质上是一个 Entity\n\n``` java\n@Data\npublic class Account {\n    private AccountId id;\n    private AccountNumber accountNumber;\n    private UserId userId;\n    private Money available;\n    private Money dailyLimit;\n\n    public void withdraw(Money money) {\n        // 转出\n    }\n\n    public void deposit(Money money) {\n        // 转入\n    }\n}\n```\n\nAccountRepository 是一层抽象\n\n```java\n\npublic interface AccountRepository {\n    Account find(AccountId id);\n    Account find(AccountNumber accountNumber);\n    Account find(UserId userId);\n    Account save(Account account);\n}\n```\n\n![domain](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBw6h6u8RNXzNE3cOVYF7cambLLlIb5ibfcLj9JLynsZL1fPAzsfcdTsA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 防腐层\n\n用来消除外部上下文结构差异的作用，也叫适配层。比如在算价上下文中需要调用促销上下文数据，不同的促销数据源提供了不同的接口和数据，这时就需要引入防腐层来屏蔽差异，防止外部上下文侵入领域内部影响代码模型。首先定义需要的数据接口规范\n\n## Domain Primitive\n\nDomain Primitive 是一个在特定领域里，拥有精准定义的、可自我验证的、拥有行为的 Value Object 。\n\n（1）将隐性的概念显性化\n（2）将 隐性的 上下文 显性化\n（3）封装 多对象 行为\n\n▍什么情况下应该用 Domain Primitive\n常见的 DP 的使用场景包括：\n\n有格式限制的 String：比如Name，PhoneNumber，OrderNumber，ZipCode，Address等\n\n有限制的Integer：比如OrderId（>0），Percentage（0-100%），Quantity（>=0）等\n\n可枚举的 int ：比如 Status（一般不用Enum因为反序列化问题）\n\nDouble 或 BigDecimal：一般用到的 Double 或 BigDecimal 都是有业务含义的，比如 Temperature、Money、Amount、ExchangeRate、Rating 等\n\n复杂的数据结构：比如 Map<String, List<Integer>> 等，尽量能把 Map 的所有操作包装掉，仅暴露必要行为\n\n![types](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBAstMWRiciaBWsJECe4ib9XiawJ0KYa6UccNWFp70mxO2agM1DUFYIB3b7Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 数据存储层\n\n\n```java\n\npublic class AccountRepositoryImpl implements AccountRepository {\n\n    @Autowired\n    private AccountMapper accountDAO;\n\n    @Autowired\n    private AccountBuilder accountBuilder;\n\n    @Override\n    public Account find(AccountId id) {\n        AccountDO accountDO = accountDAO.selectById(id.getValue());\n        return accountBuilder.toAccount(accountDO);\n    }\n\n    @Override\n    public Account find(AccountNumber accountNumber) {\n        AccountDO accountDO = accountDAO.selectByAccountNumber(accountNumber.getValue());\n        return accountBuilder.toAccount(accountDO);\n    }\n\n    @Override\n    public Account find(UserId userId) {\n        AccountDO accountDO = accountDAO.selectByUserId(userId.getId());\n        return accountBuilder.toAccount(accountDO);\n    }\n\n    @Override\n    public Account save(Account account) {\n        AccountDO accountDO = accountBuilder.fromAccount(account);\n        if (accountDO.getId() == null) {\n            accountDAO.insert(accountDO);\n        } else {\n            accountDAO.update(accountDO);\n        }\n        return accountBuilder.toAccount(accountDO);\n    }\n\n}\n\n```\n\nAccount实体类和AccountDO数据类的对比如下：\n\nData Object数据类：AccountDO是单纯的和数据库表的映射关系，每个字段对应数据库表的一个column，这种对象叫Data Object。DO只有数据，没有行为。AccountDO的作用是对数据库做快速映射，避免直接在代码里写SQL。无论你用的是MyBatis还是Hibernate这种ORM，从数据库来的都应该先直接映射到DO上，但是代码里应该完全避免直接操作 DO。\n\nEntity实体类：Account 是基于领域逻辑的实体类，它的字段和数据库储存不需要有必然的联系。Entity包含数据，同时也应该包含行为。在 Account 里，字段也不仅仅是String等基础类型，而应该尽可能用上一讲的 Domain Primitive 代替，可以避免大量的校验代码。\n\nDAO 和 Repository 类的对比如下：\n\nDAO对应的是一个特定的数据库类型的操作，相当于SQL的封装。所有操作的对象都是DO类，所有接口都可以根据数据库实现的不同而改变。比如，insert 和 update 属于数据库专属的操作。\n\nRepository对应的是Entity对象读取储存的抽象，在接口层面做统一，不关注底层实现。比如，通过 save 保存一个Entity对象，但至于具体是 insert 还是 update 并不关心。Repository的具体实现类通过调用DAO来实现各种操作，通过Builder/Factory对象实现AccountDO 到 Account之间的转化\n\n![infrastructure](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibCA7zuzhlSIpEHAClQ3dEBicft40OXaibnibT86aj2s11aok4NXVfmcrVI79sVKs5JLtrxa1Dnia06IA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n参考：\n\nhttps://www.cnblogs.com/wlandwl/p/ddd_five.html\n\nhttps://www.cnblogs.com/pyer/p/15856573.html\n\nhttps://blog.csdn.net/significantfrank/article/details/98087611"},{"title":"量化投资","url":"/底层思维/金融/量化交易/量化投资.html","content":"\n## 个人资产配置\n\n股票是最佳的长期投资方式。\n权益类投资方式是最佳的长期投资方式。\n"},{"title":"跨界能力｜广告","url":"/core/运营力/广告.html","content":"\neCPM = bid（出价）*pCTR（预估点击率）*pCVR（预估转化率）\n\n硅谷增长大佬Andrew·Chen所言，随着时间的推移，所有营销策略下点击率最终都会下降（The Law of Shitty Clickthroughs），主要的原因有三个：\n\n创意对用户的吸引随着时间推移而降低；\n对手的竞争导致效果下降；\n后期用户质量下降；\n\nbid，关乎成本，关乎战略，人话讲就是如果战略支持，就会提高广告的预算，愿意承担更多高的广告成本，bid也就高了。\n\nctr，取决于创意的质量，一个创意如何才能有吸引力？创意更容易供不应求，所以素材的工业化生产能力也很重要。\n\ncvr,意思是说用户多大概率会进行转化。这个转化能力是landing page的页面承接能力以及后续的转化路径通畅度决定的。所以最终要看产品调优和用户运营能力。\n\n\n![20210707104759](http://cdn.b5mang.com/20210707104759.png)\n\nad\t广告\t广告主可以管理的最小的展示单元；每个广告必须属于一个广告组，必须且只能引用一个创意。\n\nadcreative\t广告创意\t呈现给受众的元素集合，可能是文字、图片、视频等一种或多种元素的组合；\n\nadcreative_template\t创意形式\t对创意中元素的具体描述和限定。一般情况下，不同创意形式具有的元素或其属性（如图片的尺寸、字符限制等）不同；每个创意形式对应唯一的 adcreative_template_id，例如 adcreative_template_id=2 时，限制创意中必须包含一个长度小于 18 的文本和一张尺寸为 160*210 的图片两个元素； 一个广告创意只能对应一个创意形式。\n\nDPA\t动态商品广告\t特指动态商品广告（Dynamic Product Ads）\n\n传统广告售卖、PDB、PD、RTB之间有啥区别，还是ADX腾讯实时广告交易平台说得比较清楚。\n\n实时竞价RTB\n实时竞标 (RTB) 是指用户在访问媒体产生曝光机会时，众多家DSP根据曝光的上下文以及用户属性实时地评估曝光价值并给出报价，经过ADX竞价后最终出价最高的广告主赢得此次曝光机会。\n\n下图描述了一个曝光从发生到实时竞标，直到最后获胜广告展示的全过程：\n\n![20210712082308](http://cdn.b5mang.com/20210712082308.png)\n\n1) 用户（user）向媒体（publisher）发起访问请求\n\n2) 产生广告请求时，媒体将携带用户标识（一般是cookie或设备号）的流量发送到Tencent AdExchange\n\n3) Tencent AdExchange向众多家DSP并行发起曝光竞标请求\n\n4) DSP进行估值后决定是否参与出价并给出此次曝光的报价，Tencent AdExchange集齐DSP报价返回后进行拍卖\n\n5) Tencent AdExchange按照媒体广告模板进行样式渲染后，将获胜DSP的广告返回给用户展示\n\n6) 用户浏览页面，看到广告，广告产生曝光\n\n保价保量PDB\n保价保量(Programmatic Direct Buying, PDB) 是指在广告投放前，根据广告主的投放需求，按照固定的CPM价格、固定的资源位、固定的预定量在媒体进行下单，在广告投放过程中，当用户在访问媒体产生曝光机会时，腾讯ADX根据广告主的预定量将广告请求发给单个需求方，需求方根据N倍推送约定的规则有选择的挑选和回退流量，且无需进行竞价。需求方挑选的流量将展示对应广告主的广告。\n\n下图描述了一个曝光从发生到发生请求，直到最后广告展示的全过程：\n\n![20210712082256](http://cdn.b5mang.com/20210712082256.png)\n\n1) 用户（user）向媒体（publisher）发起访问请求\n\n2) 产生广告请求时，媒体将携带用户标识（一般是cookie或设备号）的流量发送到Tencent AdExchange\n\n3) Tencent AdExchange向广告主指定的DSP发起曝光竞标请求\n\n4) DSP在满足N倍推送比例的约束下，进行估值后决定是否选择本次流量，将结果返回给Tencent AdExchange\n\n5) 如果DSP选择本次流量，Tencent AdExchange按照媒体广告模板进行样式渲染后，将DSP的广告返回给用户展示\n\n6) 如果DSP没有选择本次流量，Tencent AdExchange将流量重新返回给广告引擎\n\n7) 广告引擎重新选择其他广告后，返回给用户展示\n\n8) 用户浏览页面，看到广告，广告产生曝光\n\n保价不保量PD\n优选购买 (preferred deal，PD) 是指在广告投放前，根据广告主的投放需求，按照固定的CPM价格和固定的资源位在媒体进行下单，在广告投放过程中，当用户在访问媒体产生曝光机会时，腾讯ADX将广告请求发给单个需求方，需求方可以按照自己的意愿挑选流量，且无需进行竞价。需求方挑选的流量将展示对应广告主的广告。\n\n下图描述了一个曝光从发生到发生请求，直到最后广告展示的全过程：\n\n![20210712082145](http://cdn.b5mang.com/20210712082145.png)\n\n1) 用户（user）向媒体（publisher）发起访问请求\n\n2) 产生广告请求时，媒体将携带用户标识（一般是cookie或设备号）的流量发送到Tencent AdExchange\n\n3) Tencent AdExchange向广告主指定的DSP发起曝光竞标请求\n\n4) DSP进行估值后决定是否选择本次流量，将结果返回给Tencent AdExchange\n\n5) 如果DSP选择本次流量，Tencent AdExchange按照媒体广告模板进行样式渲染后，将DSP的广告返回给用户展示\n\n6) 如果DSP没有选择本次流量，Tencent AdExchange将流量重新返回给广告引擎\n\n7) 广告引擎重新选择其他广告后，返回给用户展示\n\n8) 用户浏览页面，看到广告，广告产生曝光"},{"title":"跨界能力｜流量池思维","url":"/core/运营力/流量池.html","content":"\n\n流量池思维 Overview\n\n![品牌-最稳定的流量池](https://i.loli.net/2021/07/28/Wilz9Bd21e56pgH.png)\n\n品牌 =》 最稳定的流量池 =》 心智占有\n\n如何**打造**品牌的六字方针：**定位、符号、场景**，分别解决“我是谁”、“如何后效表达我是谁”、“在什么场合表达我是谁”\n\n如何有效定位：USP定位、对立型定位、升维型定位\n\n如何打造符号：视觉、听觉\n\n场景：从认知、认可到认购激发\n\n赋能：战略 + 接触点管理\n\nuser growth\n传统广告 转化不明显的难题，如何解决？\n\n![20210728081456](https://i.loli.net/2021/07/28/coqTECDFkbRzX3H.png)\n\n![20210728081556](https://i.loli.net/2021/07/28/Stj17nqROuvyIYP.png)\n\n![20210728081812](https://i.loli.net/2021/07/28/9dlKT8uCbxhetjH.png)\n\n![20210728082038](https://i.loli.net/2021/07/28/2G3auvtB4rmcUbM.png)\n\n裂变的本质：是一种低成本获客人的技能\n\n---\n\n流量池品牌观点\n\n**先做名牌，再做品牌。**\n\n---\n\n品牌快速启动的关键：**定位、符号、场景**\n\n流量池-品牌正三角\n\n![20210705080144](http://cdn.b5mang.com/20210705080144.png)\n\n---\n\n定位\n\n1. 竞争性定位（差异性、）\n2. USP定位（自我定位、功能性为主）\n3. 品类升维定位\n\n差异性、竞争性定位\n\n语言特征：\"更\"、\"比\"，\"没有\"，\"增加\"，“不是...而是...”\n例子：百度更懂中文\n特点：\n    （1）差异化、强竞争\n    （2）适合挑战者、后发品牌\n\nUSP定位-Unique Selling Propostion\n\n独特销售卖点，和垂直场景物理定位，功能主张\n例子：胃痛、胃酸、胃胀，管用斯达舒；天猫：上天猫就购了\n语言特征：....就用...\n特征：\n    （1）直观、好理解（一句话就能说清楚）\n    （2）好定位引出口号（定位不是口号，但好定位能引出好口号）\n    （3）好口号要有行动力（卡位型语言，能调动消费者行动）\n\nVS 情感性定位---情怀、梦想、主义\n\n品类升维定位\n\n语言特征：xx行业开创者；xx革命；重新定义xx\n例子：戴森：重新定义吹风机；RIO:夜场酒的消费革命；小米定位互联网电视\n特征：重新定义市场，新品类，占有品类第一\n\n---\n\n品牌工作，本质上是一个符号工程（打造、强化、保护符号，不断强化品牌记忆的关键点）\n\n品牌符号化打造：\n（1）视觉符号--建立强视觉差异符号\n\nlogo--纯文字、全图形？ 哪一个是大势所趋？\nicon(辅助图标）--进一步增加和具象产品特点，例如lv、burberry等的独有皮质的格纹\n\n（2）听觉符号\n\nslogan、jingle\n品牌口号--饿了别叫妈，叫饿了么。送礼就送脑白金。\n品牌韵律：Intel等的广告声音；Kugo：hello， kugo。\n\n（3）嗅觉符号\n\n---\n\n品牌--场景化突破：扣动流量的扳机\n\n场景营销：契合的时间 + 场景，完成消费引导\n\n人跟一个品牌的接触，人到品牌的购买路径：认知、认同、认购（场景的主要目的就是让人产生购买欲望，完成认购；）\n\n消费情绪，购买转化\n\n例如神州专车，从夜晚加班、孕妇、异地出差、接送机等6个场景切入\n\n（一定要有好的切入点，切入点的意思是说？ 之前用户的心智已经被占领了，在恰当的时机出现后，立马想到你，成交.）\n\n场景很重要，那么我们如何快速找到场景呢？\n\n根据定位和数据，寻找场景。\n\n例如：\n神州针对高端白领女性用户（放心睡，主打安全）\n孕妈专车（专用入口、专用券、妇婴app合作）\n\n---\n\n升--品牌战略是一个CEO工程\n\n从始至终贯穿，产品、运营、营销、服务等多个环节\n\n例如：海底捞的“服务至上”、神州专车主打的“安全” （他们都是在某一个点做到极致）\n\n---\n\n降--品牌接触点管理（品牌定位的落地执行）\n\n罗列出所有可能接触消费者的地方，全方位落地定位执行。\n\n![20210705081226](http://cdn.b5mang.com/20210705081226.png)\n\n---\n\n传统广告\n\n形式：电视TVC广告、广播广告、电梯站牌广告\n问题：效果不明显、转化周期长、投放成本高\n\n我们追求品效合一（做到**品牌曝光**的同时，也要带来**效果转化**。）\n\n解法：明确投放场景，内容简单、直接、重复；\n\n内容：\n    内容本身的特点：简单、直接、重复\n    表达：突出主标，卖点icon化-所见即得（一个口号，三个卖点）\n方式：\n    多用产品、促销、活动来带品牌\n其他\n    吸引研究的3B法则：animal、beauty和child\n    传统广告四件套：客服电话、搜索框、关注微信、二维码\n\n---\n\nAARRR模型\n获取用户 - 提高活跃度 - 提高留存率 - 获取收入 - 病毒式传播\n拉新 -》 提频 -》 留存\n\nMarTech（内功 ）  + AdTech（外功）\n\n营销技术（企业内部获取用户、用户运营和持续增长的技术手段） + 广告技术（企业通过外部广告、将广告和品牌内容送达消费者的技术手段）\n\n大数据标签、客户关系管理、营销自动化等 + DSP、SEM、原生广告\n\n裂变营销的特点：\n\n1. 利用关系链\n2. 强调分享\n3. 后付奖励\n\n优点：\n\n1. 创意投入小、**试错快**\n2. 获客成本低、现金**投入少**\n3. 提升用户**留存**和频次\n\n![20210727132617](http://cdn.b5mang.com/20210727132617.png)\n\n一切产品皆要可裂变\n\n裂变： 低成本获客\n广告投入 = 老用户推荐奖励 + 新用户注册奖励\n\n|   | 传统广告|裂变|\n|  ----  | ----|---- |\n|受益者|广告创意者 + 投放渠道| 用户 |\n|费用|先付 + 大笔| 后付 + 小笔 |\n|准确度|经验、判断| 技术、数据（小步试错，更加精确）|\n\n互惠互利的复利式：福利驱动（以老带新、个体福利、群体福利） + 创意助攻（IP裂变、游戏裂变）\n\n与用户的高频接触是运营的基础，所以我们要提频：\n\n![20210727132816](http://cdn.b5mang.com/20210727132816.png)"},{"title":"跨界能力｜运营基本知识","url":"/core/运营力/运营基本知识.html","content":"运营是干啥的？（运营的作用）\n\n运营是以实现业务目标（战略目标）为中心的，而不是以用户为中心。\n\n在资源投入稳定的情况下，放大业绩（杠杆能力）\n\n通过流程来优化执行效率，通过数据提升业务效率。\n\n核心是啥？用效率最大化，完成业务目标；数据驱动，实现战略决策\n\n业务目标又是啥呢？\n\n---\n\n基本功：销售产品、平台产品\n需要通过运营来放大，具备数据思维，基于收入、投入**渠道**、优化**产品**、吸引**用户**，创造**收入**\n\n运营与产品以及研发的协作\n\n![20210730133818](http://cdn.b5mang.com/20210730133818.png)\n\n数据思维\n\n**流程运营**什么鬼？？\n\n#### 产品运营\n\n产品运营要解决的一个核心问题是什么？\n\n关注产品功能\n\n通用方法论是什么？\n\n#### 渠道运营\n\n#### 内容运营\n\n#### 用户运营\n\n运营的进阶之路\n\n预算与目标制定\n\n### 流量\n\n从宏观层面到微观层面（互联网整体 =》 超级平台）\n公域流量 =》 私域流量\n通过（网红、店家、自媒体、触点）\n\n平台流量转化路径\n\n![20210730133227](http://cdn.b5mang.com/20210730133227.png)\n\n渠道的属性\n\n![20210730132948](http://cdn.b5mang.com/20210730132948.png)\n\n用户池分层\n外部流量 = 微观公域流量中的私域部分 + 宏观的私域流量\n\n![20210730133306](http://cdn.b5mang.com/20210730133306.png)"},{"title":"施展《国际政治学40讲》学习总结","url":"/底层思维/政治学/施展-国际政治学40讲.html","content":"\n### 总体方法论\n\n看清大势，把握趋势的要把握两个核心要素：\n\n1. 对现实**力量**格局的把握（军事力量、经济力量，决定了各方的博弈能力）\n2. 对**人心**的把握（欲望与道德，决定了各方可能的行动方向）\n\n   欲望，唯利是图\n\n   道德，鉴于道德，又不得不做出一些违反利益的抉择。\n\n而推动力量和人心演变的又是什么呢？\n\n1. 技术的变迁\n2. 观念的变迁\n\n### 五个阶段\n\n从时间上来看，国际秩序经历的五个阶段：\n\n#### 大航海时代（1500～1750）\n\n核心：海洋的崛起\n\n海洋崛起 =》 远洋贸易 =》 更多的财富 =》 对旧秩序的挑战（战争） =》 思考新的秩序\n\n两种视角：\n\n1. 帝国视角 =》 国家视角， 法国（对抗哈布斯堡帝国）\n2. 陆地视角 =》 海洋视角， 英国（对抗西班牙）\n\n威斯特伐利亚体系，第一个国际法\n\n---\n\n##### 传统的秩序：帝国与王国\n\n帝国：文明的概念，源于宗教，只要宗教文明在，帝国就在。\n\n王国：治理的概念，行政规划没了，王国就没了。\n\n帝国之下，诸多王国，王国之间领地相差不多。长期以来，形成一种均衡的秩序。\n\n##### 大航海缘何改变了传统秩序？\n\n大航海 =》 远洋贸易 =》 某些商人人没有领地，却有了很多财富\n\n君主从商人贷款 =》 发展军事力量 =》 基于庄园领地式的新的政治组织形式 =》 需要新的观念系统来为新的形式来做**正当性辩护**\n\n##### 为何欧洲发生的最快？\n\n不像中国，欧洲的政治体规模很小，更容易受到外部资源的影响。\n\n另外，罗马法 为欧洲人提供了一套重要的法学方法。\n\n##### 新的国际秩序\n\n国际秩序，以**全球**为单位，以**国家**为基本行为体，以**贸易和战争**为基本互动方式，以**国家法**和**国际条约**为基本行为规范，从而形成的一种秩序。\n\n---\n\n##### 基本要素之国家观念的由来\n\n统治，所指的是人和人之间分为统治者和被统治者的关系，是一个物理事实。\n\n国家，指的是一套复杂的政治和法律关系，是一个理论事实。\n\n人的统治，是一个真实存在的事实。国家，是人们以特定方式对这个事实的一种解释。\n\n法国是如何存下来的？（王爷如何合理的反抗皇帝）\n\n给自己的存在一个理由，给自己去跟其他异教徒合作寻找一个理由。\n\n根本出发点在于：世俗世界的最高统治者（罗马帝国的皇帝） 和 宗教世界的最高统治者（罗马教皇） 是分离的；而教皇才是道德制高点！\n\n主权国家，基于**国家理由**，可以把国内各种资源都动用起来，更加聚焦。\n\n思考问题的方式改变：只从本国利益出发，而不会从超越于本国之上、普世帝国秩序的角度出发。\n\n##### 观念转型之：从陆地到海洋\n\n西班牙：布局土地，庞大的舰队（适合近身肉搏）\n\n英国：布局重要的海上据点（土地上一无所有），结合海盗站，火炮\n\n**领先者是没有动力去主动改变思路的。**\n\n落后者做出观念的改变，看上去是不得已而为之的选择。\n\n海洋霸权 VS 陆地霸权\n\n海洋是自由的，陆地是封闭的；海洋虽然自由，但一定是霸权的；陆地是封闭的，但是陆地格局确实多雄并立的。\n\n海洋霸权的双重属性：军事属性 和 贸易属性\n\n公害不遵守任何国家的法律，只遵守自然法。\n\n海洋霸主通过军事垄断所实现的海洋安全，就转化为一种全球公共皮，可以为所有国家共享。\n霸主的利益在于推动自由贸易来收租。\n\n高手间的政治博弈，是对于规则主导权的争夺，也就是国际法。\n\n---\n\n##### 国际法：构建一个规则系统\n\n西班牙为何率先构建国际法\n\n因为：需要为自己的行为（占领，并掠过印第安人的土地）**诉诸合理性**。诉诸给谁看呢？诉诸给其他的国家。\n\n率先建立标准（有利于自己），然后把这个标准逻辑自洽的建立起来，那么谁就有优势。\n\n罗马法是理论基础。\n\n基于道德的规则系统 VS 基于罗马法的规则系统\n\n前者，不具有演化性，时代不通了，系统会失效；而后者，具有演化性、扩展性。\n\n抽象规则体系：其中每一条的具体规则都不是独立存在的，而是通过其他的规则获得意义，规则与规则之间相互解释，构成一个逻辑自洽的系统。 有扩展性，可以用来解决新的问题。\n\n---\n\n#### 体系形成：30年战争催生出的威斯特伐利亚体系\n\n遇到问题时，人们理念的变化为体系的形成提供了基本框架：\n\n1. 法国对抗帝国时的国家观念\n2. 英国对抗西班牙时的海洋霸权观念\n3. 西班牙掠夺殖民地的国际化规则观念\n\n30年战争，最后一场宗教战争，第一场国家战争\n\n战争的残酷，让人们意识到如何定义正义战争的必要性：\n\n主体，必须是有独立主权的国家\n理由，必须基于自然法，而不能是宗教（宗教是一个国家内部的事情）\n\n---\n\n#### 内政与外交：英国缘何能够打败法国？\n\n英国：打仗需要钱 =》 借钱融资 =》由于国家有钱，国家能够还得起 =》 良性循环\n\n法国：打仗需要钱 =》 借钱融资 =》 由于国家没钱，赖账 （另外不得不发行货币） =》 恶性循环\n\n|  项目 | 英国 |法国 |\n|  ----  | ---- |----  |\n|政体| 立宪君主制 |绝对君主制|\n|政府权力 | 小  | 大|\n|意愿整合能力 |强  |弱|\n|政府收税能力 |强 |弱，君主畏首畏尾不敢多征收|\n|融资能力 |强，民众愿意借钱，有信心，融资成本低 |弱，民众不愿意借钱给政府，没有信心，成本高|\n\n#### 大革命时代\n\n两场革命：\n\n英国的工业革命：英国优先发展了工业，所以跟其他国家有产业落差，制定游戏规则，使用现代经济打击传统经济。\n\n法国的政治革命：观念层面的变迁，现代政治打击传统政治，推动出现民族主义观念，全新的大众政治组织和动员技术以及全新的战争逻辑。\n\n为啥两个国家会爆发不同的革命？\n\n**任何演化都是既有体系当中的不均衡导致的。**\n\n两国缘何发生不同的革命？\n\n历史背景：英国贵族能力很弱（玫瑰战争让大贵族基本灭亡），而法国贵族能力很强\n\n对于英国，大航海带来新资源 =》商人阶层和经商贵族受益最大\n\n小贵族联合起来，最终与国王形成均衡，光荣革命，从封建割据到走向统一，自下而上。\n\n这种社会比较有活力，有创新，率先发起工业革命。\n\n对于法国，大航海带来新资源，法国政府受益最大（从有钱商人那里贷款），雇佣军队，干掉了大贵族，自上而下完成统一。\n\n政府力量强，长期对社会精英压制，反抗欲望强，机缘之下发生政治革命。\n\n**两场革命的影响。**\n\n现代政治的基础在于：大众政治、大众社会。也就是说，政府做什么事情，需要考虑大众的感受，需要考虑对大众的影响。\n\n需要考虑一种全新的秩序来管理人民大众：理性化\n\n理性化，需要把治理国家的方法规则化、抽象化，来应对各种各样的问题，从而让大众更加满意。\n\n**不同路径的理性化。**\n\n理性化体现在工厂管理结构上。效率提升，累积财富，质的飞跃，降维打击。除了常规战争，还发起了经济战争。工业打击农业！\n\n理想化体现在官僚制度。\n\n---\n\n自由贸易-英国从经济上降维打击别人？\n\n从重商主义到自由贸易\n\n争夺的就是规则制定权。而自己则从既定规则中受益。\n\n自由贸易：你收不收我关税，我不在乎；而我不收关税。\n\n为什么英国敢这么做？ 因为英国当时是唯一的工业出口国。从其他国家进口原材料（因为不收关税，所以其他国家更有动力卖给英国），加工，产出工业品卖给其他国家（因为只有我能制造出来，所以及时你收很高的关税，也会有人来走私）\n\n---\n\n英国的自由贸易 VS 德国的国民经济学\n\n亚当斯密 VS 李斯特\n\n任何政策都一定有既得利益者来支持。\n\n强调应该自由交易，而不应该过度干预。并且全球市场化是道德的，如果不遵守，那么就不道德，我就打击你！\n\n李斯特，国民经济学，三步走：\n\n1. 发挥自己的比较优势-农业，通过自由贸易来积累资本。\n2. 保护主义经济策略，用积累的资本促进本国工业发展\n3. 等到工业发展起来，恢复自由贸易。\n\n借助上面的策略，德国赶超英美！\n\n---\n\n人民主权 - 法国大革命巨大的影响力\n\n物质冲突 VS 观念冲突\n\n物质冲突，是一种有限冲突，只要达成利益上的平衡，冲突也就解决了。\n而观念冲突，是一种无限冲突，不把你干死，就没完。\n\n人民主权\n\n不仅考虑了主权，而且进一步思考了主权应该在谁手里？是君主主权还是人民主权？\n\n革命，之前是回归旧传统，而法国大革命指的是推翻旧秩序！\n\n---\n\n民族主义 - 德国是如何通过讲故事来对抗法国的？\n\n人民主权，首先需要将一个故事，用这个故事给他想要去覆盖的那些人赋予同样的身份，同时又能吧其他人和自己区分开。而这个故事，正是对nation，对民族的身份的讲述。\n\n人民主权，需要投票？ 那么又有那些人来投票呢？ 答案是属于这个Nation的人民。\n\n法国，是有现成的国家，讲个新故事来重新定义这个国家；而德国，是先把故事讲出来（有待统一的德意志民族），等到接受这个故事的人多了，反过来推动这个只存在于观念当中的民族统一成一个国家。\n\n法国的政治民族主义：无论出身，只要有相同的政治认同，签署了《人权宣言》\n\n德国的文化民族主义：德国的民族主义是和文化相关的，一个民族就是一种文化的载体。从哲学到人民大众更容易接受的《格林童话》，共享一种文化。\n\n文化民族主义，有着相当的封闭性，因为他要用一种和别人有高度区分性的文化来作为自己的识别标志，那么就要血统、信仰有关了。\n\n血缘民族主义，纳粹\n\n民族主义双刃剑：一方面凝聚力，一方面恶性发展给世界带来灾难。\n\n---\n\n全民战争 - 西班牙怎样在战场上拖垮法国\n\n为什么法国的全民战争这么牛B：\n\n第一，战争的目标设定：之前是解决物质冲突，而现在解决的是观念冲突；\n\n第二，战争调用的资源动员能力：之前是贵族领地，现在是全国性资源。\n\n当遇到了西班牙同样全新的全民战争-游击战\n\n法国大革命带来了：新战争模式-全民战争，新观念模式-游击战争；\n\n---\n\n维也纳和会\n\n法国如何在战败后避免被过分掠夺？\n\n道（做事情的具体原则）\n\n1. 欧洲各国的实力均衡，是能够保持大和平的基础；\n2. 光物质层面还不够，需要考虑人民对正当秩序的想象\n\n术\n\n1. 让法国成为维护各方平衡不可缺少的一部分\n2. 正统性原则（革命原则）：尊重正统君主家族的统治\n\n---\n\n海陆对抗 - 德国为何很难挑战英国\n\n英国的开放秩序（德国挑战英国之前）\n\n1. 覆盖全球的政治规则体系和贸易规则体系，大英帝国治理的不是具体的领土，而是普遍的规则体系。例如，英镑作为货币标准。\n2. 英国的国际战略：着力打造一个各国之间的势力均衡体系，而自己作为第三方仲裁。\n\n以上种种，让英国统治全球的成本并不高。\n\n德国的封闭秩序\n\n德国封闭，强大的民族主义，团结，牛B，发起第一次世界大战、第二次世界大战，而未果。开始转向开放秩序。\n\n德国从封闭到开放\n\n德国吃了两次世界大战的亏之后，德国带头，其他列强开始掠夺海外殖民地。而英国也不得不紧跟（害怕被别人抢完了），维护成本越来越高，统治世界越来越吃力。虽然德国占领很多地盘，但是还是不如英国。德国开始发展海军，给了英国（还有法国、俄国）很大压力，搞得他们不得不结盟。至此，英国也无法置身事外，充当仲裁了。\n\n两者的成功，让其他国家拼命反抗（效仿），例如德国便相继完成了第二次工业革命，并发展出了自己的民族主义，然后严重打破了新的平衡。\n\n#### 大战争时代\n\n第一次世界大战\n\n技术与观念的发展速度 超过 国际秩序上观念和规则的演化速度 =》 外交斡旋机制失效 =》 大规模战争\n\n技术方面：电报、武器工业化生产\n观念方面：民族主义狂热\n\n民族主义不道德，急切需要新的道德观：需要超越、克服民族主义的普世主义\n\n1. 威尔逊主义：先民族自决，再组建国际联盟来确保和平\n2. 列宁主义：无产阶级联合起来，革命，推翻资产阶级\n\n完全出乎大家意料，一站打了很久，最后大家都倦了。不想打了。德国不败而败，英法不胜而胜。\n\n一站，不知为何而站？打赢了的一方，渴望建立什么样子的新秩序？很迷茫。必须找到一种对于正义秩序新的叙事逻辑，一种新的国际道德观，从而为第一次世界大战找到正义的基础。\n\n一站之前的国际秩序：现实主义，大国之间力量均衡，而忽略一些小国和民族；（这种虽然对小国家不友好，但是大国之间并无明显的战争，总体还行）\n\n普世主义：你和别人共存时所遵循的基本原则，从这些基本原则里提炼出更抽象、更高阶的价值观念，这是普世主义的根基。\n\n\n民族主义情绪 依旧 强于 新的道德观（未完全实施；对德国压迫太明显）\n\n第二次世界大战\n\n原子弹的出现使得战争的破环力不可控。大规模的国家级战争不再适合作为政治手段。\n\n#### 大阵营时代\n\n战场上的热战  被 观念上的冷战 所替代，代理人战争\n\n人类的前途是美国还是苏联代表？\n\n美苏两派，需要去说服其他国家加入自己的阵营。\n\n积极鼓励殖民地独立。\n\n经济层面的差距，让苏联后劲不足\n\n美国，市场经济，鼓励创新，会催生出技术红利\n苏联，不适于创新，计划经济，适用于吃透一波红利，而不适于生出一波红利\n\n#### 大颠覆时代\n\n互联网，突破时间与空间，突破了传统社会秩序以及传统道德观念。\n\n核心资源在于对未来的想象力。\n\n\n经历了长时间，什么东西一直在变？什么东西又是不变的？\n\n有两个东西在变：\n\n所以我们需要搞清楚，\n\n什么东西不变呢？\n\n由于技术进度，导致财富积累。财富的增加导致利益分配不均匀。长此以往导致革命。\n"},{"title":"胡思乱想","url":"/杂想/胡思乱想.html","content":"\n人工智能与业务\n\n人工智能仅仅是工具，服务于业务。\n\n区块链与业务\n\n区块链也仅仅是工具，服务于业务。\n\n技术创新与业务\n\n技术只是工具，人们对业务的理解才是核心。\n\n大尺度的深入研究各种技术解决方案的设计与演变，从中推导出自己的设计方法论，把复杂问题简单化，简单的事情重复做。\n在面对我们的业务问题时，才能够有效的控制系统的复杂度，保证可扩展性。\n\n人们对与技术的态度：怀疑、狂热、理性...\n\n持续的做正确决策的能力\n\n当出现紧急的事情并且需要自己亲自出手处理的时候，管理是有问题的。\n\n1. 任务规划不好\n2. 组织结构不合理，没有梯队\n3. 没有合适的骨干\n"},{"title":"关于监控告警流程规范的思考","url":"/研发流程/关于告警监控.html","content":"\nhttps://mp.weixin.qq.com/s/0bDwRtTQdcP7tKI1s76I5g"},{"title":"套路模型｜BIAS反馈模型","url":"/模型/BIAS反馈模型.html","content":"\n当某位同学做了某件事情造成不好的影响时，可以借助BIAS模型去给予该同学适当的反馈。\n\nbehiavor 行为\nimpact 影响\nalternative 不同做法\nsuggestion 建议\n\nGROW\nGROW模型是教练式辅导的一种方法，是业界普遍使用的成熟的辅导方法。\nGROW模型是通过富有技巧性的提问和结构清晰的流程帮助被辅导者释放潜能，增加认识，承担责任，使其绩效最大化。\n\nhttps://baijiahao.baidu.com/s?id=1695100760324101612&wfr=spider&for=pc"},{"title":"套路模型｜AUDIENCE模型","url":"/模型/AUDIENCE模型.html","content":"\n如何借助框架，了解一个人的方方面面\n\nAUDIENCE模型\n"},{"title":"套路模型｜PDCA循环","url":"/模型/PDCA循环.html","content":"\nPDCA四个英文字母及其在PDCA循环中所代表的含义如下：\n\n1、 P（Plan）--计划，确定方针和目标，确定活动计划；\n\n2、 D（Do）--执行，实地去做，实现计划中的内容；\n\n3、 C（Check）--检查，总结执行计划的结果，注意效果，找出问题；\n\n4、 A（Action）--行动，对总结检查的结果进行处理，成功的经验加以肯定并适当推广、标准化；失败的教训加以总结，以免重现，未解决的问题放到下一个PDCA循环。\n\n![PDCA循环](http://cdn.b5mang.com/202151163433.png)\n\n每一件事情先做计划，计划完了以后去实施，实施的过程中进行检查，检查结果以后，再把检查的结果进行改进，进行实施，进行改善，这样把没有改善的问题又放到下一个循环里面去，就形成一个一个的PDCA循环。\n\n![持续形成标准规范](http://cdn.b5mang.com/202151163349.png)\n\n![八大步骤](http://cdn.b5mang.com/20215116358.png)\n\nhttps://zhuanlan.zhihu.com/p/51251795"},{"title":"模型系列-SMART原则","url":"/模型/SMART原则.html","content":"\nS代表specific（具体的），思考为了实现目标，你的行动计划是否清晰？\n\nM代表measurable（可衡量的），思考该用什么衡量是否实现了目标？也就是说，你定的目标最好是可观测的，客观的，而不是主观的。\n\nA代表achievable（可实现的），思考目标实现的可行性有多大？\n\nR代表relevant（相关性），思考目标是否和其他目标具有关联。\n\nT代表time-related（有时限的）。人为的设置计划时间轴，什么时间开始？什么时间结束？什么时候又是计划的关键节点？\n\n一个合格的计划，以上五个原则缺一不可。\n"},{"title":"套路模型｜库博学习圈","url":"/模型/库博学习圈.html","content":"\n行动 -》 经验 -》 规律 -》行动\n\n从行动归纳出经验，把经验升华为规律，用规律来指导行动。\n\n规律有有种来源：\n1）通过反思和验证，将自己的经验升华为规律\n2）学习前人的规律（前人建立的知识模型）\n\n![20214270146](http://cdn.b5mang.com/20214270146.png)"},{"url":"/团队管理能力/leadership.html"},{"url":"/core/如何创新.html"},{"title":"跨界能力｜行业力（Industry）","url":"/core/行业力/关于产业力.html","content":"\n对产业互联网的好奇和渴望。纯互联网机会有限，未来的空间在产业里，这是大家的共识。然而，产业互联网并不是产业 + 互联网的简单叠加，要实现真正的跨越有两大难点：一是要深入产业内部理解其业务逻辑和产业链条，这不仅考验学习能力，更需要耐心；二是需要有合适的公司进行 landing，否则水土不服，这需要一些运气。\n"},{"title":"跨界能力｜运营力（Operation）","url":"/core/运营力/关于运营力.html","content":"\n产品是基石、运营是杠杆，缺一不可。尤其是当行业成熟，空白机会和产品创新空间受到挤压、越来越趋同时，专业运营的发挥空间无疑更广阔。在 2020 年热门运营领域里，既有社群运营、活动裂变、游戏运营这样的熟面孔，也有私域流量、短视频运营、to B 运营、数据运营、MCN 运营这些新方向。\n"},{"title":"跨界能力｜得到《梁宁增长思维30讲》课程大纲","url":"/core/growth/thinking_of_growth.html","content":"\nhttp://www.woshipm.com/tag/%e5%a2%9e%e9%95%bf%e9%bb%91%e5%ae%a2\n\nhttp://www.woshipm.com/marketing/4106692.html\n\n增长思维\n\n## 什么是增长\n\n就是不断作出**正确的决定**，**打破界限**，即是增长。\n\n增长能力，就是持续作出正确决定的能力。\n\n打破界限是方法，增长是结果。\n\n你老板最感谢的，其实不是最勤奋的员工，而是为他的**关键决定**做出完美铺垫的同事。\n\n你能理解这句话吗？\n\n如果不能理解**领导的决定**，其实你就无法与领导对话，也不可能成为领导。\n\n### 增长的度量问题\n\n#### 维持甚至倒退\n\n怎么判断呢？有一个明确的指标，如果你的年营业额、利润的增长，和国家GDP增长水平基本相当，甚至低于GDP的增长水平，这种状态就是维持。因为增长了2%、3%，但是你低于整个国家的增长率，这就是跑输大盘嘛。\n\n#### 惯性增长\n\n如果你的年营业额、利润增长，大概能达到GDP增长率的2倍左右，你可以说，我跑赢大盘了，我在增长。\n\n但也别得意，在成熟市场，这样的增长，是可以**依靠管理实现**的。只要产业周期没有下行，运营盘没出问题，获得这样数字的增长是比较大概慨率的，我们一般管这种水平的增长叫**惯性增长**。\n\n#### 红利增长\n\n而我们统计了过去30年中国的明星企业，这些**明星企业的增长率**，都能够保持在国家同期GDP增长率的4倍以上。在成熟市场，这样的增长是需要有红利才能实现，比如**龙头红利、品牌效应、规模效应、网络效应**等等。\n\n#### 爆发式增长\n\n而这些年那些放卫星，出爆品，成独角兽的超级明星企业，它们的增长率就远不止如此了。\n\n爆发从哪里来？一定来自空白。空白又从哪里来呢？\n\n空白是曾经束缚市场的**限制性条件**改变了，压制市场的**天花板**被打开了，新一层的空间出现，空荡荡一个人都没有。\n\n## 如何实现增长\n\n### 了解什么是束缚增长的障碍\n\n打破界限，即增长；那如果界限无法被打破呢？ 那就无法增长。\n\n束缚增长的障碍又是什么呢？ 客观条件：某项科学技术没有达到造成的生产力不足；主观条件：路径依赖造成的过时理念。\n\n我们每个人、每个企业、每个市场今天的样子，都是在各种**客观条件**、**既往路径**、**个人观念**、**环境**挤压的重重束缚下，成为现在的样子的。就像粽子本来是一摊米，但是粽叶包裹把它束缚出了形状。\n\n技术革命在不断推进，束缚我们**生产力**和**想象力**的天花板也在不断打开。\n\n当一层天花板打开了，一层新空间出现。你看到的会是什么呢？你会怎么使用它、怎么驾驭它呢？\n\n### 了解不增长的两种后果？\n\n#### 企业的死\n\n《总体战》这本书对战争有一句定义：“战争以一方失去战斗意志为结束。”我觉得这个定义，非常准确。\n\n企业的死，其实是以**主导者失去战斗意志**为结束。\n\n遇到巨大困难不是问题，跨越周期很难也不是最关键的问题，最关键的问题是主导者的作战意志。\n\n诺基亚是一家由投资人和经理人主导的公司，危机面前他们有大量的退路。而三星是家族企业。就这一点，战斗意志就根本不同。\n\n企业的死亡，来自企业主导者战斗意志的破产。\n\n#### 企业的退\n\n“善败者不亡。”\n\n善败者不亡。这句话很重要，因为探索一定会遇到失败。\n\n瑞士的军事理论家菲米尼说：“一个良好的撤退应该和伟大的胜利同样受到赞赏。”\n\n有经验的兵家，会**保护最重要的资产**，主动下撤。所有的仗都不是白打的，你亲身战斗过，就强过所有只看过兵书的人。\n\n无论胜负，战斗都会让你变强。**认掉损失，保住最有价值的东西**。比如**品牌**，比如**信用**，比如你自己的**心理能量**，比如你的**核心团队**。阿里就说过一句话：核心团队是剩下来的，不是招募来的。\n\n企业的发展就是这样的起起伏伏。苦苦维持，惯性增长，冒险进入无人区，主动撤退，被打死，交枪投降，再次增长…就是这样，在生死进退里求增长。\n\n所以，创业者每天的心情，都会像过山车一样，第一天自信爆棚，觉得自己做出了业界最棒的东西，第二天又自我怀疑，觉得自己一定会被嘲笑被抛弃。\n\n没关系，只要还活着，只要你的战斗意志还在，我们就还可以继续打下去，还有增长的机会。\n\n### 充分认识自己的企业\n\n草莽创业 =》野火烧不尽，春风吹又生。\n\n腰部企业 =》在竞争中，找到自己的生态位，能够活下来。\n\n头部企业\n\n顶级企业\n"},{"title":"跨界能力｜关于核心能力","url":"/core/跨界核心能力.html","content":"\n每一项能力\n\n底层思维\n\n思维框架\n\n做好某件事情的方法论\n\n知识体系\n\nhttps://www.douban.com/note/765818675/"},{"title":"套路模型｜5W1H分析法","url":"/模型/5W1H分析法.html","content":"\n5W+1H：是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。\n\n1、对象 （What）——什么事情\n公司生产什么产品？车间生产什么零配件？为什么要生产这个产品？能不能生产别的？我到底应该生产什么？例如:如果这个产品不挣钱，换个利润高点的好不好？\n\n2、场所 （Where）——什么地点\n生产是在哪里干的？为什么偏偏要在这个地方干？换个地方行不行？到底应该在什么地方干？这是选择工作场所应该考虑的。\n\n3、时间和程序 （When）——什么时候\n例如这个工序或者零部件是在什么时候干的？为什么要在这个时候干？能不能在其他时候干？把后工序提到前面行不行？到底应该在什么时间干？\n\n4、人员 （Who）——责任人\n这个事情是谁在干？为什么要让他干？如果他既不负责任，脾气又很大，是不是可以换个人？有时候换一个人，整个生产就有起色了。\n\n5、为什么（Why）——原因\n为什么采用这个技术参数？为什么不能有变动？为什么不能使用？为什么变成红色？为什么要做成这个形状？为什么采用机器代替人力？为什么非做不可？\n\n6、方式 （How）——如何\n手段也就是工艺方法，例如，我们是怎样干的？为什么用这种方法来干？有没有别的方法可以干？到底应该怎么干？有时候方法一改，全局就会改变。\n"},{"title":"跨界能力｜洞察力（Insight）","url":"/core/洞察力/关于洞察力.html","content":"\n\n洞察力是什么（WHAT)？\n\n「找方向」是创始人最重要的职责，其重要性超过找人和找钱。对于公司内的业务负责人也是如此，方向错了，越努力只会离目标越远。看准方向、抓到本质的能力就是洞察力。\n\n为什么要提高自己的洞察力(WHY)？\n\n洞察力可以用在哪些地方(WHERE)？\n\n什么时候洞察力可以派上用场（WHEN）\n\n如何提高自己的洞察力（HOW）？\n"},{"title":"套路模型｜SKA能力模型","url":"/模型/SKA能力模型.html","content":"\n人为什么要学习呢？\n人学到的东西，无非就是三样东西：态度、知识、技能\n\n其中，态度要靠心去体会；技能要靠持续的连续；知识要靠记忆。\n\n能力 = （技能 + 知识）* 态度\n\n![202142622210](http://cdn.b5mang.com/202142622210.png)\n"},{"title":"套路模型｜实现你的人生愿望”的五步流程","url":"/模型/人生愿望5步流程.html","content":"\n![2021426155649](http://cdn.b5mang.com/2021426155649.png)\n\n1. 有明确的目标。\n2. 找到阻碍你实现这些目标的问题，并且不容忍问题。\n3. 准确诊断问题，找到问题的根源。\n4. 规划可以解决问题的方案。\n5. 做一切必要的事来践行这些方案，实现成果。\n\n摘录来自: [美]瑞·达利欧. 《原则》 Apple Books.\n"},{"title":"愿景、使命、价值观","url":"/团队管理能力/愿景使命.html","content":"\n### 概念\n\n愿景：一个组织最终想变成什么(**WHAT**)样子，是一个**成就自己**的问题\n使命：一个组织如何（**HOW**)才能变成想要的样子，是一个**成就他人**的问题\n\n使命，一个公司存在的根本理由（WHY, HOW)，我们秉承着某种信念，做着某些事情，达成某种目的，可以三部分：\n使命 = 目的 + 业务（翻译过来叫做宗旨，其实是业务） + 经验哲学（价值观、经营理念等）\n\n业务：提供的产品和服务是什么？ 将服务的客户是谁？ 如何提供产品和服务？ 预期结果是如何？\n\n使命，是外化的，是指企业对外部世界，对用户、人民、甚至牛逼到人类、或者宇宙啥的，要承担的一种责任。打个比喻，这个使命是要企业扛在肩上的，一般都带有生活、生命、世界、人类、美好啥的。是偏虚的，不好评判的。愿景，是内化的，是指企业对内部，从公司内部出发的，一般是和业务、企业发展等相关的，给自己立的一个大方向大目标。一般带有成为、领先、领导、更、最、行业等等词汇。是偏实的，可以一段时间后做评判的。\n\n### 相互关系\n\n企业经营管理的角度来看，「组织为何存在？」，因此，目的（Purpose）才是第一，其次才是愿景与使命（如下图二）：\nPurpose statement：指的是组织为什么（Why）存在？\nVision statement：指的是组织实现的目标是什么（What）\nMission statement：指的是组织如何（How）计划去实现愿景\n\n![愿景使命关系图](http://cdn.b5mang.com/202142610633.png)\n\n愿景、使命以及下面的价值观、目标、策略、行动计划\n\n![愿景使命价值观关系图](http://cdn.b5mang.com/20214261069.png)\n"},{"title":"技术方案模版","url":"/团队管理能力/技术方案模版.html","content":"\n对于一个技术方案或一项技术决策，需要从三个维度去评估：\n\n##### 结果评估\n\n总体原则：明确目标，以终为始\n自问自答：通过这件事情，希望拿到什么结果，你要从哪几个维度去衡量结果，从哪几个**技术指标**去验收成果。\n\n##### 可行性评估\n\n总体原则：收益 >> 成本，ROI优先\n\n自问自答：\n“人财物时”等资源投入成本 需要投入多少人、多少时间，甚至是多少资金和物资在该项目上\n\n其次是维护成本\n\n    技术选型成本 有没有使用不成熟的技术？\n    技术升级成本 其兼容性和扩展性水平，后期如果要升级呢？\n    问题排查成本 出问题了多长时间能排查出问题原因\n    代码维护成本 代码可读性如何？\n\n再次是机会成本，因此事放弃的另外一件事，带来了哪些影响呢？\n\n最后，协作成本 涉及多少团队？沟通费劲吗？\n\n##### 风险评估\n\n总体原则：反脆弱，避免系统性风险\n自问自答：该技术方案带来最大损失的可能性和边界，以及在什么情形下会发生\n\n---\n\n如何去拓展自己和团队的技术视野和技术判断力：\n\n##### 建立技术学习机制\n\n盘点你负责的业务，需要哪些方面的技术，成立一个或几个核心的**技术小组**，让团队对各个方向的技术保持敏感，要求小组定期做交流和分享，这样你就可以保持技术的敏感度。\n\n##### 专项技术调研项目化\n\n如果某项技术对团队的业务有重要的价值，可以专门立项做技术调研，并要求项目负责人做调研汇报。\n\n##### 和技术大牛交流\n\n请教其他大牛，讨论如何技术“变现”，让技术产生价值。\n\n##### 听取工作汇报\n\n在读员工的周报、季度汇报时，积极思考，并与员工相互探讨\n\n---\n"},{"title":"产品创新","url":"/core/product/产品创新.html","content":"\n### WHAT 产品创新破局\n\n#### 第一部分 产品创新如何提升品牌价值\n\n企业的核心在于什么？\n增长？ 创造利润？ **创造价值**\n\n品牌价值，降低了用户的选择成本， 使得用户愿意去付出更高的价值\n产品价格 = 品牌价值 + 本身效用价值\n\n品牌价值曲线\n\n单次产品创新 =》 塑造品牌 =》 产生价值回馈，推动企业增长\n持续的产品创新 =》 推高品牌进入平流层 =》 增强企业的抗风险能力\n\n企业分三类：\n（1）平台创新企业-腾讯、阿里巴巴\n    传递价值，很难被复制（有技术门槛或者说网络效应作为护城河）\n（2）一般企业\n    通过规模或者降低品质来降低成本、管理来提升效率 =》 品质无法得到保证\n（3）产品创新企业-苹果、小米\n    一般的产品创新，很容易被别人复制；可能会一定程度上浪费；\n    但是万一这款产品提前了5年（iphone) 或者更多年（intel、芯片）呢？\n\n#### 第二部分 如何识别创新机会\n\n三要素： 大国梦 + 经济增发展缺乏底层动力（产品创新） + 消费者觉醒（变得对品质有追求；这是时代给予企业的最大机遇）\n\n大国梦：中国不行，缺少能够代表国家形象的品牌（稀缺）\n美国对中国的创新力碾压：科技碾压（intel） + 品牌碾压（可口可乐-糖水） + 文化碾压（LV）\n\n经济发展缺少底层动力（独角兽企业中，很少做产品，大多数是做产品），所以我们需要：\n模式转换：从价值传递到价值创造\n\n#### 第三部分 何为品牌创新\n\n产品创新不是技术创新，而是要素的重新组合。\n\n多维度：\n迭代微创新（改进某一个功能）\n功能组合创新（1 + 1 > 1) - iphone、智米空调\n系统创新（要素更大范围的组合，对资源的重新配置） - itunes + ipod、IOT网络\n底层技术创新 (不确定性，对社会推动小，试错成本高）- ssd硬盘\n\n### HOW-爆品方法论\n\n爆品的定义\n\n用复杂技术（Computing)创造易用工具(Product)\n人的能力与效率，对苹果来说是最重要的！\n\n爆品：持续超出用户的预期（例如，性能更强，体积更小）\n\n爆品方法论\n\n起点：人性 从“人性”出发的最优解\n基础：技术创新\n    资源整合（看看别人有没有这块技术）\n    底层开发（如果没有办法的话）\n方法：聚焦唯一方向，无限趋近最优解\n迭代：笃定方向，做减法。依托技术革新推动产品升级，不“为变而变”\n升维：持续技术积累，跃升到下一个层级，量变到质变\n\n爆品方法论的底层逻辑\n\n发散多元 =》 **收敛聚焦**，极大的提升产品创新的效率\n创新应该是简单和清晰的。创新 ！= 变 （而是一开始就以简洁为目标，所有的繁杂只是临时的；只是技术还没有达到；）\n\n爆品的三个特质\n\n通用（考虑产品的普适性，尽可能面向所有的使用者）\n极简\n超预期：用奢侈片的标准去打造消费品\n    超预期才能为用户创造更大的价值；超预期的产品才有传播力！\n\n### 商业模式创新\n\n爆品，不只是产品，爆便是一种商业模式，是一种系统性的方法。\n\n小米--性价比\n\n小米模式（铁人三项）=》 推动传统消费品**产销生态**效率优化变革\n硬件（围绕着手机展开） + 新零售（小米自有销售渠道） + 互联网\n\n小米是一家重构\n人（用户）\n货（产品）\n厂（供应链）\n场（零售渠道）\n全产业链的新兴科技消费品公司\n\n小米商业模式：\n以**用户**需求为导向\n以**流量**经营为思路\n以**效率**提升为方法\n\n流量引擎：爆品\n\n爆品商业模式的三各层次：\n规模与成本模式\n生态模式\n互联网模式\n![20214112169](http://cdn.b5mang.com/20214112169.png)\n\n模式和成本模式\n（1）围绕产品做垂直产业\n（2）整合上游供应商（核心理念：货找源头，元器件、原材料）和下游渠道（核心理念：爆品引流）\n                                                自由销售渠道：小米网---第三方渠道卖不了更低的价格）\n                                                电商渠道：只能覆盖20%的人群；另外的80%呢？靠小米之家\n（3）提升效率，节约成本\n\n假定成功原则：爆品逻辑的起始思想，从开始就全力打造爆品，按高起始量来规划，按百万量级定价\n定倍率 = 商品售价/商品成本 （1.2～1.5）\n\n生态模式\n（1）以爆品为基础点，引入更多元素\n（2）垂直整合，横向扩展（横向扩展，战略投资其他的企业；利益共享）\n（3）多品类 + 品类之间的共生关系（竹林效应）\n\n互联网模式\n（1）爆品产生流量，流量带动爆品，爆品反馈流量（爆品系统效应形成成长飞轮）\n（2）IOT产生叠加效应\n\n流量引擎：爆品\n\n### 人的创新思维训练，创新组织建设\n\n个人：创新思维\n\n表层：感知力\n    感知力，建立在兴趣点、能力圈之上；兴趣点、能力圈、感知力与身俱来，但是需要发现、训练和加强\n    如果兴趣点、能力圈与事业相结合，极大增加成功率\n    如果这项事业与时代发展需求相适应，有可能创造巨大的价值（90年代的汽车城）\n\n    超级感知：感知普通人无法感知的精度和细节，用10倍精度看细节\n    精度：人类文明的标志（夸克）\n    超级感知 产生 高维度判断力\n中层：生活体验 = 细致观察 + 换位思考\n    观察什么样的产品：（持久大量销售的产品。。了解为什么？爱马仕。细节）\n    换位思考：从用户角度看问题，和用户共情\n底层：素养，哲科思维（ 无用之用，方为大用；）\n    哲学为科学提供方法论\n    科学的成功也会促进哲学的发展\n\n    ![202141121527](http://cdn.b5mang.com/202141121527.png)\n知道什么是好的，最终转换为产品直觉和判断力！直觉基础上的判断力！！牛B的技能！\n\n团队：创新流程，用流程驱动创新\n    串行协同 + 控制力与决策力的贯穿\n\n串行管理流程（一个完成的产品从头到尾）\n![2021411215340](http://cdn.b5mang.com/2021411215340.png)\n\n产品经理用垂直管理方式，贯穿产品定义到交付的整个流程\n\n平台：用机制和氛围驱动创新\n\n创新通过组织行为不断复制和进化\n个人能力=》平台能力\n点状力量 =》机制力量\n\n平台类型：不断试错，不断好散,打击信心。。bad\n收敛：高度收敛聚焦，提供正反馈，形成正循环。。good！\n\n---\n\n打造企业创新机制：\n（1）企业核心价值\n    使命 + 远景 + 价值观 （将创新融入到价值观中）\n（2）人才管理机制\n    人尽其才 SONY的人才流动机制\n（3）激励机制\n    让创新者获得成就感（物质利益，精神利益）\n    成就感产生自驱力；成就管就是正反馈，能够不端放大核心价值，最终形成创新氛围\n\n创新机制 ： 产生创新氛围；氛围驱动创新；正向反馈循环"},{"title":"个人能力提升系列-沟通｜演讲力","url":"/通用软技能/如何高效沟通/演讲力.html","content":"\n![2021411131428](http://cdn.b5mang.com/2021411131428.png)\n\n好演讲\n\n愿意听、记得住、能传播\n\nstep1. 愿意听\n\n收集更多素材，了解听众对什么感兴趣\n\n演讲开头是愿意听的内容，切入点（套路）别人想听的 + 你想讲的\n\n![2021411131924](http://cdn.b5mang.com/2021411131924.png)\n\nstep2. 记得住\n\n将内容总结成特别好记的金句：例如：演讲不是目的，影响力才是\n\n我不是...我就是... (我不是为了输赢，我就是认真)\n关于XXXX的几个标准：xxx,xxx,xxx\n使用公式进行类比: 记得住 = 故事 + 金句\n\nstep3. 能传播\n\n你讲的东西能否引发听众共鸣？启发用户洞察？\n\n![2021411132525](http://cdn.b5mang.com/2021411132525.png)\n\n### 建立信任：基础\n\n没有信任，别人会觉得你是在忽悠！\n\n![2021411132941](http://cdn.b5mang.com/2021411132941.png)\n\n信任的三个要素以及建立信任的一些方法\n可预测（靠谱）\n    分享自己的一些改变，证明你有能力！\n    分享给别人带来的改变，证明你有价值！\n可依赖（拉近你与听众的关系，让关系变得更好）\n    承认缺点（无关紧要的小缺点，不影响产品售卖的小瑕疵）\n    自我暴露\n信念（展示初心）能否打动别人，让别人无条件信任你\n    我要帮助谁...我要做成一件xxx\n\nTODO-准备这些素材！\n\n![2021411135816](http://cdn.b5mang.com/2021411135816.png)\n\n### 即兴演讲\n\n讲三点\n\n自我介绍的三点：成就性事件 + 初心 +具体的事例\n    成就：表达自己的优秀：收入职位；身份冲突\n    具体事例：jobs观点把人生的点串起来\n团队培训的三点：领导力故事 + 解读 + 具体建议\n    观点：苦难都是暂时的\n非正式沟通的三点：最近在做什么事情 + 分享书影 + 启发\n\n![202141114847](http://cdn.b5mang.com/202141114847.png)\n\n### 打破上台的恐惧\n\n四阶段法：准备时 + 演讲前 + 演讲中 + 下台后\n\n准备时\n\n1. 试讲3遍PPT\n2. 关键词，提示\n   ![202141114298](http://cdn.b5mang.com/202141114298.png)\n3. 选择一个熟悉的道具\n\n演讲前\n\n1. 提前到场，找托\n2. 给熟悉的人打一电话，聊聊要讲的内容\n3. 双手叉腰5分钟-激素分泌，提升自信\n\n演讲中\n\n1. 无视观众，把观众当成冬瓜\n2. 忘词时，喝口水\n3. 通过肢体语言（咳嗽两声，握握手）来放松心情\n\n下台后\n\n复盘，调查问卷，了解哪些地方做的不好，有待提升\n\nTODO \n\n![2021411142439](http://cdn.b5mang.com/2021411142439.png)\n\n### 汇报发言（会议发言&向上汇报）\n\nFFA = Fact + Feeling + Action\n\nDISC模型\n\n![2021411144250](http://cdn.b5mang.com/2021411144250.png)\n\n如何判断你的领导是什么类型的\n![2021411144052](http://cdn.b5mang.com/2021411144052.png)\n\n根据不同的领导类型，有侧重点的汇报\n![2021411144331](http://cdn.b5mang.com/2021411144331.png)\n\nTODO \n![2021411143813](http://cdn.b5mang.com/2021411143813.png)\n\n### 销售，拉近和客户的距离（职位越高，越需要懂销售）\n\n痛点型发言公式 = 你有病 + 我有药 + 赶快买\n\n你有病-了解客户的需求 =》 收集用户的抱怨\n\n![2021411145641](http://cdn.b5mang.com/2021411145641.png)\n\n我有药 - 不是介绍你的产品，而是你的产品给用户带来了什么样的改变\n![2021411145745](http://cdn.b5mang.com/2021411145745.png)\n\n赶快买 - 接受你的观点，而不一定是完成购买 -》 对症下药\n\n对症下药\n\n![202141115153](http://cdn.b5mang.com/202141115153.png)\n\n促进成交：1） 强调稀缺性 2）限时特价 3）双人套餐\n\nTODO\n\n![2021411145327](http://cdn.b5mang.com/2021411145327.png)\n\n### 互动技巧，不开小差\n\n问一下 + 记一下 + 送一下\n\n问一下 = 提问题 + 举手互动\n\n记一下 = 知识晶体 + 金句\n\n送一下 = 与主题相关 + 与个人相关 + 与热点相关\n\nTODO\n![202141115119](http://cdn.b5mang.com/202141115119.png)\n\n### 经验分享：八分干活才刚好\n\n好演讲 = 80%的干活 + 20%的常识\n\n乔哈里窗格\n![2021411151554](http://cdn.b5mang.com/2021411151554.png)\n\n用常识来拉近我们和听众的距离 + 避免盲区 + 分享干货\n\n干货公式\n\n人生工作的结果 = 能力 * 热情 + 思维方式\n\nTODO\n![2021411152425](http://cdn.b5mang.com/2021411152425.png)\n","categories":["个人能力"]},{"title":"跨学科知识体系-金融｜香帅的北大金融学课","url":"/底层思维/金融/index.html","content":"\n股份制\n永续性 股票的流动性\n\n法人：永生主体，有财产权\n\n有限责任，是股权投资者的保险，也是企业家精神的源泉\n\n风险共担（有下限），利益共享（无上限）\n\n股份制\n合伙制（合伙团队，承担无限责任）\n","categories":["知识体系"]},{"title":"个人能力提升系列-沟通｜口才套路学","url":"/通用软技能/如何高效沟通/口才套路学.html","content":"\n口才套路学\n\n即兴发言\n\n称呼 感谢大家都认可的人 回忆过去 祝福未来\n称呼 赞美 直接赞美 利用其他人的赞美 回忆过去 祝福未来\n称呼 故事(跟主题相关) 回忆过去 祝福未来\n称呼 前一位人说过的话 回忆过去 祝福未来\n称呼 问两个问题() 回忆过去 祝福未来\n\n称呼 名人名言 回忆过去 祝福未来\n\n悬疑(先给大家一个意想不到的结果)\n\n自己谦虚(讲的不好 多多担待)\n\n心情(此时此刻的心情)\n\n针对以上9种套路\n\n1. 适用于任何场合\n2. 称呼  一般都要加\n3. 称呼 回忆过去 可以去掉 仅保留祝福未来\n\n正式场合 (一般会议讨论后的发现)\n称呼 我发现 我认为 我建议 我相信\n\n非正式场合(稍微熟悉的人)\n有没有发现 我想是不是(我想可能) 如果 我估计\n\n称呼 接力感悟 祝福未来\n三个切入点 \n\n1. 接力 天气(雨 雪) 历史事件 突发事件\n2. 感悟 \n3. 认真准备 (多积累素材 提前准备)\n\n委婉拒绝别人的套路\n\n三大方面\n\n接力 缓力 建议或者感谢\n接入的切入点 可叠加使用\n\n1. 对人的肯定或者完美 \n2. 对双方关系的肯定 没忘了我这好哥们\n3. 对阶段的感同身受\n4. 对事情的积极态度 (项目确实不错)\n\n缓力 \n提高对方，压低自己 不给你添乱了\n延长答复 给定具体时间 \n接人与物 问问老婆\n模糊性对 (商量好后给你答复吧)\n对方立场 (现在对方立场 为对方考虑)\n\n歉意或者感谢 (让对方看到你的真诚)\n\n降低期许 (已经提前知道对方要借钱)\n选择应答 (我们去吃酸菜鱼吧)\n\n第二大的方面\n\n接力 (肯定对方) 援力( 借助其他人实际上不一定做 ) 歉意\n\n如何拒绝给别人找工作\n车险到期\n\n步步否决\n\n说是是有惯性的 提请求  需要催眠\n\n想办法让对方说是\n\n天气预报可能有雨\n\n求人办事\n铺垫 礼物 诉求 谢恩 注意事项\n\n\n谈判\n\n张弛有度对方浪\n\n成功谈判=谈判意识 + 核心推演 + 主导技巧 + 锦上添花\n\n第一块：\n\n双赢意识（塑造未来价值 一锤子买卖）\n持续猜疑意识\n说服意识（不要说我们想说的话，说对方想听的话）---我会尽量早入职，拉人头给团队（包括PM）\n利为根本（给团队带来更多的利益，找一个人成本会很大！）\n付出意识\n    谈判开始时，赞美对方（（（！！！工作好用功！！）））\n    物质方面（利益），精神方面（赞美）（（（（ 没有给到期望的职级，已经在付出了；跟自己的原始期望已经下调很多了哦）\n    16Base + 年终奖（有空间） + 股票\n    59K * (16-一般都有 + 1) + 17 (150W / 3 = 50) + 88W（44 + 44） = 194 100W\n        收市价 匀速 ====\n    一次性费用 15w\n    T11 有管理职级 黄金链路 汇报给组长！ 业务技术负责人 ｜ 第一轮的面试官（小额拼拼...） 新增了HC 给到电商赋能...\n    T11 没有组长..\n\n    同等职级...\n\n第二块：\n\n针对可能有疑问的地方，提前去准备，做好解答\n接力 + 解决问题 + 主导\n\n接力的四个切入点：\n对人的肯定\n对双方关系\n对阶段的\n对事情的积极态度\n\n第三板块：主导技巧\n谈判中对方的疑问可以解决掉，结果就是我们想要的；\n利用响应的技巧，化被动为会主动\n\n接力 + 因势利导\n    逐步引导\n    铺垫（说对方做事干脆，跟你合作\n\n接力 + 多意引导\n\n 接力 + 故事引导（戴高帽 + 观点有利于自己的铺垫）\n    我给你举一个真实的例子吧。 王总，你做这一行好多年了。。\n\n借他人他事他时他地\n    需要请示下其他的领导；需要和我们的团队商量一下；（老大能不出动就不出动）\n    这个地方不太安静\n    这次谈判就到这里吧。\n\n小付出\n    不是原则性的付出；价格已经到底线了，但是我们可以把保修期延长一年。\n\n声东击西\n    阳谋 对方微微\n\n提前破冰\n    已经和对方的领导提前沟通好了\n    在谈判之前已经喝过酒了\n\n心理制胜\n    不能把自己身份放低；两只眼睛看他一只眼睛，让对方恐惧\n\n重视价格\n    需要请示领导\n    回避价格，小付出\n\n第四个板块\n\n锦上添花：另一种小付出，让对方对我们有好感\n\n====\n\n价格谈判\n\n！不可单独使用！\n\n买方压价的九个技巧：\n1）货比三家：知己知彼百战不殆，有利于探求对方的低价（（（对方低价是多少））） 250w,并且股票占比会比较大！\n2）还价有理\n    针对刚开始的报价，吃惊，否决\n    还价一定要低于自己的心理价位\n3）画饼策略-三个切入点\n    承诺长期：又不是一次性买卖，给对方台阶下（（（（（！！找一个高P的成本有多大！！）））））\n    量多探底：多买一些，更加了解对方的低价\n    假装大户：能持续长久且大批量买他东西；新的装修公司的！数码店的\n4）化零为整\n    买奶粉，一年算下来，要2万多块钱呢；一是长期，二是让对方觉得确实贵了 （（（！！！生活开销那么大，距离很远！！！）））\n5）分开击破\n    直接去掉 或者 了解对方的利润\n6）巧借他人\n    借助他人询价（借助假的领导）\n    借助他人直接出面\n7）同情策略\n    我还是学生。。我新手。。。\n8）适当压力\n    我有更多的选择性：说实话，对方比你便宜10来块（（（！！）））\n9）让对方小付出\n    奖金？ 签字费？薪资构成？\n\n卖方抬价的九个技巧：\n（1）合理定价\n    有章法的定价，稍微高一点（1%期望法；中间差价法）\n    不同客户的针对价格\n（2）巧借他人\n    自己扮演（你的这个价格可千万不要让别人知道。。）\n    借助领导/团队/合伙人\n（3）化整为零\n    每天不到55块，价格没那么高了\n（4）选择探底\n    给他推荐别的产品\n（5）适当反悔\n    自己给自己台阶（你先别着急；我向我们的领导申请下）\n    原定价格的提升\n（6）同情策略\n    不瞒你说，我们这个行业不景气，我们不赚钱\n（7）时间节点策略：活动快结束了\n（8）强调差异化：自己与同类产品的差异，然后再报价\n（9）小付出\n\n","categories":["个人能力"]},{"title":"模型系列-如果我需要干什么，我有一个模型","url":"/模型/index.html","content":"\n### 想真正成为一个做某件事情的高手，刻意练习\n\n刻意练习，分为四个步骤：\n\n第一步：制定科学的目标与训练计划\n    三个要点：精致化目标、工程化分解、颗粒化节点\n    ![精致化目标](http://cdn.b5mang.com/2021323223759.png)\n    ![工程化分解](http://cdn.b5mang.com/2021323223818.png)\n    ![颗粒化节点](http://cdn.b5mang.com/2021323223840.png)\n第二步：只在学习区大量重复训练\n    同心圆理论：舒适区、学习区、恐慌区\n    四个要点：逃离舒适区、避免自动化、接受痛苦、保持专注\n第三步：获取持续高质量的有效反馈\n    三个关键点：及时性、客观性、有效性\n第四步：创建高质量的心理表征模型\n    刻意练习最终的成果：心理表征模型，强大的脑神经元连接！\n    例如：练习讲话的一个比较优秀的表征模型可以是：概述（说明你要讲什么）、条理（使用123分层次）、归纳（总结前面讲的）\n\n### 想真正的了解自己，元认知\n\n元认知-对认知的认知；认知与元认知的联系与区别：\n1）从本质上讲，元认知是不同于“认知”的另一种现象，它反映了主体对自己“认知”的认知。同时两者又相互联系、不可分割，认知是元认知的基础，没有认知，元认知便没有对象。\n2）元认知通过对认知的调控，促进认知的发展。\n3）元认知和认知共同作用，促进和保证认知主体完成认知任务，实现认知目标。\n\n人的行为，靠反馈回路，具体为：\n1）事实阶段，通过感官去收集更多的数据、信息、或者事实\n2）联系阶段，借助认知，去除无用信息，选择性留下有用的信息\n2）结果阶段，利用信息，结合自己的经验，去处理这些信息\n3）行为阶段，根据对信息的处理结果，下发命令，指导行动\n\n元认知的作用：\n1）影响反馈回路 2）发现认知扭曲 3）强化脑神经回路\n\n元认知的结构：\n1）元认知知识\n    个人因素（个体内差异、个体间差异、人类认知普遍特性）\n    任务因素（学习资料、学习目的会影响学习的效率）\n    认知策略（计划策略、监控策略、调整策略）\n2）元认知体验\n3）元认知监控\n    制定计划、实际控制、检查结果、补救措施\n\n如何培养元认知能力\n1）掌握元认知知识\n    掌握学习策略：时间管理策略、遗忘曲线、批判性思维、费曼学习法等\n    知道知识的分类与学习方法\n        陈述性知识：有关概念、规则“是什么”的知识；需要理解和记忆\n        程序性知识：一种“怎么办”的知识；需要示范、练习、反馈\n        条件性知识：一种“何时做，什么场景做，为什么这么做“的知识；需要讨论和反思\n2）自我提问法-不断向自己提问\n3）联脑学习讨论-头脑风暴，与他人辩论\n4）善于反思和总结\n\n内容讲述框架\n\n故事  =》 故事的背后（问题、反思）\n"},{"title":"常见系统设计题系列-微博计数系统","url":"/backend_knowledge_architecture/system_design/counter.html","content":"\n\n\n### 数据库\n\n数据库 + 分库分表\n\n方案的问题：\n\n1. 如果不分库，性能扛不住\n2. 如果按照时间分库分表，存在热表问题（越新的微博，越容易被访问）\n3. 如果按照id取模的方式，扩展性不够。\n\n### 数据库 + 缓存\n\n最大的问题：\n\n1. cache需要访问好多空数据（好多微博的count为0）\n2. cache 太贵了，尤其是redis，redis的有效内存利用率比较低。（如果key特别特别多，用redis特别昂贵，这个时候需要考虑自研服务了）\n\n方案三: 自研Counter服务\n\n可以利用的点：\n\n1. 大量微博(一半以上)是没有转发，或者没有评论，甚至是没有转发也没有评论\n2. 各种计数（评论数、转发数）通常一起展现。\n3. 大量的微博的count并不会很大，是没有必要寸long类型的。那那些超过65535的呢？\n\n参考：https://www.cnblogs.com/kenshinobiy/p/4316217.html\n\n---\n\n系统通知未读数：全量用户， 全局递增ID相减\n\n系统通知的小红点：每一个人有一个时间戳  PK 全局时间戳\n\n关注的未读数 = SumOf（每一个关注的人的最新值 - 上一次访问快照中的历史值）\n","categories":["系统设计"]},{"title":"stack相关的题目","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/index.html","content":"\n```cpp\n\n//栈 —— 模板题 AcWing 828. 模拟栈\n// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空,tt 大于0 表示栈不为空。\nif (tt > 0)\n{\n\n}\n\n```\n\n## 相关的经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [检查合法Stack的弹出序列](isPopOrder.html)  |模拟题，启发式思考|\n| | [最小栈](minStack.html)  |模拟题，启发式思考，空间换时间|\n","tags":["栈"],"categories":["数据结构与算法"]},{"title":"贪心算法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/greedy/index.html","content":"\n### 贪心算法\n\n在对问题求解的时候，总是做出在当前看来最好的选择。也就是说，找出局部最优解。通过求局部最优解得到最终问题的答案。贪心策略的选择必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。\n\n### 贪心问题的解决步骤\n\n1. 当我们看到这些问题，首先联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选择几个数据，在满足限制值的情况下，期望值最大。\n2. 尝试看这个问题能否用贪心问题解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。\n\n### 贪心的正确性\n\n数学上如何证明两个值相等， 等价于： $A \\ge B$ && $A \\le B$\n\n### 经典问题\n\n#### Huffman树问题\n\n合并果子\n\n用堆来维护所有的叶节点，一次pop两个，添加和\n\n#### 排序不等式\n\n排队打水问题，按照时间从小到大排序\n\n证明：调整法，假设最优解不是按照从小到大排好序的，通过调整可以减少等待时间，从而矛盾。\n\n比较严谨的证明：\n数学归纳法\n反证法\n\n#### 绝对值不等式\n\n货仓选择问题：放中位数\n\n$f(x) = |x_1 - x| + |x_2 - x| +  |x_3 - x| + ... +  |x_n - x|$\n$f(x) = (|x_1 - x| + |x_n - x|) +  (|x_2 - x| + |x_{n-1}) + ...$\n\n思想：分组（将前面的项与后面的项放在一起考虑） + 放缩\n\n### 推公式\n\n刷杂耍的牛：\n\n![20201229224811](http://cdn.b5mang.com/20201229224811.png)\n\n分糖果问题\n\n钱币找零\n\n区间覆盖问题\n\n### 相关题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n|股票买卖系列| [仅买卖一次](../stock_1time.html)  |贪心算法、股票买卖、定序、新的变量与最值|\n","tags":["贪心"],"categories":["数据结构与算法"]},{"title":"程序员用到的数学知识","url":"/底层思维/数学/math_for_coder.html","content":"\n十进制 => 二进制\n\n二分思想\n\n逻辑代数，硬件电路\n\n---\n\n同余定理\n\n求余是一种特殊的hash函数\n\n对称加密\n\n---\n\n迭代法，就是不断用旧值，推导计算新值的过程。\n\n迭代，对应计算机中的递归或者循环\n\n迭代哪些应用：\n\n1. 求数值的准确或者近似解（例如，迭代法求解根号2）\n2. 在一定范围内找到目标值（例如，顺序查找或者二分查找）\n3. 机器学习算法中的迭代（例如，梯度下降法）\n\n---\n"},{"url":"/block_chain/index.html","content":"区块链\n\n分布式记账 技术\n\n数据库\n\n大型数据库  账本\n\nA有多少钱 =》 B\n\n都有权利记账，\n\n比特币。\n\n记账权。。10分钟 账页\n\n付出冗余\n\n高可靠性（超过50%）\n高透明度（每一笔比特币的交易）\n无法篡改（大多数一致的账本）\n无中介价值转移（信息互联网，价值互联网）\n\n信息互联网\n    信息的传递与复制\n\n价值转移\n    很难做到 转账，必须借助支付宝等中介机构\n\n银行、保险必须借助中介机构\n\n区块链如何诞生\n\n比特币 匿名黑客  论文 2008 2009.1.3 前50个比特币\n中本聪是谁？更有可能是一个欧美人\n\n匿名黑客\n\n传统加密技术\n共识算法、非对称加密等算法很巧妙结合在一起\n\n万亿美元 中心式 金融系统\n\n比特币底层技术： Block Chain 区块链\n\n除了支付\n更多领域：智能合约\n\n以太坊 加拿大天才 2012\n图灵完备的智能合约： 一套程序\n与传统的程序？\n\n定义在区块链的程序\n\n一旦被\n\n无法终止的程序\n\ndeck\n\nDecentralized Autonomous Organization,\ndao 规则 去中心化的去中心化组织\n\n传统商业社会三大支柱\n    复式记账法\n    有限公司制度\n    保护私有财产的法律制度\n\n商业成本，社会成本比较高； 需要庞大的法律体系 + 司法 + 执法\n\n区块链社会\n    分布式账本\n    DAO\n    智能合约\n\n降低成本，但是监管有困难\n\n挖矿（pow工作量证明机制）\n    竞争记账权，如果你抢到了，就获得50个比特币\n    每10分钟，4个比特币；每四年减半\n    竞争越来越多\n矿机\n    参与的计算机\n矿工\n    参与的人\n\n共识机制\n    pow 工作量证明机\n    dpus 代理人记账\n    pus 谁比特币多，谁收益更大\n\n公有链\n    每一个节点，都没有权限的要求；\n私有链（许可链）\n    必须准许才可以接入；\n联盟链（许可链）\n\n广域网 VS 局域网\n\nico\n\n代表这个软件使用权\n\n任何一个项目，代表收益权\n发币的方式来融资\n\n以太坊，自治组织\n以太币\n软件使用权\n\n倒车修理厂\nICO 一共100个\n分红权\n其实类似证券类型\n\nICO需要更加严格的监管，不能随意\n\n区块链落地的应用有哪些？\n支付结算、证券、医疗 保险 物联网\n\n去中心化尝试的？\n\n物联网应用：\nIBM 设备的民主 2050 至少1000亿设备。需要高可靠\n\n车联网，对可靠性有一定的要求\n\n现在的互联网很难做到100%可靠\n\n去中心化交易系统\n中心化交易系统\n\n去中心化存储\nIPFS 替代百度云、腾讯云\n\n医疗领域，第二个区块链领域\n医疗档案保管（如何确保医疗档案的安全）\n虹膜系统、指纹系统 数据大规模外流？ 金融系统的灾难。 指纹流失之后，不可更改。\n基因数据泄漏？ 多权限的复杂管理，多把私钥共同管理\n\n开源软件\n让开源软件可以赚钱\n\n复杂的加密算法\n\n比特币 数字货币\n各个政府认同很大困难\n不能监管\n"},{"title":"网站安全系列-XSS攻击","url":"/backend_knowledge_architecture/security/xss.html","content":"\nXSS（Cross-site request forgery）跨站请求伪造\n\n## 核心原理\n\n攻击者通过表单，提交了**一段带有攻击性的JS代码**作为用户要提交的数据。\n\n我们的服务器会把它存起来。\n\n当这段数据被加载到浏览器中渲染时，会被浏览器无条件的当成HTML代码(With JS)来执行渲染。\n\n## 防范实践\n\n### 防范手段\n\n对从数据库中读取的数据，进行URL转义处理；\n\n而不要：存的时候进行转义；\n\n我们的原则一般是：尽量保持信息不丢失。\n\n### 最佳实践\n\n\n## 参考文章\n","tags":["系统安全"]},{"title":"二叉树系列-节点路径计算","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/node_path.html","content":"\n给一个二叉树节点，打印节点路径\n\n### 解题思路\n\n退出条件：找到对应节点\n\n遍历方式：后续遍历\n\n### 代码\n\n```cpp\n\nvoid dfs() {\n    if (root == target) {\n        res.push_back(target);\n        return;\n    }\n\n    dfs(root->left);\n    dfs(root->right);\n\n    if (!res.empty()) && (res.back() == root->left || res.back() == root->right)) {\n        res.push_back(root);\n    }\n}\n\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"二叉树系列-前序中序序列重建二叉树","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/pre_in_rebuild.html","content":"\n输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。\n\n注意:\n\n二叉树中每个节点的值都互不相同；\n输入的前序遍历和中序遍历一定合法；\n样例\n给定：\n前序遍历是：[3, 9, 20, 15, 7]\n中序遍历是：[9, 3, 15, 20, 7]\n\n返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]\n返回的二叉树如下所示：\n3\n/ \\\n9  20\n/  \\\n15   7\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    map<int, int> hash;\n    vector<int> preorder;\n    vector<int> inorder;\n    \n    TreeNode* dfs(int pl, int pr, int il, int ir)\n     {\n         if (pl > pr) return NULL;\n         \n         auto root = new TreeNode(preorder[pl]);\n         //借助hash，避免扫描\n         int k = hash[root->val];\n         \n         auto left = dfs(pl + 1, pl + k - il, il, k - 1);\n         auto right = dfs(pl + k - il + 1, pr, k + 1, ir);\n         \n         root->left = left; \n         root->right = right;\n         return root;\n     }\n     \n    \n    TreeNode* buildTree(vector<int>& _preorder, vector<int>& _inorder) {\n        preorder = _preorder;\n        inorder = _inorder;\n        \n        for (int i = 0; i < inorder.size(); ++i) hash[inorder[i]] = i;\n        \n        return dfs(0, preorder.size() - 1, 0, inorder.size() - 1);\n    }\n};\n```","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"常见系统设计题系列-源码编译顺序","url":"/backend_knowledge_architecture/system_design/compile_seq.html","content":"\n1. 用图来来表示源文件编译时的依赖顺序\n2. 对图进行拓扑排序\n","tags":["拓扑排序","图论"],"categories":["系统设计"]},{"title":"常见系统设计题系列-大文件整数找中位数","url":"/backend_knowledge_architecture/system_design/big_file_mid.html","content":"\n在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。\n\n回答：\n\n不妨假设10G个整数是64bit的。2G内存可以存放256M个64bit整数。\n\n我们可以将64bit的整数空间平均分成256M个取值范围，用2G的内存对每个取值范围内出现整数个数进行统计。这样遍历一边10G整数后，我们便知道中数在那个范围内出现，以及这个范围内总共出现了多少个整数。\n\n如果中数所在范围出现的整数比较少，我们就可以对这个范围内的整数进行排序，找到中数。\n\n如果这个范围内出现的整数比较多，我们还可以采用同样的方法将此范围再次分成多个更小的范围（256M=2^28，所以最多需要3次就可以将此范围缩小到1，也就找到了中数）。\n\n注解：先按取值范围将数据保存到对应文件，并统计每个文件有多少数值，然后计算第5G和5G+1个数在哪个文件，继续对该文件重复上述步骤\n","tags":["位图","分治"],"categories":["系统设计"]},{"title":"二进制表示中1的个数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/bit/NumberOf1.html","content":"\n输入一个32位整数，输出该数二进制表示中1的个数。\n\n注意：\n\n负数在计算机中用其绝对值的补码来表示。\n样例1\n输入：9\n输出：2\n解释：9的二进制表示是1001，一共有2个1。\n样例2\n输入：-2\n输出：31\n解释：-2在计算机里会被表示成11111111111111111111111111111110，\n一共有31个1。\n\n```cpp\nclass Solution {\npublic:\n    int NumberOf1(int n) {\n        int c = 0;\n        while (n) {\n            n = n & (n - 1);\n            c++;\n        }\n        return c;\n    }\n};\n```\n","tags":["位运算"],"categories":["数据结构与算法"]},{"title":"吴伯凡每周商业评论","url":"/core/商业力/吴伯凡每周商业评论.html","content":"\n2021.02.24\n\n#### 世界太复杂，我们要解释\n\n《创新者的窘境》颠覆式创新\n\n任何人和企业，都由三部分构成：资源、流程、价值观\n资源的有无和多少，决定了你的自由度\n流程是为了有效率地到达目的地的一种优化的途径\n价值观是我们做选择、做抉择的依据。\n\n原罪：你生来就有，但你自己又不知道的缺陷。\n\n人生来就有的原罪：你看到的世界实际上是你构造的世界；你打造的产品是被你的世界观和方法论支配的产品。\n\n不要面对客户（你的客户就是你的枷锁）而应该与客户肩并肩同行，去尝试还原他们的世界，才能做出在他们的世界中管用的产品。\n\n让自己的世界观变得更加复杂，更加高级，从单一世界变为平行世界，从单调世界变成复调世界。\n\n一个人同时保有两种相反的观念，还能自由行事，这是第一流智慧的体现。\n\n#### 一张脸面向过去，一张脸面向未来\n\n云计算，源于电网，像一个水库，最大的水库是云。\n\n所谓预言，只是他看到了很远的过去。你想看见多久的未来，就要看清楚多远的过去。任何一个新的世界都包含着一个旧的世界。表面上是新世界在运行，其实是旧世界在过去已经发生的事情，在今天改变了形态在发生。\n\n在这个忙碌的世界的背后，其实是有简单的、更本质的要素、模式、力量存在的。\n我始终关注未来，因为我的余生将在那里度过。为了关注未来，我必须密切的关注过去。我们看待商业世界的方式：反复看、往回看、最终向前看。\n\n#### 字节跳动为什么总是出爆款\n\n第一点：一种全新的思维方式：TAG思维\n\n创新的源头\ntag思维 VS Label思维，从层级到光谱\n\n第二点：一种可以支持快速创新的组织架构：大中台，小前台\n\n三台一体\n\n大中台，他存储了足够的资源和能力，提供的是一种模块化的半产品，供小前台使用，快速搭建一个全新的产品。\n\n诺基亚的模块化生产\n\n#### 中国内循环与产业、消费、资产升级？\n\n内循环的两重驱动力：\n内需：最主要的目的是去消化国内的巨大产能（因为国外金融危机没有能力去消费国内的产品）\n内供，自己供应（之前都是通过进口来满足内部需求），自己消费；如果可以的话，还可以出口。\n\n为啥消费会升级？ 为啥消费需要被升级？\n因为中国大的目标是截止到某个时候中产阶级翻一番，从3亿到6亿；有钱人变多了，消费自然要升级。\n\n食：本地快消品，吃点好的\n    一点思考：大家越来越不在乎钱了，大家更注重品质；大家又不是完全不在乎钱，如果你能够设定一个价值锚点，让用户觉得占了便宜，大家还是会很乐意去买单的。\n    第一点，关乎大家的收入增加了，钱包鼓了\n    第二点，关乎人的本性，这是刻在基因里的，没那么容易改变。\n精神消费：文化娱乐、游戏、心理服务、宠物、陪伴、旅游\n以上是中等人\n以下是上等人的高端消费，会发生中国化，规模性的国产替代。\n2000+的酒，如果没有茅台，有钱人会考虑二锅头吗？ 不会，他们会考虑国外的高档酒。\n\n如何才能消费升级？产业升级是基础，是消费升级的先决条件。\n产业升级，简而言之就是让大家做更有技术含量的工作，例如消费升级、科技、医疗健康、先进制造\n有几个大的方向：\n1）通过技术，促进传统行业的整合，形成某个行业的巨头？例如养猪\n2）医疗健康？老龄化问题\n3）科技：芯片、5G、新能源；\n\n还有双循环，中国那些产业可以出海？优势何在？\n\n资产升级\n产业升级带来的资产，除了满足消费升级，如果还有盈余呢？势必会带来资产的升级：\n\n过去以及现在，主要资产是房产。未来呢？\n1）流动性更高的基金、权益类资产（新的一代，理财意识的提升 + 房价太高了）\n2）数字资产（比特币， 实体资产的数字化、个人行为数据）\n3）数字人民币？\n\n#### 如何看待\"+酒\"饮品越来越多了\n\n元气森林-无糖饮料\n越来越多的“+酒”饮品\n如何创新：通过要素的另类组合，去开拓新的品类，去开发消费者新的需求。\n而不是一定要去红海中竞争，去抢更大的蛋糕。\n\n#### 淘宝上干啥的都有\n\n为啥淘宝上挖掘机卖的那么好？\n挖掘机是农村人才有会的需求，卖的特别好，起码说明：农村人会上淘宝了\n\n一开始农村人是在淘宝买东西的（农产品等），供应方；\n可能哪一天意识发生了转变，我是否可以买到自己想要的东西？ 不太靠谱。。\n\n一些海外企业在淘宝上做测试，测试自己的产品是否适合中国市场？\n1）贸然进入一个市场是有很大风险的（收入可能覆盖不了成本）；借助互联网思维，最小可用产品？\n\n淘宝直播，卖锦鲤？卖乌龟？卖活物？\n\n哪些东西适合直播带货？\n1）吃的，容易勾起大家的食欲\n2）宠物，直播更加生动\n3）化妆品， 让人感觉更加真实，前后差别？\n\n一单生意之所以成交不了，最主要有两方面：信息不对称、信任不对称。\n直播带货之所以能火，一定是某件商品通过带货这种特殊的售卖方式，信息得到了更好的传递？建立了更好的信任？\n\n#### 为啥大伙都去养猪了\n\n如果一个行业集中度比较低，说明这个行业没有形成垄断。而对于行业中的某一家公司而言，就有更大的市场潜力。\n\n一个行业的产业链有什么组成？ 产业链上的利润分配如何？\n例如生猪行业：最下游是养猪的，上面是杀猪的，在上面是猪肉分销。\n利润分配方式取决于供应链上的主体的行业集中度。\n对于美国，杀猪的CR5是83%，集中度较高，所以话语权在杀猪企业，所以杀猪企业的利润更高；\n而中国，养猪的CR5 6.4%, 杀猪的CR5 5.5%, 养猪的利润更高；为啥呢？\n再往下的话，就是消费者了。\n一个杀猪的，当天当地没有那么多杀（因为消费者喜欢吃新鲜的），所以就没有动机去扩大规模。\n而美国人，可以吃冷鲜肉，肉制品，这个可以直接由中下游企业来满足。\n\n为什么猪肉这个行业的集中度那么低呢？\n因为中国人喜欢吃新鲜的猪肉，地域限制，服务半径，其他地方送过来的猪肉新鲜度不够了？ 强龙压不过地头蛇？\n\n产业链上的企业之间什么时候会发生整合？有哪些整合方式？是上游整合下游，还是下游整合上游？分别适用于什么情况？\n（1）技术壁垒高的 整合 技术壁垒低的企业\n（2）离消费者更近的 整合 离消费者远的（在中国，中国对生猪肉的要求更高；而美国，对各种各样的猪肉制品要求更高）\n\n为什么最近大家（一些互联网大厂）都争相去养猪了？\n环保要求，这个属于政策对商业的影响，这种环保要求，会让“养猪”需要更高的技术！\n因为非洲瘟疫，散户们养的猪都死了，猪肉涨价大涨。这个事情就引发了大家的思考：\n养猪是一个技术活，例如防疫呀，清洁呀，这些东西都需要技术研发，需要资金，不是所有的散户都搞得起。\n然后**大公司**恰好有资本去做这种长周期的投入。最后靠技术上的优势，取得更大的市场份额，从而获得更高的收入。\n\n#### 在与美国的竞争中，中国有哪些产业优势是独有的？\n\n台积电 给 华为 提供芯片, 20%的产能都是华为消化的；但是台积电的核心技术都是美国的专利，并且最大的股东是一家美国企业。所以听美国的，给华为断了供。\n\n中国的产业升级是外在因素推动的，还是内部也有实力推动？ 答案是后者。那么中国究竟有啥优势呢：\n\n1）全球最大单一市场（量大了，会形成绝大的规模优势，从而大幅降低生产成本。成本低了，就有钱去高价雇佣最牛的人才！）\n2）人才红利---注意不再是人口红利\n    人口红利对应着成本耕地的劳动力，现在相关产业已经外溢到了越南、柬埔寨等东南亚国家。\n    人才红利，体现在，我们只需要花200W就能雇佣一个很牛B的人；而在国外，足够牛B的人要花的钱远远超过200W..\n3）大基建（工业基础设施-交通网、网络基建-移动通讯网、能源网）\n4）产业链又大、又长、又全（大，是由于市场大；长，是说从最上游到最上游，包括了所有环节；全，是说品类齐全）\n    举个例子，汽车产业链：钢材=》零配件=》整车 =》汽车金融 =》销售等\n\n相比国外，如果国外企业完全退出中国市场，国外企业的利润率可能会下降5～8%个百分点。\n\n#### 新能源汽车为什么被那么多人看好？\n\n经纬中国\n1）相比传统燃油车，造电动车的技术门槛降低\n    传统燃油车的核心技术：发动机、变速箱等；一般的公司没有这个技术！\n    电动车的核心技术：电池\n2）电动车使用电作为动力，让汽车更加智能化，整个车就是一个完整的系统（相比燃油车，是N个子系统，整合性差）\n    尤其是中国，市场大，数据积累更加丰富，有助于自动驾驶的测试验证\n    ---一个完整的系统的弊端：被黑客入侵，一挂全挂？而之前的独立系统不会出现类似的问题。\n\n汽车的供应链很长，如果汽车行业发展能够大大激发我国的制造业潜力！\n\n#### 蚂蚁金服是干嘛的？\n\n蚂蚁金服，蚂蚁科技 -- 一家**数字基建**\n\n蚂蚁的愿景：让信任等于财富！ 蚂蚁最重要的资产是什么：是数字和技术吗？其实是信任！！\n\n蚂蚁的收入来源：\n1）数字支付与商家服务，服务于个人，36%\n2）对银行、信托等金融企业的咨询服务费用，服务于企业，60%----利用数据来赚钱，这个是科技公司做的事情：用户触达、风险管理等\n3）其他-区块链、数据库等，5%\n\n蚂蚁本质上是一家解决问题的公司，他解决的问题都是哪些在现有的能力基础上，跳一跳能够得到的问题。\n\n解决了哪些问题：\n1）担保支付----解决了商家与用户之间的信任不对称问题\n2）快捷支付---解决了网银支付不方便的问题\n3）310小微企业贷款--在阿里云（成为了技术基石）上实现100W以下的小额带宽，3分钟申请，1秒钟放款，0人工介入\n4）余额宝--让天虹基金把准入门槛降到了1元\n\n对自己技术的倒逼，可能会变为价值巨大的产品！\n\n#### 对新疆棉的看法\n\n![纺织产业链](http://cdn.b5mang.com/2021327225518.png)\n经济需服从政治\n\n#### 广告行业的理解\n\n广告主 广告平台 流量端\nCPC、CPS\n\nCost Per Sale\n\n京东联盟\n淘宝联盟\n多多进宝\n蘑菇联盟\n当当网联盟\n唯品会联盟\n\n垂直细分\n\n"},{"title":"职场晋升方法论","url":"/团队管理能力/职场晋升方法论.html","content":"\n晋升，不仅仅是对你过去工作价值的认可，更是对你未来工作价值的预期。\n晋升三要素：\n（1）出色的业绩 -》 业务足够出色 =》承担更大的责任，获得更大考验的机会\n（2）职场领导力 -》 承担更大的责任，调动更多的资源，领导更大的团队 -》 提升整个团队的价值\n（3）职场能见度 -》 能力让其他人看到，得到他们的公认（晋升一个人，疏远所有人） -》 只有能得到别人的认可，才可以调动跨团队的资源，从而做成更大的事情\n\n谁在决定你的晋升：\n评估者（小老板）---给出晋升评估方案（每一个直接下属的业绩表现、领导力、价值观等，提报晋升的候选人）\n决策者（大老板）---全局统筹安排，确定最终候选人，进入晋升评估期\n影响者（平级、合作伙伴）---他们对你的态度会影响评估者、决策者\n\n晋升的三个雷区：\n（1）如果有跟大老板合作的机会，千万别把事情搞砸了（千万不要让老板给你打上一个负面标签）\n（2）远离耀眼，不要在背后评论你的职场伙伴\n（3）不要在职场考察期松懈\n\n出色的业绩-如何更加聪明的工作\n\n出色的业绩 = 客观的数字或者案例更加有说服力\n\n第一点：做正确的事\n（1）跟上级一起沟通你的工作重点，并且定期沟通；当你的精力被其他工作占据过多的时候，必要时跟上级领导反馈和沟通，请他帮你减轻负担或者梳理优先级\n（2）处理临时接到的任务时，跟老板确认他的期望\n\n第二点：正确的做事\n（1）不要重复造轮子（你要相信，这个问题肯定不是你第一个遇到）\n（2）成为改进者（通过改进，选择更多一些，速度更快一些，质量更好一些，成本更省一些）\n    Why-Why分析法，多问几个为什么，定位到问题的原因，然后分析改进\n（3）及时复盘（罗列这一次我们做的好的三个长处，做的不好的两个短处）\n\n职场领导力-给周边小伙伴带来：\n（1）方向感-大局观\n    原则1: 先目的后措施；先分类后解决；先整体后细节\n    原则2: 比你目前的级别更高一级去思考问题\n        基层：完成当前执行细节；中层：完成某个项目或者任务（进度）；高层：企业业务模式（安排资源和进度）\n（2）能量感-赞美和驱动\n    赞美公式：“你做的很好”， 你为什么做的这么好，我内心的感受\n    批评公式：你今天哪里做的不好，为什么我认为做的不好，我内心的感受\n    赞美/批评要及时\n    正面的感受表现出来；负面的感受表达出来\n\n    驱动力：推着老板、同事、客户、项目前进的主动力量\n    手头上的工作，每到一个节点，主动跟同事和上下级沟通，说清楚需要什么样的配合和协助，以及，及时分享好消息\n    让别人觉得，他要做的事情，就是他自己的重要的事情（利益共享｜头脑风暴，让伙伴觉得他要做的事情是他自己的想法）\n（3）信任感\n    职场资源有限，会被别人抢资源，来提升自己的业绩；遇到这种情况，我们的原则应该是：好合作、有原则、敢反击\n    首先释放善意，但如果对方做了对不起你的事情，需要敢于捍卫自己的权利，要为自己的组织去争取；最后，从自己利益最大化的角度，去选择反击或者原谅他。\n\n职场能见度-影响力\n（1）让你的名字与一个正面能力挂钩\n    明确自己的统治区域，到处传播，让别人一遇到问题就想到你\n    不要自己给自己搭上负面标签，永远不要说自己不行\n（2）参加跨部门合作的公司级项目，让更多同事认识你\n    招聘、培训、运动会等\n（3）找到职场导师\n    首先你得行，其次得有人说你行，最后说你行的人得行\n    如何让他们帮你：（1）通过具体事情，寻求他们的帮助（2）说清楚“你自己想做什么 + 遇到什么困难”\n（4）穿的高级一点\n（5）营销自己的业绩\n    经验总结会、内部邮件分享\n\n把握外部晋升机会-主动跳槽\n\n能实现更高的“职场价值”\n\n原因：\n（1）公司成长快，业务好，但是轮得到你嘛？\n（2）公司目前成长快，但是将来有可能会被取代。\n\n只要。。。。就。。。\n只有。。。。才。。。\n"},{"title":"得到课程索引","url":"/core/index.html","content":"\n==============\n\n### 要学习的知识\n\n#### 第2版\n\n互联网\n    梁宁·产品思维30讲\n    梁宁·增长思维30讲\n    《增长黑客》\n    《俞军产品方法论》\n    启示录:打造用户喜爱的产品\n    人人都是产品经理\n    结网\n\n最新的商业信息\n    蔡钰·商业参考（年度日更）\n    吴伯凡·每周商业评论（年度周更）、 伯凡 · 日知录\n    万维钢·精英日课⁴（年度日更）、万维钢·精英日课³、万维钢·精英日课第二季、万维钢·精英日课第一季\n    吴军·硅谷来信³（年度日更） 、吴军·硅谷来信、硅谷来信²·谷歌方法论\n    卓克·科技参考（年度日更）\n商业\n    刘润·商业通识30讲\n    5分钟商学院·基础\n    5分钟商学院·实战\n    刘润·商业洞察力30讲\n    贾宁·财务思维课\n    年度得到·香帅中国财富报告\n    香帅中国财富报告25讲\n\n自我提升\n    吴伯凡·认知方法论\n    吴军·阅读与写作50讲\n    蔡钰·批判性思维15讲\n    何帆的读书俱乐部\n    超级个体\n    30天认知训练营第二季、30天认知训练营第一季\n经济学\n    薛兆丰的经济学课\n    何帆·宏观经济学30讲\n    年度得到·何帆中国经济报告\n    何帆中国经济报告2019-2020\n    何帆中国经济报告2018-2019\n金融学\n    香帅的北大金融学课\n    何帆大局观\n    余剑峰·行为经济学\n    张潇雨·个人投资课\n    张晓燕·风险管理课\n    李笑来·通往财富自由之路\n自然科学\n    吴军·数学通识50讲\n    吴军·信息论40讲\n    吴军·科技史纲60讲\n    刘嘉·概率论22讲\n    卓老板聊科技\n    卓克·科学思维课\n管理学\n    宁向东的管理学课\n    熊太行·关系攻略\n    有效提升你的职场价值\n    谈判能力：\n    沟通能力：\n政治学\n    刘擎·年度思想前沿报告\n    刘擎·西方现代思想\n    施展·国际政治学40讲\n法律\n    刘晗·法律思维30讲\n心理学\n    武志红的心理学课\n    刘嘉·心理学基础30讲\n听书系列\n    镇馆之宝\n    《增长黑客》| 广行解读\n    《疯传》| 无锋解读\n    《原则》| 远读重洋解读\n\n#### 第1版\n\n最新的商业信息\n    蔡钰·商业参考（年度日更）\n    吴伯凡·每周商业评论（年度周更）、 伯凡 · 日知录\n    万维钢·精英日课⁴（年度日更）、万维钢·精英日课³、万维钢·精英日课第二季、万维钢·精英日课第一季\n    吴军·硅谷来信³（年度日更） 、吴军·硅谷来信、硅谷来信²·谷歌方法论\n    卓克·科技参考（年度日更）\n商业\n    刘润·商业通识30讲\n    5分钟商学院·基础\n    5分钟商学院·实战\n    刘润·商业洞察力30讲\n    贾宁·财务思维课\n    年度得到·香帅中国财富报告\n    香帅中国财富报告25讲\n互联网\n    梁宁·产品思维30讲\n    梁宁·增长思维30讲\n\n自我提升\n    吴伯凡·认知方法论\n    吴军·阅读与写作50讲\n    蔡钰·批判性思维15讲\n    何帆的读书俱乐部\n    超级个体\n    30天认知训练营第二季、30天认知训练营第一季\n经济学\n    薛兆丰的经济学课\n    何帆·宏观经济学30讲\n    年度得到·何帆中国经济报告\n    何帆中国经济报告2019-2020\n    何帆中国经济报告2018-2019\n金融学\n    香帅的北大金融学课\n    何帆大局观\n    余剑峰·行为经济学\n    张潇雨·个人投资课\n    张晓燕·风险管理课\n    李笑来·通往财富自由之路\n自然科学\n    吴军·数学通识50讲\n    吴军·信息论40讲\n    吴军·科技史纲60讲\n    刘嘉·概率论22讲\n    卓老板聊科技\n    卓克·科学思维课\n    王立铭·生命科学50讲\n    给忙碌者的量子力学课\n    孙亚飞·化学通识30讲\n    科学人物课-冯诺依曼、霍金、费曼、杨振宁\n    前沿科技·吴军讲5G、量子计算、人体微生物组9讲、新药研发课、\n管理学\n    宁向东的管理学课\n    熊太行·关系攻略\n    有效提升你的职场价值\n    谈判能力：\n    沟通能力：\n政治学\n    刘擎·年度思想前沿报告\n    刘擎·西方现代思想\n    施展·国际政治学40讲\n法律\n    刘晗·法律思维30讲\n心理学\n    武志红的心理学课\n    刘嘉·心理学基础30讲\n听书系列\n    镇馆之宝\n    《增长黑客》| 广行解读\n    《疯传》| 无锋解读\n    《原则》| 远读重洋解读\n"},{"title":"网站安全系列-CSRF攻击","url":"/backend_knowledge_architecture/security/csrf.html","content":"\nCSRF（Cross-site request forgery）跨站请求伪造\n\n## 核心原理\n\n浏览器在请求接口时有如下机制：\n**浏览器**请求某域名下的某个接口时，会**自动带上该域名下的Cookies**，而不管发起请求的页面是究竟在在哪个域名下。\n\n基于以上机制，攻击者只要有目的的部署自己的攻击方式，便能够让真正的用户在**不知情的情况下**完成某些操作，例如：给攻击者点赞、给攻击者转账等。\n\n攻击方式：\n\n- GET类型\n  - 伪造图片\n  - 伪造超链接\n- POST类型\n  - 页面加载自动提交POST表单\n\n## 防范实践\n\n### 防范手段\n\n- 每次发起请求时，从页面元素中拿取一个由服务端动态下发的token\n- 每次发起请求时，从cookies中拿取一个由服务端种好的token\n- 检查refer是否符合预期（问题是：不是所有的合法请求都有refer)\n- 浏览器SameSite机制：lex\n\n#### 同源检测\n\nHTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于bank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于bank.com之下，这时候服务器就能识别出恶意的访问。\n\n这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。\n\nCSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。\n\n#### Samesite Cookie\n\nChrome 51开始，浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪。Samesite有三个可选值，分别为Strict、Lax、None。\n\nStrict：最严格模式，完全禁止第三方Cookie，跨站点访问时，任何情况下都不会发送Cookie。换言之，只有当前网页的 URL与请求目标一致，才会带上Cookie。\n此方式虽然安全，但是存在严重的易用性问题，用户从第三方页面访问一个已登录的系统时，由于未携带Cookie，总是需要重新登录。\n\nLax：Chrome默认模式，对于从第三方站点以link标签，a标签，GET形式的Form提交这三种方式访问目标系统时，会带上目标系统的Cookie，对于其他方式，如 POST形式的Form提交、AJAX形式的GET、img的src访问目标系统时，不到Cookie。\nNone：原始方式，任何情况都提交目标系统的Cookie。\n由于Samesite是Google提出来的，其他浏览器目前并未普及，存在兼容性问题，目前不推荐使用。\n\n#### CSRF Token\n\n由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在Cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是Form表单中的一个数据项。服务器将其生成并附加在Form中，其内容是一个伪随机数。当客户端通过Form提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。\n\nCSRF Token需要服务器端对提交的请求进行验证，一般CSRF Token以Session参数的形式保存在服务器端。对于分布式应用，使用分布式Session来管理的难道比较大，可以考虑把Token保存在Redis等分布式缓存中。\n\n双重Cookie验证\n上述CSRF Token方式，需要在服务器上保存Token值，并对请求参数进行校验，增加了服务器端的复杂度。双重Cookie验证的原理是在Cookie中保存Token值，同时在Form表单中也提供该值，请求提交时，Cookie和Form表单中的Token同时提交，服务器端只需要对请求中的两个参数进行校验即可，省去了在服务器端维护Token的步骤。\n\n由于Cookie的安全限制，只能在本域名或子域名下访问到Cookie值，兄弟子域名无法访问到，如a.bank.com域名下的Cookie，只能被a.bank.com，sub.a.bank.com访问，无法被b.bank.com访问。对于分布式应用，可能需要在多个子域名中提交请求，所以一般需要把Cookie保存在根域名bank.com中。不过此方式存在安全风险，如果任何一个子域下的页面存在XSS攻击，可导致根域名下的Cookie被篡改，Token可被攻击者任意修改，导致安全措施失效。\n\n### 最佳实践\n\n一般情况下，我们可以这么做取防范CSFR攻击：\n\n- 明确GET/POST的最基本语义，并严格遵守（不要出现GET接口完成写操作的情况）\n- 写入代表登陆态的Cookies时，使用SameSite的lex模式\n\n## 参考文章\n\nhttps://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/\nhttps://www.jianshu.com/p/66f77b8f1759\nhttps://tech.meituan.com/2018/10/11/fe-security-csrf.html","tags":["系统安全"]},{"title":"网站安全系列-防重放攻击&防篡改","url":"/backend_knowledge_architecture/security/replay.html","content":"\n第一个点：如何防止给服务端的内容被黑客抓取，并查看里面的内容？\n\n客户端每次加密前，都随机生成一个AES key，我们计为：AES_Key\n同时请求服务端，获取服务端RSA的公钥，我们计作：RSA_Public(服务端持有用于加密的私钥RSA_Private)\n\n客户端使用RSA非对称加密算法对AES_Key进行加密，得到Encrypt_AES_Key=RSA_Encrypt(AES_Key, RSA_Public) ---由于黑客不可能知道我们的私钥，所以他不可能知道客户端本地AES_Key\n\n客户端使用利用AES对称加密算法对要传输的内容（计作123456, OriginContent），得到Encrypt_Content = AES_Encrypt(AES_Key, OriginContent) ---由于黑客很难知道我们的AES_Key，所以他不可能知晓原始内容\n\n那黑客可以篡改请求吗？例如把前面的12345，转换为54321？\n\n如果黑客知道私钥(硬编码)确实可以。但是这就涉及到客户端加壳反编译等问题了。\n\n参考：\n\nhttps://cloud.tencent.com/developer/article/1175758","tags":["系统安全"]},{"title":"网站安全系列-SQL注入","url":"/backend_knowledge_architecture/security/sql_injection.html","content":"\n## 核心原理\n\nwhere a = '$input'\n\ninput 被攻击者蓄意构造，系统服务器执行了不符合预期的SQL语句，从而导致攻击者获取到了更多的的数据。\n\nwhere a = 'input' or 1=1;\n\n## 防范实践\n\n### 防范手段\n\n对输入进行特殊字符的转义\n\n### 最佳实践\n\n## 参考文章\n","tags":["系统安全"]},{"title":"网站安全系列-SYN-Flood攻击","url":"/backend_knowledge_architecture/security/sync_flood.html","content":"\nSYN-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击。\n\n它就是利用了TCP协议实现上的一个缺陷，通过向网络服务所在port发送大量的**伪造源地址**的攻击报文，就可能造成目标server中的半开连接队列被占满，从而阻止其它合法用户进行訪问。\n\n这样的攻击早在1996年就被发现，但至今仍然显示 出强大的生命力。非常多操作系统，甚至防火墙、路由器都无法有效地防御这样的攻击。并且因为它能够方便地伪造源地址。追查起来非常困难。它的数据包特征通常是源发送了大量的SYN包，而且缺少三次握手的最后一步握手ACK回复。\n\n原理：攻击者首先伪造地址对 server发起SYN请求。server回应(SYN+ACK)包，而真实的IP会觉得，我没有发送请求，不作回应。服务器没有收到回应，这种话，server不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。对于server的内存、带宽都有非常大的消耗。\n\n攻击者假设处于公网（**这句话不是很理解**，日后需要仔细研究），能够伪造IP的话，对于server就非常难依据IP来推断攻击者，给防护带来非常大的困难。\n\n#### 防范\n\n- 无效连接监视、释放\n\n这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。\n\n这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，”伤敌一千，自损八百“\n\n- 延缓TCB分配方法\n\n- 使用SYN 2Proxy防火墙\n","tags":["系统安全"]},{"title":"得到系列-《刘润5分钟商业学基础篇》","url":"/core/商业力/liurun_5fenzhongshangxueyuan.html","content":"\n奋斗 挣扎\n\n原始舒适区 = 零认知\n\n自由 不等于 自在\n\n无知即极乐，有知即痛苦\n\n逃避自由，回归母体\n\n认知：认出世界的真实性和虚幻性\n\n给思维一个支点：问题不可能由导致这个问题的思维方式来解决。\n\n认知越狱 双环学习（单环学习）\n\n表述的不是世界，而是自己的世界观。\n\n思维模式的投射，自然而然，毫无觉察，左右着我们自己，\n\n提问题的能力，让我们避免掉进陷阱的一个很重要的前提条件\n\n提问，猜测，反驳\n\n正确的提出问题之前，答案是不存在的。\n\nmatrix: 矩阵，线性多一个维度\n\n矩阵式认知 洞穴比喻\n\n认知优势，极大的竞争优势\n\n商业：最经典的商业概念 （一个人与企业外部）\n\n    消费心理学\n    行为经济学\n\n    商业社会的5个基本逻辑\n\n    互联网的5个基本定律\n\n    宏观经济学/微观经济学\n\n    一家企业的具体商业行为：产品、定价、营销、渠道\n\n管理：最有效的实战管理方法（一个人与企业内部）\n\n    管理的人：人性、心理\n\n    如何招人\n\n    如何培养优秀员工\n\n    如何有效激励\n\n    如何把业绩目标拆为可以执行的任务分配下去\n\n个人：如何让自己变得更值钱（一个人与自己）\n\n    时间管理\n\n    快速学习\n\n    职业化习惯\n\n    演讲/写作\n\n工具：如何借助外力，提升前三者\n\n### 01丨商业篇：消费心理学(5讲)\n\n消费心理学主要研究消费者在消费活动中的心理现象和行为规律。它的目的是研究人们在生活消费过程中，在日常购买行为中的心理活动规律及个性心理特征。\n\n一起商业的问题，都是人的问题。\n\n（我想学习心理学的其中一个目的就在于此，与其说我想学习心理学，我更想学的是消费心理学）\n\n01 心理账户：从最有钱的那个心理账户花钱\n\n概念\n\n心理账户：分门别类的存放在不同的账户中\n\n案例：音乐会丢门票\n\n运用：场景（巧克力卖给爱人、装修方案帮用户省了4、5个平方）\n\n小结：改变顾客对你商品的认知，让他从不愿意花钱的心理账户，转移到愿意为此付费的那个心理账户中去。\n\n02 沉没成本：不要为打翻的牛奶哭泣\n\n概念\n\n沉没成本\n\n对沉没成本的损失厌恶\n\n案例：英法造飞机\n\n运用：场景（买衣服讨价还价、办豪华的婚礼、交定金）\n\n小结：沉没成本，无好坏；我们要利用其他人对沉没成本的厌恶来增加对自己有利的交易的成功率；并且尽量去客服这种心理，去做出更加理性的商业判断\n\n03 比例偏见：贵和便宜，是相对的\n\n概念：人们对比例的感知，比对数字的感知更加敏感\n\n小结：\n促销：价格低的商品打折-； 价格高商品用降价\n换购，用1块钱换购50元的郭，比例是500%  PK 买1000元的东西，送50快\n比较：\n\n04 规避损失：得到100元，可以弥补失去100元吗？\n\n损失规避：负面效应 是 正面效应的 2.5倍\n\n配送费 pk  包邮 +20元的价格\n\n以旧换新：对旧的东西的损失规避\n\n换购 替代 打折； 无理由退货：拥有了害怕损失；\n\n05 价格锚点：拉个垫背的，显示你便宜\n\n80元一小时 PK 105元1天（完胜！！）\n\n避免极端； 权衡对比\n\n### 02丨商业篇：五大基础逻辑(5讲)\n\n进入商业世界，你必须了解的五大基础逻辑：流量之河、倍率之刀、价量之秤、风险之眼和规则之缝。\n\n01 流量：比电商更先进的零售方式是什么？\n\n流量成本 = 流量价格 / 潜在用户数\n\n现在伴随着商户的增多，广告成本（不竞价排名，根本就就无流量）已经成为流量成本的大头，流量成本已经已经很高了\n\n其实除了电商，还有更多的流量涞源：直播带货、线下复购、私域流量、社群等，这些可能都比开网店便宜\n\n02 倍率：哪有什么一分价钱一分货\n\n定倍率：定价/成本\n\n化妆品：20～50； 鞋子衣服：5～10倍\n\n创新的话，就可以把定倍率定高；如果是效率的话，就把定倍率降低（出版设）\n\n03 价量：该把货卖得更贵，还是卖得更多？\n\n04 风险：风险可以买卖，但你必须有一双风险之眼\n\n05 规则之缝：黄牛，商业世界的黑客？\n\n### 03丨商业篇：五大基本定律(5讲)\n\n进入互联网世界，必须要学习的五大基本定律：信息对称、网络效应、边际成本、长尾理论和免费。\n（跟互联网产品、创业等紧密耦合）\n\n01 信息对称：在美国，你会吃麦当劳吗？\n\n02 网络效应：互联网与生俱来的洪荒之力\n\n03 边际成本：理论上，你可以服务全人类\n\n04 长尾理论：商业的未来是小众市场？\n\n05 免费：所有的免费，都是“二段收费”\n\n#### 04丨商业篇：行为经济学(5讲)\n\n行为经济学是将行为分析理论与经济运行规律、心理学与经济科学有机结合起来。听起来可能有些抽象，但实际上它的基本理论很简单：人类不是机器人。\n\n01 结果偏见：抓住老鼠的就是好猫？\n02 适应性偏见：为什么我们会喜新厌旧？\n03 鸡蛋理论：为什么妈妈们喜欢在朋友圈晒娃？\n04 心理概率：全世界一半的娃，都丑到了平均水平以下\n05 凡勃伦效应：不买最好，只买最贵\n\n05丨商业篇：微观经济学(5讲)\n\n微观经济学的研究方向：微观经济学研究市场中个体的经济行为，亦即单个家庭、单个厂商和单个市场的经济行为，以及相应的经济变量。\n\n01 供需理论：看见那只看不见的手\n02 边际效用：为什么麦当劳的可乐免费续杯？\n03 机会成本：你到底是赚了，还是赔了？\n04 激励相容：自私是共同获益的原动力\n05 交易成本：企业的边界在哪里？\n\n06丨商业篇：宏观经济学(5讲)\n\n宏观经济学，是以国民经济总过程的活动为研究对象，主要考察就业总水平、国民总收入等经济总量，因此，宏观经济学也被称做就业理论或收入理论。\n\n01 节约悖论：居民越节约，国家越贫穷吗？\n02 看得见的手：张维迎和林毅夫在辩论什么？\n03 人口抚养比：4亿人不工作后，你打算怎么办？\n04 泡沫经济：用20年的积蓄，买几朵郁金香\n05 再分配：你赞成给全中国人民无条件发钱吗？\n\n07丨商业篇：金融和法律(5讲)\n\n金融是一种交易活动，传统金融的概念是研究货币资金的流通的学科。而现代的金融本质就是经营活动的资本化过程。\n\n01 风险投资：最疯狂的心，和最冷静的脑\n02 合伙人制度：资本和人才，哪一个更重要？\n03 商品证券化：可以只买LV两个字，不买包吗？\n04 庞氏骗局：金融界的万骗之祖\n05 互联网金融：金融的本质，是风险买卖\n\n08丨商业篇：产品(5讲)\n\n产品是指能够供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。\n\n01 企业能量模型：你陪客户喝酒，是因为做产品没有流汗\n02 品牌容器：不被消费者优先选择的，不叫品牌，叫商标\n03 爆款：长尾爆款，才是真正的未来\n04 用户代言人：转身，成为用户的代言人\n05 最小可用品：用最快的速度、最低的成本犯错\n\n09丨商业篇：定价(5讲)\n\n定价策略，通常是影响交易成败的重要因素，同时又是市场营销组合中最难以确定的因素。\n\n01 渗透定价法：把自己逼疯，把对手逼死\n02 撇脂定价法：为什么手机越卖越便宜？\n03 组合定价法：自己装配汽车花的钱，能买12辆整车\n04 价格歧视：让有钱人为同一件商品多付钱\n05 消费者定价：定价权，能交给消费者吗？\n\n10丨商业篇：营销(5讲)\n\n市场营销是指，企业发现或挖掘准消费者和众多商家需求，从整体的营造以及自身产品形态的营造去推广、传播和销售产品，主要是深挖产品本身的内涵，切合准消费者以及众多商家的需求，从而让消费者深刻了解该产品进而购买的过程。\n\n01 定位理论：占领市场之前，占领心智\n02 饥饿营销：金杯银杯，不如排队的口碑\n03 技术采用生命周期：跨越死亡之井\n04 危机公关：撒硬谎，道软歉，就是作死\n05 独特销售主张：只溶在口，不溶在手\n\n11丨商业篇：渠道(5讲)\n\n渠道通常是指商品销售路线，是商品的流通路线，所指为厂家的商品通向一定的社会网络或代理商而卖向不同的区域，以达到销售的目的。\n\n01 深度分销：进入市场的毛细血管\n02 销售激励：如何把销售变成虎狼之师？\n03 全渠道营销：把一切的触点，发展为渠道\n04 社区商务：离消费者越近，越有价值\n05 反向定制：根治“库存”顽疾的最有效方法\n\n12丨商业篇：互联网营销(5讲)\n\n互联网好比是一种“万能胶”将企业、团体、组织以及个人跨时空联结在一起，使得他们之间信息的交换变得“唾手可得”。市场营销中最重要也最本质的是组织和个人之间进行信息传播和交换。\n\n01 社群经济：自带高转化率的流量\n02 口碑经济：自带流量的粉丝\n03 单客经济：终生免费的流量\n04 引爆点：像病毒一样传播\n05 红利理论：会冲浪的人，必须也要会游泳\n\n13丨商业篇：商业视野(11讲)\n\n如何在现实生活中熟练使用前面学到的商业知识，是我们要修炼的内功。因为每一件事情背后，都有其商业逻辑。\n\n01 对赌基金：每一件事情背后，都有其商业逻辑\n02 雇佣客户：让客户帮你管理员工\n03 农耕式经营：你是在狩猎，还是在农耕\n04 打开慧眼：美国有没有互联网思维\n05 社会责任：用商业的理念做公益的事业\n06 去中心化：商业的世界，必须要有一个中心吗？\n07 零边际成本社会：未来会不会所有商品都免费？\n08 人工智能：你的工作，会被人工智能取代吗？\n09 奇点临近：据说2045年，“奇点”将要临近？\n10 基因技术：如果你能活120岁，你打算如何规划人生？\n商业篇总结｜70个即学即用的商业套路，全在这儿了\n\n14丨管理篇：管理的本质(5讲)\n\n管理是一种有价值和道德取向的工具，它的对象是人所进行的工作，因此管理者一定要与人打交道，他们必须面对包括他们自己在内的人性的善与恶。\n\n01 激发善意：尽力来自于本份，尽心来自于善意\n02 设计系统：分钱，花钱，赚钱\n03 知人善用：把合适的人，放在合适的位置上\n04 反求诸己：发而不中，行有不得，反求诸己\n05 面向业绩：梦想归梦想，绩效归绩效\n\n15丨管理篇：组织和激励(10讲)\n\n激励机制是指通过特定的方法与管理体系，将员工对组织及工作的承诺最大化的过程。\n\n01 马斯洛需求理论：激励就是发现需求，满足需求\n02 双因素理论：从“应得的”到“太好了”\n03 期望理论：“跳一跳，够得着”的奖励，才是激励\n04 X-Y理论：左手激励 ，右手压力\n\n胡萝卜加大棒\n\n坚守底线（有些错误可以犯，但有些例如道德缺失这种不可容忍）\n提高要求（工作目标，必须要跳一跳才能够够得到；工作任务，一定要好好管理好时间才可以完成）\n    松弛的工作状态，轻松的目标，容易让人懈怠松散\n赏罚分明，赏罚要及时，当众\n\n05 公平理论：工资是否应该透明？\n\n员工的激励程度源于自己和参照对象的报酬和投入的比例的主管比较的感觉。\n\n内部公平\n    建立专业的薪酬福利体系（薪资对应责任、奖金对应绩效、股权对应潜力）\n    仅制定规则，不具体分配奖励\n外部公平\n    同时保证内外不公平很难，薪资倒挂问题\n个人公平\n    规则清晰，赏罚分明，把权利锁在笼子里\n\n总之，用严明的规则，给员工公平感和安全感。\n\n06 责权利心法：老板做员工的事，员工讨论国家大事\n\n在任何一个管理单元上，权利、责任、利益，这三件事情必须要同时、对等的发生在一个主体身上。\n\n权利独大，将会导致权力寻租（不带责任的徇私舞弊）\n利益独大，就会引发内耗冲突（肥缺，抢资源，分业务）\n责任独大（权力小、利益小===》 消极怠工）\n\n07 分权机制：考核结果，还是考核行为？\n\n美国，联邦制国家，中央政府下的每一个州，又是一个独立的主权单位（不违背宪法），对州的“最终结果”负责。---联邦分权\n每一个州政府下面，立法、行政、司法三权分立。每一个部门对自己职能范围内的“自身行为”负责。---职能分权\n\n职能分权：执行简单，容易专注，效率很高，但是对管理要求高\n联邦分权：考核简单，容易激励，主动性高，但是对员工要求高 ----- 独立的电商失业部门\n\n自身行为与最终结果的因果关系是否明显，有没有必然的因果关系\n如果明显，很容易根据结果反推行为，那么采用职能分权制\n如果不明显，采用联邦分权制，例如销售，分地区，分行业。\n\n08 组织模式：羽毛球双打、足球队、交响乐队，还是军队？\n\n组织模式：把职能分权、联邦分权两个基本单元组合在一起的方式。\n\n羽毛球双打：联邦分权制，信任\n足球队：职能分权制，战略打法\n交响乐队：职能分权制，人数很多，上百人，靠的是流程\n军队：职能分权制，人数更多，靠的是奖惩\n\n09 阿米巴模式：内部市场化的组织模式\n\n内部定价的管理体系：需要有一个类似于发改委的机构，尽量公允的给每一个部门的服务定价\n基于职能部门的利润和总的工作时间，计算出单位时间利润，作为核算制度\n利润之心，员工收益与公司整体利益挂钩，而不是完全与阿米巴的绩效挂钩\n\n10 手表定律：一个员工，不能有两个老板\n\n手表定律，不知道听谁的\n\n设计组织的两个原则：\n（1）一个上级原则-创业中一定要有绝对控制人\n    超级指挥，领导的领导找你干事。\n（2）一致管理原则\n    不仅受流程管理，还受流程（流程执行平等）、绩效指标  的管理；所以切莫有冲突\n\n16丨管理篇：知人善用(20讲)\n\n企业的组织结构设计实质上是一个组织变革的过程，它是把企业的任务、流程、权力和责任重新进行有效组合和协调的一种活动。\n\n01 变招为抢：找人，是天底下最难的事情\n\n抢人、求人\nCEO（COO成熟期运营，CSO转型期战略，CHO初创期人才)\n转变心态，变招为抢\n\n02 套娃现象：不用比自己优秀的人，企业将走向衰落\n\n善用比我们更优秀的人\n为什么喜欢招不如自己的人：\n（1）不安全感，担心自己被替代（2）容易沟通，容易高效率的做低效效果的事\n\n如何解决：\n（1）给人以安全感\n（2）解决制度问题\n    直属经理的上级参与面试，做最终决策\n    设定用人标准，高于团队平均水平\n    直属经理连续两次选人失误（新进员工垫底10%），则扣除奖励\n（3）解决自身问题（CEO是最大的套娃）\n\n03 态度和能力：鱼头美女身，美女头鱼身，你选哪一个？\n\n想干 X 能干  = 态度 X 能力 = 绩效\n态度决定一切（改变态度的难度要远远大于改变能力）\n\n![态度能力四象限](http://cdn.b5mang.com/2021217232054.png)\n\n04 拒绝面霸：面试的巨人，行动的矮人\n\n面试官的三个心理缺陷：\n首因效应（避免让面霸先入为主）、光环效应（避免“以貌取人”、“以简历取人”，避免以偏概全）、近因效应（对最后一个或者说面试的最后部分印象最强烈）\n\n（1）岗位说明书（职责是什么、需要的能力是什么）\n（2）制度（多轮面试、罗列每一项能力需要的题目，避免面试官随意发挥）\n（3）面试培训\n\n05 面试公关：你们说回去等消息，后来给消息了吗\n\n有面必答、尽量委婉、期待未来、统一回复\n\n为什么招聘\n（1）短期、解决业务/运营或者技术问题\n（2）中期、实现业务/运营或者技术目标\n（3）长期，确认业务/运营或者技术远景\n\n基于业务倒退，需要什么组织和岗位，以及什么样的经验（必须的）与能力（基于经历与成就来推断）\n\n06 蘑菇定律：谁跟我谈战略，我开除谁\n\n培养新人\n\n1. 做务实的事情（从最基本的事情做起）\n2. 给足够的养分（选择合适的小蘑菇，然后有计划的轮岗培训）\n\n年轻的基层新员工，能力不强，自视清高。\n\n07 师徒制：有人敢欺负你，就报我的名字\n\nmentor让你更快的融入公司\n\n（1）严格设计制度\n\n08 情境管理：他是钉子你用锤子，他是螺丝你用改锥\n09 鲶鱼效应：用危机和竞争，激活团队\n10 贝尼斯定理：让员工的脚步，跟上你的思路\n11 不值得定律：你是想卖一辈子糖水，还是改变世界\n12 懒蚂蚁效应：懒，是因为勤奋到没时间\n13 热炉法则：把自己的权力关进笼子里\n14 拜伦法则：你那不叫授权，你那叫授责\n15 波特定律：扔掉心中的错误放大镜\n16 员工流失率：没解雇过员工，不是好管理者\n17 职业生涯：你的公司有“户口制度”吗？\n18 酒与污水定律：给你的组织，装一个净水器\n19 离职面试：多一个朋友，少一个敌人\n20 前员工：你的公司有“前员工俱乐部”吗？\n\n17丨管理篇：反求诸己(15讲)\n\n管理之道惟在用人。人才是事业之根本，可以说得人才者得天下，失人才者失天下。\n\n01 古狄逊定律：人生中的第一个管理问题\n02 权力接受论：权力不是领导给的，权力是员工给的\n03 任务分解：不会把目标翻译成任务，要你何用？\n04 推功揽过：打妖怪你去，背黑锅我来\n05 刺猬法则：亲密，但是不能无间\n06 独立损益表：你的部门，有必要存在吗？\n07 奥卡姆剃刀定律：如无必要，勿增实体\n08 管理六字真言：抓大、放小、管细\n09 关键绩效指标：坐进你的管理驾驶舱\n10 目标管理：不但要锁死目标，更要锁对目标\n11 企业三法宝：愿景、使命、价值观\n12 战略思考：不要用战术的勤奋，掩盖战略的懒惰\n13 组织：就是信息流动的方式\n14 决策理论：如何做出好的决策\n15 平衡艺术：这不是一个坏问题，但我没有一个好答案\n\n18丨管理篇：面对业绩(5讲)\n\n管理者如果要提高组织的效率，首先要有具体的效率标准作为衡量的依据，主要包括管理队伍的规模、素质和结构。\n\n01 项目三角形：优质、快速或廉价，只能选两样\n02 六西格玛：变态的质量，源自于变态的过程管理\n03 财务报表：能用数字讲故事的三张报表\n04 风险管理：悲剧里挖出来的学问\n05 向上管理：你敢管理你的老板吗？\n\n19丨管理篇：管理误区和企业周期(11讲)\n\n创业管理不同于传统管理。它主要研究企业管理层的创业行为，研究企业管理层如何延续注入创业精神和创新活力，增强企业的战略管理柔性和竞争优势。\n\n01 破窗效应：无序邀请无序，混乱引发混乱\n02 旁观者效应：责任除以二等于零\n03 帕金森定律：“大企业病”有得治吗？\n04 彼得原理：别把晋升当激励\n05 墨菲定律：只要可能出错，就一定出错\n06 企业生命周期：向着悬崖狂奔\n07 管理阶段：别把正确的方法，用在了错误的阶段\n08 共同体：降一半工资，委以重任，你干吗？\n09 创业管理：因为你是微软的，所以减一分\n10 永续经营：长生不老，不如养儿防老\n管理篇总结｜65个最有效的实战管理方法，都在这儿了\n\n20丨个人篇：高效能养成(15讲)\n\n01 思维转换：你可能连杯子都要换掉\n02 成熟模式图：独立，是不成熟的表现\n03 积极主动：别让消极，把你拉入海底\n04 以终为始：别把追求成功的梯子，搭错了墙\n05 要事第一：我不忙，我只是时间不够\n06 双赢思维：我要赢，你也要赢，否则就别干\n07 知彼解己：先理解别人，再被别人理解\n08 统合综效：天啊，太棒了，居然还可以这样\n09 不断更新：把优秀，变成一种习惯\n10 思维习惯：从狭窄的5%，跨度到广阔的95%\n11 时间成本：到底是花时间做，还是花钱买？\n12 GTD:让大脑用来思考，而不是用来记事\n13 猴子理论：多问一句“你觉得呢？”\n14 三八理论：人生的不同，是由第三个8小时创造的\n15 番茄工作法：人，真的可以三头六臂吗？\n\n21丨个人篇：职业素养(6讲)\n\n01 微信礼仪：再问“你好，在吗”，我就拉黑你\n02 邮件礼仪：这辈子，你们只会在邮件里“见字如面”\n03 时间颗粒度：是一个人的职业化程度\n04 事实和观点：事实有真假，观点无对错\n05 职业化：就是商业世界的教养\n专题总结：如何快速实现职业化的转变？\n\n22丨个人篇：学习能力(5讲)\n\n01 幸存者偏见：看不见的弹痕最致命\n02 库伯学习圈：知识，是经验的升华\n03 知识技能态度：为什么人类不擅长谈恋爱？\n04 私人董事会：作为自己的CEO，你有“私人董事会”吗？\n05 快速学习：如何用20小时，快速学习？\n\n23丨个人篇：逻辑思考力(10讲)\n\n01 六顶思考帽：从对抗性思考，到平行思考\n02 批判性思维：大胆质疑, 谨慎断言\n03 全局之眼：冻死在那个不存在的冬天\n04 逆向思维：电吹风的反面，是吸尘器\n05 正向思维：做一个“因果逻辑收集者”\n06 同一律：白马到底是不是马？\n07 矛盾律：理发师的头是谁理的？\n08 排中律：生存，还是毁灭，没有中间状态\n09 三段论：一眼识别诡辩的五个方法\n10 归纳法：几乎所有的知识，都始于归纳法\n\n24丨个人篇：谈判策略(10讲)\n\n01 定位调整偏见：自己先开价，还是让对方先开价？\n02 权力有限策略：你的这个要求，我要请示一下\n03 谈判期限策略：女生为什么会逼婚？\n04 出其不意策略：击穿对手的心理防线\n05 双赢谈判：我多拿一元，你就必须少拿一元吗？\n06 同理心：千般能力的共同心法\n07 自我认知：不偏不倚的自我认知\n08 自我控制：自律即自由\n09 自我激励：真正优秀的人，都自带鸡血\n10 人际关系处理：你的情感账户余额不足，请充值\n\n25丨个人篇：沟通演讲(10讲)\n\n01 认知台阶：你不是在讲，你是在帮助他听\n02 画面感：用画面感，增加语言的带宽\n03 开场和结尾：精彩绝伦的开场，和余音绕梁的结尾\n04 即兴表达：现场组织语言能力，是你的厨艺\n05 演讲俱乐部：从对着镜子，到对着活人\n06 快乐痛苦四原则：我有一个好消息，一个坏消息，你先听哪一个？\n07 写作心法：如何写出一篇好的专栏文章？\n08 电梯测验：大WHY，小WHAT，和一带而过的HOW\n09 如何开会：开会，是一个用时间换结论的商业模式\n10 精准提问：是沟通界的C2B\n\n26丨个人篇：创新与领导力(11讲)\n\n01 减法策略：灵感，其实就在你的盒子里\n02 除法策略：冰箱和空调，可以变成一个产品吗？\n03 乘法策略：空气清新剂 x 2 = 提神清新剂\n04 任务统筹策略：向《火星救援》，学创新套路\n05 属性依存策略：给属性装上一根进度条\n06 专注：藏在“威胁、此刻、重要”后的大猩猩\n07 集中：你是小公司里的胖子，还是大公司里的瘦子？\n08 变革：透过时间轴、概率轴、和博弈轴看世界\n09 快速：天下武功，唯快不破\n10 远见：是尽可能接近未来的推理能力\n个人篇总结｜65个“让你更值钱”的习惯养成方法，都在这儿了\n\n27丨工具篇：战略工具(10讲)\n\n君子性非异也，善假于物也。\n\n01 MECE法则：透过结构看世界\n\nMECE: 不重不漏\n几个原则：谨记分解的目的（分解是在哪一层进行的），避免层次混乱，借鉴已有成熟模型\n\n02 波特五力模型：一家小龙虾餐厅面对的五种竞争作用力\n\n直接竞争对手：现在的竞争对手多吗？是不是已经过度竞争了？\n顾客：顾客形成联盟，会对商家带来巨大的谈判压力，从而压缩自己的谈判空间\n供应商：自己在供应商那里是否足够重要，越重要，议价空间越大\n潜在新进公司：储值卡，增加用户迁移成本\n替代性产品\n\n03 波士顿矩阵：你的公司有现金牛，明星，问题，和瘦狗吗？\n\n公司想要成功，必须拥有市场增长率与市场份额各不相同的产品组合\n\n![波士顿矩阵](http://cdn.b5mang.com/2021218181032.png)\n\n发展战略、保持战略、收割战略、放弃战略\n\n04 SCQA架构：你不是没有重点，你是没有结构\n\n结构化表达工具-情景（Scene）-冲突（Complication）-问题（Question）-答案（Answer）\n\n05 通用电气矩阵：打不赢你，那我就怼死你\n\n![通用电气矩阵](http://cdn.b5mang.com/2021218185227.png)\n\n06 正态分布&幂律分布：你喜欢倒钟型行业，还是尖刀型行业？\n07 PEST模型：趴下来仰视微观之前，先站起来俯视宏观\n08 平衡计分卡：你想要鹅下蛋，还是吃鹅肉？\n09 SWOT分析：如何用科学的方法，追到女神\n10 商业模式画布：商业模式就是“你怎么挣钱”吗？\n\n28丨工具篇：博弈工具(10讲)\n\n01 纳什均衡：明明可以“共赢”，为什么他们“损人不利己”？\n02 囚徒困境：向香港电影学习如何破解“囚徒困境”\n03 智猪博弈：不懂搭便车，你连小猪都不如\n04 公地悲剧：三根救命毫毛，为何只给孙悟空？\n05 重复博弈：诚信是一种与这个世界重复博弈的心态\n06 不完全信息博弈：你有你的“空城计”，我有我的“木马计”\n07 拍卖博弈：让时间最不值钱的旅客下飞机\n08 博弈游戏：博弈游戏，有时也是吃人的陷阱\n09 零和博弈：吃着碗里的，看着锅里的，想着田里的\n10 一报还一报：用惩罚回报恶行，用善行回报善行\n\n29丨工具篇：决策、管理、思考(15讲)\n\n01 决策树：如何用决策树来选择相亲对象？\n02 德尔菲法：70年前发明的高科技：人脑云计算\n03 KT法：把决策的艺术，变成一门技术\n04 麦穗理论：如何选择人生中最大的那支麦穗？\n\n05 基于数据决策：决策，就是与这个世界的博弈\n\n06 OKR：KPI是秒表，OKR是指南针\n\nObjective KeyResult\nOKR不是绩效考核工具，并不能解决绩效考核问题。\nKPI是绩效考核工具，但他不是万能的；因为有些绩效是不可量化的，只能主观评分，比如360度环评。\n360度环评：通过多方均衡，让主管评分，尽量接近客观。\n\nOKR是目标管理工具，主要目的在于让一个无法用数字考核的团队，通过层层分解的目标与关键任务，向同一个方向前行。\n\n实施OKR的四个关键：\n（1）目标要有野心，关键结果要可衡量\n（2）最多五个目标，每一个目标最多5个关键结果，要聚焦\n（3）从公司到团队到个人层层分解\n（4）所有OKR公开、透明\n\n07 SMART原则：有“OKR”这把刀，更要有“SMART原则”这套刀法\n\n示例：O（目标）：打造业务最好的产品\nKR1(关键结果1)：持续提高产品质量\nKR2(关键结果2)：不断创新，增加新功能\nKR3(关键结果3)：听取最终用户意见，提升满意度\n\n针对以上OKR打分，不同的人会给出不同的评分，原因在于目标不符合SMART原则\n\nKR1(关键结果1)：持续提高产品质量\n\n目标一定要Specific(具体的)，不可模棱两可\n问题：什么叫产品质量？没有具体的界定，就无法评判、衡量与执行。\n新的KR: 消灭致命缺陷数；降低严重的产品缺陷数；提高应用商店app评分\n\n目标一定要Measurable（可衡量的），对标准不可有争议\n问题：提高多少评分，降低多少数量？\n新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app评分从4.0提升到5.0\n\n目标一定要Attainable（可实现的），目标不能不切实际，跳一跳要能够得着\n问题：评分5分的app存在吗？\n新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app评分从4.0提升到4.5\n\n目标一定要Relevant（相关的），目标不能与自己的工作无关\n问题：app提升到5分，一定和产品质量提高有关系吗？是不是其他新功能或者外观导致呢？应用质量与app评分有相关性，但是不够强。\n新的KR：致命缺陷数保持为0；严重缺陷数减少50%；app store的差评中，汇报产品缺陷的比率减少50%\n\n目标一定要Time-Based（有时间限制的），目标不能无限拖延\n问题：完成上面的目标需要多久呢？1年吗？还是几个月？\n新的KR：致命缺陷数保持为0；严重缺陷数在三个月内减少50%；app store的差评中，汇报产品缺陷的比率在三个月内减少50%\n\n08 PDCA循环：交待给你的事办完了，就不能回个话么？\n\n09 项目复盘：把所有的经验教训，都变成组织能力\n10 MBTI：MBTI是算命，娱乐，还是性格测试？\n11 头脑风暴：用数量带动质量，用点子激发点子\n12 思维导图：你是用它记笔记，还是把它当作思考工具\n13 5W2H法：集齐七个问题，让思维更缜密\n14 5WHY法：追问5个为什么\n15 二维四象限：太极生两仪，两仪生四象\n\n30丨工具篇：沟通工具(5讲)\n\n01 一对一会议：请把和下属的1:1会议，放入日程表\n02 罗伯特议事规则：如何用“十二原则六步法”开好一个会\n03 Scrum：\"死磕自己\"是种精神，但更是种方法\n04 视觉会议：让右脑一起来开会\n05 作战指挥室：外部越是剧烈变化，内部越要集中办公\n\n31丨工具篇：高效率工具(11讲)\n\n01 白板：如何随时随地、无边无际地思考？\n02 移动办公：整个世界都是你的办公室\n03 电子书：你每年读的书，有100本书吗？\n04 知识管理：用软件帮助收集篮“大肚能容”，吃尽知识\n05 云服务：任何时候任何地点，通过任何设备，访问任何文件\n06 搜索工具：人生80%的问题，早就被人回答过\n07 邮箱日历联系人：把基本功，耍得虎虎生风\n08 协同软件：如何避免与懒惰握手言和？\n09 休息运动：如何最高效地休息，和运动？\n10 我的一天：君子性非异也，善假于物也\n工具篇——50个让你提高效率的工具，都在这儿了\n\n32丨刘润专访：客座教授(51讲)\n\n罗胖：我为什么开始做内容付费？\nKeep王宁：如何在少花钱的情况下，增长用户？\n投资人刘芹：为什么我会看好小米模式？\n蒋昌建：如何训练自己的演讲风格？\n小米刘德：未来，人们将怎么买买买？\n曲向东：小众市场如何实现持续增长？\n王东：传统行业如何拥抱电商时代？\n吴士宏：大企业如何应对市场变化？\n王欣：学做卓有成效的管理者\n白鸦：做商家背后的服务者\n叶国富：名创优品，不搞电商也能赢\n慕容引刀：如何打造一个经久不衰的IP？\n张蕴蓝：大数据时代最牛的“裁缝”\n毕胜：一切商业模式，都是为了赢得更好的性价比\n潘江雪：公益投资也要找“痛点”\n百度曾良：所有的技术，都是为了让消费者获得便捷高效的服务\n百姓网CEO王建硕：公司是为什么存在的？\n脉脉CEO林凡：大数据如何进行商业变现？\nKen Qi：如何精准找到和企业高匹配度的人才？\n东方航空韦志林：企业转型过程中，如何获得各方认同？\n荣耀中：如何持续保持领先优势？\n梁小虹：用工匠的严谨支撑科技的创新\n真格李剑威：投资人最大的价值是提高赢的概率\n陈葵：Twitter究竟是怎么运行的？\n周健工：内容付费的核心是持续提供有价值的信息和分析\n方建华：我为什么会大规模开实体店？\n薛兆丰：如何做个理性明白人？\n宗毅：用钱投票 选出好人才\nStephen M. R. Covey：始终要明白你想达到的目标是什么\n臧勤：用创新和增值服务获得溢价收益\n孙振耀：战略是决定对的事，管理是把这个事情做对\n米雯娟：人工智能＋教师＝未来教育生态系统\n肖知兴：企业家之间高价值的社交圈是怎么形成的？\n爱德华·德博诺：思维质量决定未来质量\n蒋盛志：借助互联网打造持续的注意力经济\n于揚：未来的公司都是AI公司\n古典：在未来，哪些职场能力是必需的？\n张荣耀：先颠覆自己，再颠覆行业\n小马宋：创意是营销的敌人？\n朱峰：如何用好莱坞的方式生产优质内容？\n韩都衣舍赵迎光：电商新品牌如何快速突围？\n\n电商相关：\n\n独特的定位\n\n郑亚旗：如何经营好一个长线IP？\n吴声：未来，什么样的新物种能获得机会？\n华米黄汪：做产品，如何找准消费者需求？\n李笑来：如何投资才能获得最大化收益？\neBay大中华区CEO林奕彰：国内企业如何开拓海外市场？\n崔聿泓：如何在一个已饱和市场实现弯道超车？\nDr.魏：如何从父母的需求中找到我们的机会？\n王凯：如何打造一款成功的内容产品？\n吴晓波：未来，中国企业最需要突破的地方在哪里？\n陈春花：如何激活员工积极性？\n\n33丨课程推荐书籍(5讲)\n\n01 商业书籍：商业不是一蹴而就，商业是一路走来\n02 管理书籍：MBA中，没有一门课叫“管理”\n03 个人书籍：个人升级，最重要还是认知升级\n04 工具书籍：刻意练习，人人都可以是自己的CEO\n05 刘润五本书：希望知识给你启发，求知过程给你更大启发\n\n34丨特别放送：加餐课程(25讲)\n\n全部课程总结：从基本功，到格斗术\n商业篇总结：商业世界的左脚、右脚，一步一步，从不踏空\n管理篇总结：战略大于组织，组织大于人，一错全错\n个人篇总结：所有问题，最终的最终都x是个人的问题\n工具篇总结：不要做装备派，要做个装备精良的实力派\n第二季特别放送｜直播复盘：未来商业，哪些行业最有前景？\n第二季特别放送丨独家分享：西门子公司全球高管大会演讲\n第二季特别放送｜商业地图：来自世界各地的商业智慧\n第二季特别放送｜商业思维在生活中如何灵活运用？\n第二季特别放送｜新零售：坪效高出同行5倍，盒马鲜生究竟做对了什么？\n加餐｜刘润：小米生态链千亿元收入背后的商业逻辑\n特别加餐｜直播复盘：“新零售”的本质就是定义效率\n特别加餐｜直播复盘：如果你自己是家公司，怎样更成功\n加餐丨世界顶级CEO教练给我的20条启示\n加餐丨为什么我们常说做to C 的人比较难去做to B ？\n加餐丨四处招人，可你缺的是人才吗？\n《每个人的商学院》轻读本，抢先预售\n新课邀请｜半秒洞察本质的人，注定拥有开挂的人生\n深度｜Costco火爆的秘密是什么？\n加餐丨刘润对话李丰：中国经济正在触底反弹，充满机会\n直播回顾一丨重启高效：远程办公六锦囊（附2月6日视频）\n直播回顾二丨企业自救指南：救命、治病、养生（视频版）\n直播回顾三丨一份各行各业的自救指南（视频版）\n直播回顾四丨疫情之后的机遇在哪里？（视频版）\n学习攻略 |《5分钟商学院·基础》使用说明书\n\n试题(1讲)\n\n毕业考试 | 你能从《5分钟商学院·基础》毕业吗？\n"},{"title":"通识系列-商业洞察力","url":"/core/洞察力/商业洞察力30讲.html","content":"\n## 认知思维提升\n\n不紧要看到元素，更要看到元素之间的关系。\n\n## 《刘润-商业洞察力30讲》提纲\n\n普通的人改变结果，优秀的人改变原因，顶级优秀的人改变模型。\n洞察力：透过现象看本质、然后改变模型的能力\n\n通过学习系统动力学，来提升的自己的洞察力。\n\n看透**系统**（比如手表里的各种精密齿轮），找到**动力**（比如发条、电池、或者人体动能），你就能洞察万物，然后根据动力的方向，预测未来\n\n### 搭建模型\n\n系统动力的虚的基础理论\n\n系统，就是一组相互连接的要素。当人在系统中时，是“系统”决定了个体要素的行为。\n\n真正深刻而不同寻常的洞察力，来自观察“系统”如何决定自己的行为。\n\n![洞察力](http://cdn.b5mang.com/20212322278.png)\n\n所有你无法解决的问题，都是因为你看不清。因为要真正解决问题，通常不是靠改变要素，而是改变要素之间的关系。\n\n系统要素的结构模块：变量、因果链、增前回路、调节回路、滞后效应\n\n![系统=要素*连接关系](http://cdn.b5mang.com/202123223727.png)\n\n#### 变量：流量改变存量，存量改变世界\n\n浴缸模型：变量 = 存量 + 流量\n\n第一，关注“核心存量”\n\n找到核心存量后，不遗余力的往里面注入流量。\n\n互联网公司：用户；投资机构：案例；医院：社会信任；讲师：用户口碑...\n\n第二，关注“流量增速”\n\n实力靠存量，潜力靠流量，赶超靠流量增速。\n国民财富是存量；GDP是每年新增的流量；6.5%的增幅，是流量增速。\n速度有滞后效应\n\n第三，关注“周转时间”\n\nT = 存量 / 流量， 效率的刻度， 效率往往是企业的生命线。\n\n#### 因果链：只看结果，是最low的管理方法\n\n因果链：就是变量之间增强或者减弱的连接关系\n\n警惕三个误区：\n\n第一，遗漏中间项\n\n通过找到并分析因果链条上的中间项，你可以发现那些藏得很深，但至关重要的因素。\n\n第二，迷信相关性\n\n相关是未知的因果；真正的洞察力，要可以始于相关性，但终于因果链。\n\n第三，颠倒因果链\n\n销售价格 《===》 生产成本\n\n你花了更多的钱生产，并不会导致用户愿意花更高的价格来买。价格由供需决定。\n\n透视因果，正确的还原因，药到病除；早早的推演果，防微杜渐。\n\n#### 增强回路：每家伟大的企业，都有一个旋转飞轮\n\n增强回路：良性循环，因增强过，果反过来增强因，形成回路，一圈一圈循环增强。追求极端\n\n百度，腾讯，淘宝的回路\n\n如何建立自己的增强回路：\n\n第一，找到自己的飞轮（罗列要素，确定因果关系，找到回路）\n\n第二，确定第一推动力（淘宝是选择用户还是选择商家？）\n\n第三，坚持不懈的推动\n\n#### 调节回路：你的计划是腾飞，世界的计划是回归\n\n调节回路：因增强果，果反过来减弱因，从而抵抗系统变化的因果回路。追求平衡\n\n（1）打破看不见的天花板（大公司的管理难题，本质上就是由于公司规模变大后形成了一个新的调节回路）\n（2）建立自我修复机制（为重大风险，设计自我修复的调节回路）\n（3）让阻碍变革者，成为变革受益者（找到变革阻塞者，调整激励机制，让他们受益）\n\n#### 滞后效应：教育难题\n\n如何识别和处理好“滞后效应“，有三点：\n\n第一，原因不一定在结果附近（培训的好处、股票的大涨始于三年钱研发资金的投入）\n第二，减少滞后，增加确定性（立刻表扬优秀的同学）\n第三，警惕由“滞后效应”引起的剧烈震荡（长鞭效应）\n\n![长鞭效应](http://cdn.b5mang.com/202123231810.png)\n\n如何解决：缩短<减少供应链环节>、平滑<根据长周期的历史数据安排生产>\n\n#### 搭建模型：白手起家，创业者如何找到自己的战略势能\n\n第一，核心存量（很多，包括声誉、成功案例、深刻洞察等）\n\n第二，关键因果链（收入，交易成本，战略定力：绝不去客户现场做销售）\n\n第三，增强回路：推动增长的飞轮（声誉 =》 学识 =》 作品 =》声誉）\n\nCEO核心职责：求之于势，不责于人。\n华为说：不能在非战略机会点上，消耗战略性资源。\n\n第四，调节回路：打破增长的天花板（时间）\n\n第五：滞后：饱和式创业\n\n![商业模型]](http://cdn.b5mang.com/20212323290.png)\n\n系统体检：检查系统（一个商业模型）是否健康\n（1）适应力：突然遭受外部冲击，系统自我修复的能力\n（2）自组织性：为了适应变化，系统自我突变的能力\n（3）层次性：通过把整体切分为局部，来控制系统信息风暴的能力\n\n如何提高适应力：\n（1）存量：库存\n（2）调节回路：周例会（介于执行结果之间的调节回路，关键在于纠偏）\n    管理者90%的工作是沟通；90%的沟通在于讨论风险；明确风险后，迅速调节\n\n如何提高自组织性-乱七八糟的生机勃勃胜过井井有条的死气沉沉（死于25岁，葬于75岁）\n自组织性：大雁\n（1）建立特区机制\n\n如何提高层次性（复杂，是成熟的代价；没有层级只能说明你还小）\n分层：避免信息风暴\n\n### 实操：解决难题-商业经验难题\n\n#### 还原大前提：过去有效，现在无效\n\n过去有效，现在无效，一定是所以来的某个隐含大前提消失了\n从方法到效果的因果链，断裂了；断裂原因是什么：\n隐藏的大前提，不见了\n\n超市：信息流、资金流、物流的集合\n超市商业模式：通过资金流差价，收回信息流成本\n隐含大前提：80%～90%的顾客看重商品后，都会购买。\n互联网 + 物流后 （资金流走线上支付，物流走快递；仅通过超市来检索信息流）\n如何破局：\n（1）加大难以在网上买到的商品比重，例如餐饮、娱乐\n（2）不再赚差差价，改为像品牌收取信息流展示费或者向用户收取会员费（佳世客）\n\n找到隐藏的大前提，进行还原：\n（1）时间前提\n（2）空间前提（某个健身房偶尔成功，是由于他在某个互联网公司旁边）\n（3）技术前提（“很难建立底成本的个人信用体系”技术前提，被蚂蚁金服干掉了，从而实现了“贷款可以没有抵押”这个新的模式）\n\n#### 突围边界墙：止步不前，无法跨越\n\n雀巢：从奶粉（遭遇边界）到咖啡（突破边界）\n\n边界墙：一种特殊的调节回路，刚性约束条件，设定的系统增长极限\n\n常见的刚性约束有哪些：\n（1）市场规模（最大可触达市场规模）\n    竞争对手的强弱，决定了你出发最大可触达市场规模的难度。\n（2）资源限制（将自己的商业模式建立在高速可再生资源上面：知识、流程、专利等）\n“我认识谁”，人力资源\n“我很能干”，个人能力，时间会成为限制\n“我家有矿”或者“独门手艺” 不可再生资源\n（3）法规限制（及早合规运行，否则不保证国家哪天便把口子赌上了）\n（4）技术限制（CPU不可以永远永远X86,因为技术遭遇了瓶颈）\n\n#### 安装缓冲器\n\n缓冲器：是专门用来平滑流（入）量波动的存量；缓冲对波动，用力缓缓释放系统瞬间冲击\n\n安装缓冲器之后，无法发挥极致效率，但是抗波动能力强。\n\n水库、配件库存、安全现金流、公共人才库\n\n牛B的CEO懂得：牺牲一定的效率（降低了响应变化的速度），用必要的缓冲器来对冲波动和猝死风险。\n\n安装哪些缓冲器：\n（1）安装应对“缺乏型波动”的库存型缓冲区：buffer思维、存款准备金\n（2）安装应对“过剩型波动”的蓄水池型缓冲区：蓄水池、车辆避震器、软件公司的“农闲项目”\n\n#### 跨域临界点-一直挺好，突然变了\n\n临界点的本质，是主导结构模式之间的切换\n\nC轮死：赢家通吃的“网络效应驱动”的增强回路，取代了“烧钱驱动”，成为系统的主导结构模块\n\n常见的四种临界点：\n（1）跨越质变点（投诉电话越来越多，然后没有了；水温越来越高，然后没有了）\n（2）跨越引爆点\n    引爆点：存量超过一个阈值，激活了一个正向增强回路\n    一个产品要做到足够优秀：要让大家用了之后，忍不住发朋友圈\n（3）跨越灭绝点\n    灭绝点：存量低于某一个阈值\b，激活了一个负向增强回路，从而加速衰败\n    最小可存活种群：在100～1000年内，一个物种为了有90%～95%的存活可能，所需要的最小个体数量\n（4）跨越失速点\n    失速点：当存量增长到一定阈值后，就激活了一个刹车式的调节回路\n    发展线下，扩大潜在用户规模，突围边界墙，才能重新获得速度\n\n#### 总结一波\n\n还原大前提，之前有效，现在无效，失效问题\n突破边界墙，止步不前，无法跨越，停滞问题\n安装缓冲器，起起落落，频繁波动，波动问题\n跨越临界点，一直挺好，突然变了，突变问题\n\n用症状解解决问题，解决的”是什么WHAT“的问题\n用原因解解决问题，解决的“怎么办HOW”的问题\n用根本解解决问题，解决的是“为什么WHY”的问题\n\n改变模型，是一切问题的根本解。\n\n### 实操：看透人心-管理难题\n\n人，是系统中最大的“变量”\n\n#### 上下同欲：让我的计划，成为员工的计划\n\n罗素艾柯夫的社会系统模型，看透**集体**\n\n所有问题，都是尚未解决的冲突！\n\n管理：企业有义务服务于员工，员工是独立的利益相关者。\n\n世界上，一共四种系统\n![四种系统](http://cdn.b5mang.com/202128172553.png)\n\n社会系统是唯一一个系统、个体都有意识的系统！\n\n要破产的茶叶公司，最后采用“让员工收购公司”的方式力挽狂澜。\n\n如何设计“上下同欲”模型：\n（1）参与约束\n    设计一个系统，确保用户加入系统获得的收益比不加入系统要多\n    股权激励、超过月薪*12的年薪制\n（2）激励相容\n    获取超预期收益的计划，符合“员工越自私，公司越盈利”原则。\n\n#### 群体压力：让员工说出真实的想法\n\n库尔特勒温 “群体动力学” 模型， 看透**群体**\n\n在群体中，表达不同，会收到某种调节回路，**群体压力**变大\n\n群体压力：当成员发现自己的意见和群体抵触时，会产生巨大的u压力，从而主动放弃观点，接受群体意见。\n\n达成一致意见的速度越快，说明群体压力已经在集体中扎根。\n\n群体动力学，切断调节回路：\n（1）魔鬼代言人（引入一个故意唱反调的人）\n（2）头脑风暴（重量而不重质；提出而不反驳）\n（3）名义群体法（先写观点，而不是先讨论）\n\n#### 结构性张力： 如何帮员工\n\n### 实操：预测未来-时间难题\n\n### 实操：终身练习-思维难题\n"},{"title":"通识系列-概率论","url":"/底层思维/数学/liujia_gailvlun.html","content":"\n## 学习概率论带给我的认知提升\n\n（1）首先我重温了概率论的主要内容：随机性、概率、独立；概率的几种计算方法（定义法、频率法、迭代法）；概率分布（正态分布、泊松分布、幂律分布、二项分布等）；贝叶斯定理\n（2）让我影响最深的是：大数定理（伯努利弱大数定理、切比雪夫强大数定理）、中心极限定理以及概率的公理化定义（如何一步步的从粗略变为精确）、概率 = 先验概率 * 调整因子\n\n## 《刘嘉概率论22讲》大纲\n\n概率论解决问题的本质：就是把局部的随机性转化为整体上的确定性。\n某一次结果的随机，是低层次的事；而概率论，是高层次，确定性的认知。\n\n![上帝在掷骰子](http://cdn.b5mang.com/20212103130.png)\n\n### 随机：随机性不等于不确定性\n\n概率论研究的是随机性，而不是不可确定性。不确定性包含随机性，随机性是不确定性的一种类型。\n什么是随机性：不可预测，灰犀牛事件\n什么是不确定性：结果不可预知（总体空间不可知，或者说总体空间大得出奇）黑天鹅事件\n\n区分三种随机：\n真随机：“测不准原理”：允许空无一物的空间产生少许能量，这个能量的诞生是完全随机的。\n效果随机：掷骰子、投篮等，如果把所有的因子全部计算清楚是可以得到精确结果的；只是太难了，所以从最终效果来看，结果很“随机”\n伪随机：看似无规律，但其实是潜在规律的，只是你窥探规律的成本足够大而已。例如计算机random函数就是伪随机，如果被黑客GET到随机数种子，是完全可以“预测“未来的。有限状态机是不可能产生真随机的。如果计算机要想得到效果随机，需要将随机算法与特定的物理实体建立联系。\n\n随机是世界的决定性力量。\n\n### 概率：对世界可能性的度量\n\n概率是随机事件发生可能性的度量。\n\n只要按照下面三个设定表达，任何事情都可以变成随机事件：\n（1）限定一个条件\n（2）从可能性的视角出发\n（3）对某个发生结果进行陈述\n\n概率的定量：随机事件子集 / 样本空间\n\n概率空间的完备性：\n黑天鹅事件的本质：这个事件之前是不在我们的样本空间中的\n\n我们对世界的认知，就是对样本空间完备性的认知。原子衰变到底能放出多少粒子？决定恒星运动的里到底有多少种？每一种突破性的进展，其实都在完善我们的样本空间。\n\n### 独立性：独立事件的相互关系\n\n赌徒谬误：抛硬币，已经连续5次正面了，第6次出现正面的概率肯定更小，大概率出现反面。\n\n热手谬误：抛硬币，已经连续5次正面了，第6次肯定还会大概率出现正面。\n\n独立事件：这是我们描述某些随机事件的数学模型罢了。很多看似独立的事件，其实都是相互有联系、相互影响的；我们在计算概率时，需要格外注意。\n\n### 概率计算：定义问题比计算更重要\n\n三大法则：\n（1）组合排列法则\n（2）乘法法则（同时发生，但需要独立事件。如果非独立呢？）\n（3）加法法则（互斥）\n\n真正困难的是：定义问题\n飞机失事两次的概率 VS 飞机再次失事的概率\n\n正确翻译现实问题，是概率计算最复杂的地方。概率思维的核心就在于准确的把现实问题转换成对的概率问题。\n\n### 概率度量：建立整体确定性的三种方式\n\n（1）定义法是一种等概率的设定，来源于自然界对称性的假设，是一种宏观尺度下的合理简化。\n    但是并不是所以的事件都是等概率的，例如一个人坏癌症的概率是多少。于是有了方法（2）\n（2）频率法是通过随机事件发生的频率来估算概率，要求实验或者数据尽可能的多。\n    但是我们有时候并不具备做多次试验的条件，例如登月成功的概率。于是有了方法（3）\n（3）迭代法强调不断通过迭代，可以在小规模数据下，针对事件的变化和个体的差异来度量概率。\n    先利用手头少量的数据做推测，甚至主管猜测一下，然后再通过收集新的证据不断调整概率。贝叶斯（最初的概率可能源于前两种）\n\n![偷看上帝的安排](http://cdn.b5mang.com/20212103151.png)\n\n### 频率法：概率是对发生频率的计算\n\n频率法的前提假设：一个实际事件的发生，是存在一个真实的、客观的的概率的。\n\n频率法在试验上得到了验证，但是**没有用**，直到努利给出了初步证明：大数定律\n切比雪夫版本大数定律：随机变量X的均值，方差\n\n在相同环境、重复试验的条件下，用历史数据预测未来是可行的，也是合理的。\n\n足够多：置信区间、精度误差\n\n### 大数定律：局部频率不是整体概率\n\n弱大数定律：试验数量越多，频率接近概率的**可能性**（注意：并不是100%）就越大。\n\n强大数定律：一定会接近真实概率\n\n现实中的频率都是局部频率。\n\n整体不需要对局部进行补偿\n\n整体通过概率对局部实施约束作用，具体如何作用呢？\n（1）错误的补偿思维：整体不需补偿来对局部产生作用，大数定律并不通过补偿来实现。大数定律不会对已经发生的情况进行补偿，而是利用大量的正常数据，削弱那部分异常数据的影响。\n（2）整体通过**均值回归**对局部起作用\n如果一个数据和他的正常状态偏差很大，那么他向正常状态回归的概率就会变大。产生作用的对象是：特殊的、异常的、极端的数据。\n\n### 数学期望：对随机事件长期价值的衡量\n\n个体的数学期望并不一样\n\n### 方差：围绕数学期望波动程度的度量\n\n方差的本质：对风险（波动性）的度量\n对抗方差：增大数据量，增大本钱\n\n![收集上帝的骰子](http://cdn.b5mang.com/2021210327.png)\n\n### 概率分布：认识现实世界的数学模型\n\n随机变量 与 概率分布\n\n用模型去不短逼近世界的真相\n股市：正态分布、柯西分布...未来更多\n\n### 正态分布：最简单、却最重要的概率分布\n\n三个特性：\n（1）均值就是期望\n（2）极端值很少\n（3）标准差决定胖瘦\n\n不同的正态曲线的比较：\n（1）只有均值不同（方差相同），能比较好坏\n（2）只有方差不同（均值相同），能比较波动（越矮胖，波动越大）\n（3）标准差与均值都不同，能比较专业与业余（专业：均值越大，方差越小；而业务则相反）\n\n### 中心极限定理：正态分布是概率分布的神\n\n无论样本源自什么分布，这些样本的均值，最终一定满足正态分布。\nhttps://www.zhihu.com/question/22913867\n\n合法性：中心极限定理\n正统性：正态分布是所有分布的参照系\n主宰性：正态分布是世界的宿命\n（1）正态分布普遍存在\n（2）所有分布最终都会变成正态分布\n（3）正态分布是信息熵最大的一种分布\n\n### 幂律分布\n\n幂律分布：随机变量越小，出现概率越大；越大数字，则出现概率越小；\n\n无标度：在任何观测尺度下，幂律分布都呈现同样的分布特征。\n（一般分布都有一个尺度范围，在这个范围内服从这个分布，超过这个尺度就不服从了；而幂律分布没有尺度的限制）\n\n例如：图书销量服从幂律分布；最畅销/前10销量 = 前10/前100 = 前100 / 前1000\n\n幂律分布让平均值、方差失去意识\n幂律分布让原本不会发生的极端事件发生：长尾效应\n幂律分布完全不可预测\n沙堆模型：砂崩规模与发生频率，服从幂律分布。\n\n幂律分布，有可能是对坑熵增的工具；水（无序）=》冰（有序），熵减\n在水变冰的临街状态，所有指标呈现出幂律分布。\n\n### 泊松分布：打开统计推断的大门\n\n泊松分布解决的问题：已知一个随机事件发生的整体概率，并且该概率服从正态分布；那么在某一段时间或者空间间隔内，这个随机事件发生次数的概率分布是多少呢？\n\n泊松分布，是正态分布的一种微观视角。（如果把时间尽可能的放长，泊松分布越来越接近于正态分布）\n![柏松分布](http://cdn.b5mang.com/20212317347.png)\n\n泊松分布的间隔是无记忆性的（独立性）\n\n泊松分布连接了概率与统计。\n\n### 假设检验：基于概率反证法的统计推断\n\nH0:零假设（如果这个假设成立，我们计算概率会特别方便）\nH1:备选假设\n\nP值：在H0假设下，当前现象以及更极端现象出现的概率。\n\n显著性水平：\n\n假设检验的弊端\n（1）忽略小概率事件（小概率事件真的有可能会发生）\n（2）导致系统性偏差（P值影响最终结论，但是P值大小由样本决定的，不通的样本就会得到不通的P值；也就是说，如果我不断改变样本，总能找到比较小的P值，推翻原假设） 邮件骗局-人人都是股神；你这一成功的一例，只是成千上万中的一组而已。他幸存了下来\n（3）显著性水平设置不好导致错误；水平应该依据问题以及领域而定\n（4）用错分不导致错误结论\n\n概率分布是假设检验的基础：利用概率分布来计算P值\n\n![猜测上帝的底牌](http://cdn.b5mang.com/20212103235.png)\n\n### 条件概率：贝叶斯公式的基础\n\nP(A|B) = P(AB) / P(B)\n\n一切概率都是条件概率\n很多看似没有条件的概率，只是把某些条件给忽略了。\n\n操纵条件，改变概率\n（1）辛普森案（家暴后发生杀妻的概率  VS 丈夫家暴妻子，并妻子已经死于谋杀的双重条件下，杀人凶手是丈夫的概率）\n（2）高频交易：尽量缩短事件片段，简化条件，把我关键因素\n\n条件概率量化了条件对随机事件的影响，但他只是表示统计意义上的相关性，并不代表因果关系。\n\n### 贝叶斯推理：概率是信心的度量\n\n概率问题：正概率问题（根据原因推结果）、逆概率问题（根据结果推原因）\n\n贝叶斯世界中：概率本质上对信心的度量，是我们对某个结果相信成都的一种定量化表达）\n\n贝叶斯推理的优势：\n（1）起点不重要，迭代很重要（经过足够多的迭代，无穷趋近于真理）\n（2）信息越充分，结果越可靠（生活里，我们总是在追寻更多的信息，把信息搞完备，就是为了运用尽可能多的信息，提高自己做判断的准确性）\n\n### 贝叶斯计算：定量解决逆概率问题\n\nP(A|B) = P(B|A) * P(A) / P(B)\n\nP(A|B)酒驾发生交通事故的概率\n\nP(A) 发生交通事故的概率，先验概率，先于经验，就是说在看到新现象、重新计算之前，基于经验甚至主观猜测的概率。如何使先验概率更准：分析历史数据、参考专家意见、平均设置概率\n\nP(B|A) / P(B) 调整因子，必须客观\nP(B|A) 发生交通事故的人当中，有多少是酒驾的（这个容易获取）\nP(B) 人们酒驾的概率（管中窥豹，利用样本数据来合理估计总体数据， 某一次检查中，酒驾人数 / 总检察数）\n\n### 主观与客观：不同的概率学派在争什么？\n\n### 一些原则\n\n（1）对抗直觉，能算就算\n（2）寻找条件，增大概率\n（3）相信系统，长期主义\n\n### 《刘嘉概率论22讲》下载地址\n\n![头像](http://cdn.b5mang.com/img_first.png)\n\n扫码关注公众号，回复“概率论”获取下载地址。\n"},{"title":"通识系列-数学通识","url":"/底层思维/数学/wujun_shuxuetongshi.html","content":"\n## 学习数学通识带给我的认知提升\n\n1. 良好的沟通是建立在精确的定义的基础之上的。而给事物一个精确的定义却没有那么容易，如同“无穷小”，“概率”。给到一个精确的定义，需要我们非常了解事物的本质，甚至需要颠覆我们的认知。“无穷小”、“概率”这些东西，并不是静态，而是一个过程、一种趋势，一种极限。\n2. 我们有理由这么相信：这个世界是完美的。如果一件事情在某些方面表现的没有那么“完美“，我们也许需要更深入的考虑一下是不是我没有窥探到事物的本质。例如：借助虚数，我们可以让一元N次方程，在复数范围内有N个解。\n3. 数学提供了很多工具用来解决很多类似的问题。在解决现实问题的时候，我们需要做的是将现实问题转换为正确的数学问题，然后借助正确的工具去求解。一些数学问题的解答，会有一些“奇技淫巧”，这些解答固然巧妙，但是并没有可复制性，不能举一反三的解决更多的问题。反过来，我们更提倡的是给某一类问题找到通用解法。这类解法可以更笨一些，但是一定要通用。\n4. 模糊的正确胜过精确的错误。这里的正确、错误指的是更高层次的正确和错误，指的是解决一个问题的总体框架、算法是否有问题；而这里模糊、精确指的的低一个层次的东西，是细节；模糊的正确指的是：总体框架、算法是没问题的，只是其中一些细节不够清晰，待明确；这种思路显然比精确的错误要更好。\n5. 公理化体系：以一些不证自明的道理或者事实为原地，通过逻辑推理，得到一个个定理，进而得到一整套完整的知识体系。这个是欧几里得的《几何原本》告诉我们的。其实不只是数学，管理学、经济学、法律都是源自这个思路。在管理学中，一个企业的远景与使命决定了企业为何而存在，而企业的企业文化决定了企业内外的人的相互关系以及价值观。经济学也有自己的前提假设-市场中的每一个人都是理性的，自私的。法律的话，在某些法律中会提到“法律面前人人平等”，“私有财产神圣不可侵犯”等论断，这些论断从何而来呢？ 这些只不过是一些不能再简单的大道理罢了。\n6. 跨界创新：几何与代数的完美结合，笛卡尔将两者结合，可以更加方便的用彼此来解决自己的一些问题。其实，所谓的创新不外乎是各项生产要素的重新组合而已。更重要的是要开阔自己的思路，不要禁锢在自己的领域之内。\n7. 数（自然数、整数、有理数、无理数、虚数、复数）数，存在吗？有理数，存在吗？数、有理数其实还没有拿难以理解。为什么呢？因为在现实世界中，有实物可以与之对应。数，就是物体的数量；有理数，就是我从10份中拿走了自己的7份。零呢？负数呢？虚数吗？这些概念，在现实世界中并没有与之相对应的事物。它们是数学家们虚构出来的概念，是一个工具，是一个桥梁，用来解决现实的数学问题。一个现实问题，往往要解决一个不存在的事物，才能得到解决。化学反应中的催化剂、公司法人的概念，甚至于宗教崇拜，都是类似的问题。人类也许是唯一可以想象出现实世界中不存在的事物的物种吧。正是这种优势，才让人类在物种竞争中脱颖而出。\n8. 有穷与无穷：因为我们生活在有限的世界中，所以很难想象无穷。在无穷的世界中，有限世界中的很多法则都要改写。无穷是一种趋势，而绝不是一个很大很大的数。数不等于趋势，这个才是本质。罗素为了挑战牛顿、莱布尼茨等人，提出无穷小悖论，造成了数学史上的第二次危机。\n9. 数学分为很多分支，我们在每一分支的学习过程中，需要搞清楚：（1）每一个方向的基本假设（公理）、基本定义（2）该方向提供了什么工具，可以解决什么问题\n10. 微积分：通过学习微积分，我们需要能够把控宏观趋势的微观趋势的相互影响。需要了解积分造成的滞后效应。牛顿借助趋势，通过导数的方式来求最大值，这种思路也值得我们参考。\n11. 线性代数：向量、矩阵的本质，矩阵加法、矩阵乘法的本质。更多的是一种数学工具，让我们更方便的批量处理数据。\n12. 概率论：忽略局部不确定性，把握整体的确定性。概率论的学习，让我们在不确定的世界中有迹可循。分布：正态分布（标准正态分布）、柏松分布、幂次分布、二项分布。\n13. 博弈论：在现实世界中，我们要尽量少参与零和博弈，毕竟出来混迟早要去还的。而应该多参加非零和博弈，因为只有非零和博弈才有双赢的可能。然而，双输更有可能成为博弈的平衡点，其根源的化在于信息闭塞，博弈方有信任危机。\n\n## 《吴军数学通识50讲》大纲\n\n数学：学科基础\n\n思考方式：化繁为简，直击本质。\n\n把自己的对所有数学概念和方法的理解程度，从**静态的**、**具体的**，上升到**动态的**、**规律性**的。\n\n### 数学的线索：从猜想到定理到应用\n\n![数学的线索](http://cdn.b5mang.com/20212103344.png)\n（）数学与自然科学的三个本质差别：\n\n第一，测量 和 逻辑推理 的区别\n\n观察的经验能够给我们启发，但是不能给到我们结论。\n数学上的结论，一定是从定义和公理出发，经过逻辑推到而得到。\n\n第二，事实证明 与 逻辑证明 的区别\n\n自然科学中，一个假说通过实验证实就变成了定律（即使某些条件下确实不满足，实际上自然科学上几乎所有的定律和理论都有被推翻的可能性）\n数学理论必须靠证明，保证没有例外。\n\n第三，科学结论的相对性 与 数学结论的绝对性\n\n数学的每一个定理都是一块基石，然后在此基础上建立新的基石，从而一点点建起整个数学大厦。\n\n（）毕达哥拉斯 （从经验到系统性科学）\n数学从哪里开始：必须遵守严格的逻辑证明才能得到结论。\n逻辑体系的一致性与完备性；\n\n（）数学的预见性：如何用推理走出认知盲区\n\n数学史上第一次危机：无理数的出现\n\n如果现实与数学发生了矛盾，那么有几种可能：\n（1）数学推导本身有问题\n（2）我们的眼睛或者认知有问题，例如我们之前的认知中是没有无理数的\n（3）最初的假设错了，例如非欧几何\n\n基于第二点，让很多危机变为转机，认知拓展，产生新的理论，例如：无穷小概念的提出、无穷大的重新认识、公理化集合论的确立\n\n自然科学上，很多重大的发现，并非源于观察或者观测，而是基于数学推论，然后才被实验证实。\n\n（）数学思维：如何从逻辑出发想问题\n\n矛盾律：一个实物不可能既满足A属性，又不满足A属性；\n反证法：基于一个假设，推出矛盾；所以，假设是错误的。\n\n（）数学的边界\n\n毕达哥拉斯定理 <=== 费马大定理 ====> 希尔伯特第十问题\n到目前为止，我们所能解决的问题只是所有数学问题中很小一部分。\n解析解：答案是以公式的形式存在的；这样子套入任何数字，就可以得到具体的解。\n\n非线性方程怎么解：\n苏联：数学水平高，所以努力去求出其解析解\n美国：将非线性问题转换为计算量大，但很简单的线性问题，然后统计计算机来求解。\n\n（）毕达哥拉斯：黄金分割，连接数学和美学\n\n黄金分割源于：自相似，分形；\n等角螺线：蜗牛、龙卷风、星系 （黄金分割。。）\n\n（）数学的应用\n现实世界中很多问题，究其本质都是数学中的最优化问题\n华罗庚：优先法 黄金分割的应用\n真正的大师：能够用通俗易懂的话将复杂的问题讲明白\n\n（）数列和级数\n\n数列：是从生活中而来，例如利息与几何级数有关系；而斐波那契数列与物种繁衍、组织自然发展有关系。数列反映了现实世界中事物的发展过程。\n\n斐波那契 与 黄金分割有关系\n\n数列反映的是趋势，他不像数（这个数有多大，有多少钱，多少资源）而是关心未来能变的多大，变得多快。\n除了趋势，我们还关系累计的效果，也就是数列之和，也就是级数。\n\n级数的发散与收敛 具体应用：文章如何成为爆款？\nr 相邻两项的比例，r>1 发散； r<1， 则收敛\n\n### 数：方程、虚数\n\n![数的概念](http://cdn.b5mang.com/20212103427.png)\n\n思维工具：从具体到抽象\n\n抽象工具的发明，用于解决实际问题。\n\n对数的认识，从具体到抽象\n\n数学的本质，是工具！\n\n针对某个具体问题的精妙的解题技巧的作用，远远不如通用的“笨方法”\n\n应用题：把自然语言描述的现实问题变成用数学语言描述的数学问题，比如列出方程\n一元一次，一元二次方程，解析解，没毛病； 那么一元三次方程呢？（没有通解，唯有一些特殊方程，用一些巧妙的办法才能解出来）\n\n一些启发：\n从引理到定理，引理只能解决某个问题的特殊形式，并不能成为定理。\n实际学习，能够把现实问题转换为数学问题的能力是最重要的，而不用拘泥于如何去求解他们。我们应该借助工具。\n\n解三次方程：明明有公式，但是公式中遇到了一堵墙，我们**必须**引入一个不存在的东西才能把这堵墙翻过去。\n哲学意义：明明是现实问题，在现实世界也有答案，却无法直接得到，而非要发明一个不存在的东西作为桥梁。\n\n引入虚数之后：\n（1）逻辑可能的漏洞补上了，一元N次方程，一定有N个解\n（2）作为工具的作用，直角坐标转换为极坐标\n（3）应用层面：量子力学、相对论、控制系统等都离不开虚数\n\n人类是唯一可以构造出不存在的事物的物种！！宗教、法律、有限公司、法人团体、法人！想象共同体\n\n抽象思维：认知水平高低，在于能够接受虚拟的、不存在的事物！\n自然数 =》 0 =》 负数、分数 =》 无理数 =》 虚数 越来越抽象\n\n很多数学概念的基础在现实世界并不存在；但是建立在不存在基础上的工具，却能解决很多现实问题！\n复数：\n\nhttps://www.wolframalpha.com/input/?i=sqrt%2834%29\n\n无限！！\n\n无穷大，动态的，不断扩大的趋势，而不是一个静态的数！\n\n旅馆悖论\n\n在无穷大的世界的里，部分可以和整体等价！\n我们不能以有限的认知，去理解无限的事物；也不能将把那些从很少的经验中得到的结论，放大后用于更大的场景。\n\n动态变化发展的眼光，从趋势去看待世界，新的认识世界的方式\n把我世界变化是处于什么层次上？ 无穷小？\n\n经验 与 逻辑 的矛盾\n经验胜利：各种芝诺悖论\n    他永远追不上乌龟 无穷小累加是一个有限的数\n    飞箭静止  混淆了瞬间位移 与 瞬间速度\n    两匹马的距离 等与 一匹马做的距离  无穷小不是0\n逻辑胜利：日心说\n\n第二次数学危机：贝克莱PK牛顿 无穷小悖论：无穷小到底等不等不0？\n微积分的基础是导数；而导数的前提是无穷小；但是无穷小却没有精确定义？\n\n极限的精确定义\n芝诺 牛顿/莱布尼茨（无穷小） 贝克莱 柯西/威尔斯特斯拉（定量、逆向思维=》精确定义极限）\n\n数学逻辑的漏洞，其实是人们认知的漏洞！\n有逻辑的傻问题，是我们认知体系扩大的开始！\n\n无穷大/无穷小 虽然不是数，但是可以比大小；甚至可以参与+-*/等数学运算\n\n一些认知：\n有穷 VS 无穷\n静态 VS 动态 （趋势）\n现实 与 虚构\n直觉 和 逻辑（逻辑可以让我们分析清楚 我们看不到，甚至不存在的事物）\n概念 与 表述 （ 做事专业，需要掌握专业的术语，数学、法律）\n财富 和 荣誉 （科学无专利，带来的是荣誉；而技术有专利，带来的是财富）\n\n### 几何\n\n![20212103510](http://cdn.b5mang.com/20212103510.png)\n几何学： 埃及：初步感性认识 =》 量化的感性认识 =》 记录传播 =》 希腊：公理化知识体系\n\n如何建立一个完备的公理化知识体系\n\n欧氏几何：源自 五条一般性公理  与 五条几何公理\n定义一些基本概念！\n\n辅助线： 又一次借助虚拟的工具来解决问题\n\n如果某一条公理有错误呢？\n（1）如果你设定的公理 与 现有公理有矛盾，那么知识体系就无法建立\n（2）如果没有矛盾，那么就会构建出一个新的知识体系，他本身是自洽的；但是与其他体系相矛盾。\n\n欧氏几何，非欧几何（双曲面、椭球面）\n平面是什么？ 满足平行公理的面。\n黎曼几何：相对论的理论基础\n\n解析几何：将代数 与 几何 统一；他借助代数让一些几何问题变得容易求解；借助几何让一些代数问题变得容易求解。\n坐标系：笛卡尔坐标系；\n\n公理化体系：通过公理化系统构建一个知识体系，体现出人们创造思想的最高水平！\n\n法律：自然法，那些最基本的，不证自明的依据\n管理：企业文化价值观\n\n延拓：在想象的世界里，一次合乎逻辑的认知升级：减法延拓出负数、开根号延拓出虚数等\n\n### 代数：函数、向量、线性代数\n\n![数量绘制世界](http://cdn.b5mang.com/202121102826.png)\n数 =》 方程 =》 函数\n\n代数：两个工具（函数、方程）一个规律（数字有方向）\n\n函数：对应关系\n函数：人们的认知 从 个体上升到整体；从单点联系上升到规律性的网状联系。从单个数字、变量的关注引向了趋势。为同一类问题提供了普遍性的答案。\n\n因果关系：数学中可互换\n反函数：轴对称\n\n72定律：年回报率为R%，那么财富将在72/R年后翻翻。\n\n搞清楚：只有一个自变量的话，自变量与因变量存在因果必然性；而多变量的话，每一个变量与函数值仅是相关性。\n\n向量：有方向的数量；二维空间，三维空间，多维空间\n\n数量的方向性，给我们的提示：做事情要聚焦。\n\n向量夹角，余弦定理 与 文本相似度\n\n线性代数：工作生活中实际用得上。\n\nM*N矩阵的函数：M个N维向量放在一起\n\n矩阵加法\n\n工作生活的增量原则：有一个相对固定的大原则，以及针对各种情况的小变动。全量 + 增量\n\n矩阵乘法：\n单个计算 =》 大批量计算\n\n### 微积分\n\n![动态的世界观](http://cdn.b5mang.com/202121102856.png)\n与初等数学工具最大的不同：从关注静态关系，变成了 动态规律，特别是瞬间规律的把握。\n\n微积分更多的作用在于训练思维！！\n\n微分：从宏观趋势了解微观变化\n\n导数：对变化快满的准确量化度量\n\n多变量函数的微分：梯度\n\n大量不确定性时，往婆度最高的方向努力。\n\n从宏观趋势中把握微观变化的趋势，让我们认清每一步的方向。\n\n不可导的趋势靠不住：\n函数的光滑程度与可导之间的关系\n\n经济过热、经济硬着陆、经济稳定增长\n\n积分：从微观趋势了解宏观变化\n\n积分思想的本质：从动态变化来看累积效应；之前都是靠平均值。\n\n滞后效应\n\n1. 凡是通过积分获得数量，它的结果会滞后于瞬间变化，有时还要经过相当长的时间之后才能看到\n2. 这种由积分获得的数量，一旦大到被大家观察到之后，要逆转这个趋势是很难。\n\n飞轮效应\n加速度 =》 速度（有一定滞后） =》 距离（滞后两次）\n\n从努力，到能力，到成绩，再到赏识，是一级级积分的结果，有滞后效应的；\n\n用变化的眼光来看最大值和最小值\n\n最优化问题：机器学习、金融投资、商业博弈论等\n\n有限集合求最值的和心思想：两个元素直接或者间接比大小‘\n\n牛顿的牛B：把最优化问题堪称了解函数动态变化趋势的问题。寻找最大值转换为一个解方程问题：导函数等于0\n\n更加通用，并且与结合大小无关。\n\n牛顿的方法只能找到极大值，却无法找到最大值。\n\n如何找最大值的方法，至今无人解决。只能一个一个比较。\n\n莱布尼茨从哲学出发，其哲学思想和逻辑思想有两点：\n（1）我们所有的概念都是从非常小的、基本概念复合而成的，他们组成了人类思维的基本单位。\n（2）简单的概念符合成复杂概念的过程是计算。\n\n微积分是一个纯数学的工具。\n\n牛顿 PK 莱布尼茨：宗教信仰不同\n牛顿：自然神论者，上帝仅仅创造了世界。\n莱布尼茨：神学家，上帝维护者\n\n### 概率：（大数据思维的基础）\n\n![从确定到不确定](http://cdn.b5mang.com/202121102923.png)\n微积分这个工具以及牛顿，给了人们空前的自信，认为什么事情都是确定的；机械论世界观\n\n拉普拉斯给出的定义：\n随机事件：包含若干个等概率的基本事件\n概率：随机事件A包含的基本单位数量/总数量\n\n有漏洞！！\n等概率？ 循环定义。\n\n随机性是一种自然的属性；它客观存在，所以得到结果的不确定性；\n\n有关不确定的概率，只有在大量随机试验时才能显现出来，当试验次数不足时，他则显示出偶然性和随意性。\n\n伯努利实验\n\n期望，误差，标准差/平方差\n\n理想与现实：\n\n越是概率小的事件，由于标准差的存在，所以误差就会越大；\n例如1%的概率的事件，进行100次实验，标准差是1，期望是1，误差是大约是100%\n如果想确保1次成功，至少要做260次实验。\n\n提到单次成功率要比多做实验更重要，所以凡事多做准备，争取一次性成功。\n\n泊松分布：小概率事件，但是试验次数足够大\n\n公司停车问题\n\n投资失败，判定一件事情发生的可能性总是由很大的误差，一个重要的原因就是靠直觉与有严重漏洞的逻辑，而不是靠严格的数学逻辑和推导。\n\n应对随机性，需要的冗余比想象中的大。\n（通讯公司应对通话高峰期问题）\n\n池子越大，越能抵消随机性带来的误差。\n（保险：保费与投保人数） =》 大的保险公司！！\n如何尽可能的放大池子：保险公司互保\n\n正态分布\n一个标准差，置信度：65%\n二个标准差：置信度：95%\n三个标准差：置信度：99.73%\n\n标准差越小，越瘦高；\n\n如何缩小标准差：增加统计数量\n\n条件概率：贝叶斯公式\n\nP(X|Y) = P(Y|X) * P(X) / P(Y)\n为什么这么写呢？因为通常P(X), P(Y)比较容易求的；而P(X|Y), P(Y|X)有一个比较容易求的。\n\n机器翻译的原理（英文翻译成中文）\n假设有N种翻译方法，其实就是从这N种翻译方法中找到一种翻译X, 使得在已知英文句子Y的条件下，X的概率P(X|Y)的概率最大。\n\n给定一个中文语句，对应的英文句子的概率（马尔科夫计算模型）\nP(X)表示那个句子在语法中更合理\n\n概率公理化\n\n概率的精确定义：\n\n借助于极限的思想\n\n伯努利版本大数定理：\n如果一个事件的概率P存在，那么事件A的发生次数M / 总的试验次数N 伴随着N趋近于无穷大，M/N 无限趋近于 P\n（不严格：假设P存在）\n\n切比雪夫大数定理：\n大量试验后，随机变量的平均值，就等于它的概率\n\n前两者，偏向于自然语言，不够优雅，初等概率论\n\n现代概率论：柯尔莫哥洛夫，引入“测度”概念\n测度：概率函数，定义了概率，一个随机事件对应的数值。\n\n统计学和大数据\n\n用好数据的5个步骤\n\n1. 设定研究目标\n2. 设计实验\n3. 根据试验进行统计和实验，分析方差和均值\n4. 通过分析进一步了解数据，提出新假说（如果证明无效，提出新假说）\n5. 使用研究结果\n\n黑天鹅产生的原因：把小概率事件当作零概率事件\n\n奇普夫定律：自然界的普遍定律：排名 * 频次 = 常量\n\n财富排名 * 财富 = 常量\n\n古德-图灵折扣估计\n\n### 博弈论\n\n零和博弈：最多是平衡而已\n\n博弈的最好策略：在对方给我们造成的最糟糕的局面里，选择相对最好的。\n计算机算法：最小值中的最大值策略\n\n静态博弈：\n动态博弈：下围棋，交替出招\n\n马鞍点：平衡点\n\n非零和博弈\n\n囚徒困境\n双赢点是大家主观上都想达成的目标，但在现实中客观的结局常常是纳什均衡点，也就是双输的结果。\n\n现实中，双赢很难的5个原因：\n（1）博弈是长期反复的，长期坚持信任几乎不可能\n（2）博弈论讲的是阳谋的策略，但很多时候博弈双方使用的确是阴谋。\n（3）人类处于文明初级阶段，道德水准不聋高估。（见不别人比自己好）\n（4）乌合之众效应（两人或者两个独裁国家博弈更容易双赢，但是两个民主国家则更难）\n（5）看似双赢，但其实是更大范围内的零和博弈（公司给员工的期权）\n\n合作，永远不要玩难以达成双赢的游戏；初次相信原则\n\n智猪博弈：大小企业竞争，搭便车似的跟随策略\n\n制定最好的策略，是要考虑到对方采取每一种策略的概率，而不是简单考虑对方一定会采用对自己最不厉的策略。\n\n### 数学和其他知识体系\n\n![数学的基础作用](http://cdn.b5mang.com/202121102953.png)\n哲学与数学，一头一尾\n\n数学如何影响哲学\n\n笛卡尔\n人类如何知识：经验 + 理性推理（逻辑） + 去伪存真\n\n实证  人的理性\n\n莱布尼茨\n\n相对的因果时空观\n对离散的世界理解（二进制、不可分割性=》离散数学、量子力学）\n\n使用建立公理化体系的方法，建立自己的哲学体系。\n\n数学和逻辑学：逻辑是一切的基础\n\n逻辑是人类理性的体现，基本原理：\n（1）同一律\n明确概念、偷换概念，以偏概全\n（2）矛盾律：不可能是A，又不是A\n同一时间，同一属性，同一方面，对象\n（3）排中律：是非明确\n二分相关算法的逻辑基础\n（4）充分条件律：有果必有因\n任何结论都要有充分的理由。\n\n工具\n\n运筹学：利用图论、线性代数等数学工具，从整体上改变现有系统的效率。 数学是工具\n\n管理学：企业的三公理\n愿景和使命（企业为什么而存在）\n价值观（企业中的人与外界各种人的关系）；数学，公理思维方法论\n\n历史：历史研究中，不强调所有的正确性或者正统观点，而强调逻辑的自洽。任何从客观出发，逻辑上都自洽的结论都是有意义的。\n\n体系公理不一样，还原出的历史就不一样。没有对错，却有好坏，有合理和荒诞。评判标准在于：其假设前提，也就是公理的客观性，以及论证的逻辑性。\n\n伽罗瓦 古典难题给我们的提示：\n\n伽罗瓦的群论，近世代数\n\n（1）绝大多数知识体系都不可能做到绝对的完备性和一致性的统一。\n某一个区域内，一定会出现仅靠区域内的知识无法解决的问题。解决这些问题需要更大领域的知识。\n\n（2）每一种工具都可以解决很多问题，将很多看似并不相关的难题的共性找出来。如果这些工具，某些难题看似能解决，但仅仅是靠技巧。\n\n（3）跳出圈外，在某一个时代，某些问题之所以很难，是因为他们看似当时知识体系的问题，但其实是表象。二等分角 VS 三等分角（欧几里得几何范围内无法解决）\n\n庞加莱猜想 拓扑学的基石 done\n\nNP问题：不存在还是没找到？\n\n霍奇猜想\n\n黎曼猜想（希尔伯特问题）\n\n杨-米尔斯存在性与质量间隙\n\n罗素悖论：第三次数学危机 理发师悖论\n能否有一个集合，他有那些不包含自身的集合构成？\n\n数学思维：\n一切从公理出发，逻辑得到结论\n在解决问题之前，先搞清问题，特别是搞清楚问题的定义\n各种知识体系是相通的\n用动态、发展的眼光看待世界。\n\n思维方式\n\n哲学对数学的影响\n\n哲学试图去构建一个位于科学和其他知识之上的大一统体系，形成一个没有矛盾的知识体系。\n\n数学：希尔伯特，大一统的数学体系（不可能）\n物理学：爱因斯坦，大一统的物理体系（至今未实现）\n\n一个人只有在深刻人类知识的普遍性原理之后，才能站在一个制高点往下俯视。\n\n![一头一尾](http://cdn.b5mang.com/2021131171935.png)\n\n从个案到整体规律\n从个别定理到知识体系\n从具体到抽象\n从静态到动态\n从完全的确定性到把握不确定性\n\n------\n\n数据\n\n数据的提供者：用户\n数据的管理者：JD,gogole等公司\n数据的使用者：谁从数据中受益\n\n金钱的不可复制性，稀缺\n数据呢？如果数据可以随意复制，那么他将一文不值。\n\n如何数据的不可复制性\n\n区块链：某些数据本身是很稀缺的。\n\n数据资产化，数据资本化\n"},{"title":"链表系列-O(1)删除节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/delete_node.html","content":"\n给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。\n\n假设链表一定存在，并且该节点一定不是尾节点。\n\n样例\n输入：链表 1->4->6->8\n      删掉节点：第2个节点即6（头节点为第0个节点）\n\n输出：新链表 1->4->8\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n```\n","tags":["链表"],"categories":["数据结构与算法","剑指Offer"]},{"title":"链表系列-奇偶重排","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/odd_even.html","content":"\n```cpp\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        auto evenHead = new ListNode(-1);\n        auto oddHead = new ListNode(-1);\n\n        auto evenTail = evenHead, oddTail = oddHead;\n\n        int k = 1;\n        while (head) {\n            if (k & 0x1) { //奇\n                evenTail->next = head;\n                evenTail = head;\n            } else {\n                oddTail->next = head;\n                oddTail = head;\n            }\n            k++;\n            head = head->next;\n        }\n        \n        oddTail->next = NULL; //最后的尾巴需要设置为空\n        evenTail->next = oddHead->next;\n        return evenHead->next;\n    }\n};\n```","tags":["链表"],"categories":["数据结构与算法"]},{"title":"链表系列-排序链表删除重复节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/slow_fast_pointer/deleteDuplication.html","content":"\n在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。\n\n样例1\n输入：1->2->3->3->4->4->5\n\n输出：1->2->5\n样例2\n输入：1->1->1->2->3\n\n输出：2->3\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplication(ListNode* head) {\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n        auto p = dummy;\n        while (p->next) {\n            auto q = p->next;\n            while (q->next && q->next->val == q->val) q = q->next;\n            if (p->next == q) p = q;\n            else {\n                p->next = q->next; \n            }\n        }\n        \n        return dummy->next;\n    }\n};\n```\n\n扩展问题：\n\n移除重复节点，无排序版本\n\n编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。\n\n解答思路：\n\n1. 借助hash来记录val之前是否出现过\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeDuplicateNodes(ListNode* head) {\n        //hash + 链表\n        unordered_map<int, bool> map;\n\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n\n        auto p = head, pre = dummy;\n        while (p) {\n            if (map[p->val]) { //出现过\n                pre->next = p->next;\n            }\n            else {\n                pre = p;\n            }\n            map[p->val] = true;\n            p = p->next;\n        }\n\n        return dummy->next;\n    }\n};\n```\n","tags":["快慢指针"],"categories":["数据结构与算法"]},{"title":"常见系统设计题系列-分布式日志系统","url":"/backend_knowledge_architecture/system_design/distributed_log.html","content":"\nELK方案\n\n- elastic search\n\n对日志进行分词，并建立倒排索引\n\n- log stash\n\n日志采集\n\n- Kibana\n","categories":["系统设计"]},{"title":"常见系统设计题系列- DNS系统","url":"/backend_knowledge_architecture/system_design/dns.html","content":"\n设计DNS服务器中cache的数据结构。\n\n要求设计一个DNS的Cache结构，要求能够满足每秒5000以上的查询，满足IP数据的快速插入，查询的速度要快。（题目还给出了一系列的数据，比如：站点数总共为5000万，IP地址有1000万，等等）\n\n回答：\n\nDNS服务器实现域名到IP地址的转换。\n\n每个域名的平均长度为25个字节（估计值），每个IP为4个字节，所以Cache的每个条目需要大概30个字节。\n\n总共50M个条目，所以需要1.5G个字节的空间。可以放置在内存中。（考虑到每秒5000次操作的限制，也只能放在内存中。）\n\n可以考虑的数据结构包括hash_map，字典树，红黑树等等。\n\n核心思想：估算、哈希\n","categories":["系统设计"]},{"title":"常见系统设计题系列-在线人数统计","url":"/backend_knowledge_architecture/system_design/online_stat.html","content":"\n问题：\n求一个论坛的在线人数，假设有一个论坛，其注册ID有两亿个，每个ID从登陆到退出会向一个日志文件中记下登陆时间和退出时间，要求写一个算法统计一天中论坛的用户在线分布，取样粒度为秒。\n回答：\n\n<!-- more -->\n\n方法1:\n将所有的事件（包括每个ID的登陆，退出） 按照时间排序；\n如果登陆则+1， 登出则-1\n\n方法2:\n如果无序怎么办？需要先把所有的事件从磁盘读出来，然后把结果记录下来。\n\n一天总共有3600*24=86400秒。\n\n定义一个长度为86400的整数数组intdelta[86400]，每个整数对应这一秒的人数变化值，可能为正也可能为负。开始时将数组元素都初始化为0。\n\n然后依次读入每个用户的登录时间和退出时间，将与登录时间对应的整数值加1，将与退出时间对应的整数值减1。\n\n这样处理一遍后数组中存储了每秒中的人数变化情况。\n\n定义另外一个长度为86400的整数数组intonline_num[86400]，每个整数对应这一秒的论坛在线人数。\n\n假设一天开始时论坛在线人数为0，则第1秒的人数online_num[0]=delta[0]。第n+1秒的人数online_num[n]=online_num[n-1]+delta[n]。\n\n这样我们就获得了一天中任意时间的在线人数。\n","tags":["位图"],"categories":["系统设计"]},{"title":"常见系统设计题系列-URL去重","url":"/backend_knowledge_architecture/system_design/url_uniq.html","content":"\n可能需要想到的思路：哈希、bloomfilter\n","tags":["哈希"],"categories":["系统设计"]},{"title":"常见系统设计题系列-积分排名系统","url":"/backend_knowledge_architecture/system_design/val_rank.html","content":"\n问题：\n某海量用户网站，用户拥有积分，积分可能会在使用过程中随时更新。现在要为该网站设计一种算法，在每次用户登录时显示其当前积分排名。用户最大规模为2亿；积分为非负整数，且小于100万。\n\n回答：\n\n存储结构\n首先，我们用一张用户积分表user_score来保存用户的积分信息。表结构：\n\n![用户排名](http://cdn.b5mang.com/2021119234048.png)\n\n下面的算法会基于这个基本的表结构来进行。\n\n<!-- more -->\n\n### 算法1：简单SQL查询\n\n首先，我们很容易想到用一条简单的SQL语句查询出积分大于该用户积分的用户数量：\n\n```sql\nselect 1 + count(t2.uid) as rank\nfrom user_score t1, user_score t2\nwhere t1.uid = @uid and t2.score > t1.score\n```\n\n算法特点\n优点：简单，利用了SQL的功能，不需要复杂的查询逻辑，也不引入额外的存储结构，对小规模或性能要求不高的应用不失为一种良好的解决方案。\n缺点：需要对user_score表进行全表扫描，还需要考虑到查询的同时若有积分更新会对表造成锁定，在海量数据规模和高并发的应用中，性能是无法接受的。\n\n### 算法2：均匀分区设计\n\n在许多应用中缓存是解决性能问题的重要途径，我们自然会想能不能把用户排名用Memcached缓存下来呢？不过再一想发现缓存似乎帮不上什么忙，因为用户排名是一个全局性的统计性指标，而并非用户的私有属性，其他用户的积分变化可能会马上影响到本用户的排名。然而，真实的应用中积分的变化其实也是有一定规律的，通常一个用户的积分不会突然暴增暴减，一般用户总是要在低分区混迹很长一段时间才会慢慢升入高分区，也就是说用户积分的分布总体说来是有区段的，我们进一步注意到高分区用户积分的细微变化其实对低分段用户的排名影响不大。于是，我们可以想到按积分区段进行统计的方法，引入一张分区积分表score_range：\n表结构：\n\n![范围数量]](http://cdn.b5mang.com/2021119234159.png)\n\n表示[from_score, to_score)区间有count个用户。若我们按每1000分划分一个区间则有[0, 1000), [1000, 2000), …, [999000, 1000000)这1000个区间，以后对用户积分的更新要相应地更新score_range表的区间值。在分区积分表的辅助下查询积分为s的用户的排名，可以首先确定其所属区间，把高于s的积分区间的count值累加，然后再查询出该用户在本区间内的排名，二者相加即可获得用户的排名。\n乍一看，这个方法貌似通过区间聚合减少了查询计算量，实则不然。最大的问题在于如何查询用户在本区间内的排名呢？如果是在算法1中的SQL中加上积分条件：\n\n```sql\nselect 1 + count(t2.uid) as rank\nfrom user_score t1, user_score t2\nwhere t1.uid = @uid and t2.score > t1.score and t2.score < @to_score\n```\n\n在理想情况下，由于把t2.score的范围限制在了1000以内，如果对score字段建立索引，我们期望本条SQL语句将通过索引大大减少扫描的user_score表的行数。不过真实情况并非如此，t2.score的范围在1000以内并不意味着该区间内的用户数也是1000，因为这里有积分相同的情况存在！二八定律告诉我们，前20%的低分区往往集中了80%的用户，这就是说对于大量低分区用户进行区间内排名查询的性能远不及对少数的高分区用户，所以在一般情况下这种分区方法不会带来实质性的性能提升。\n\n算法特点\n优点：注意到了积分区间的存在，并通过预先聚合消除查询的全表扫描。\n缺点：积分非均匀分布的特点使得性能提升并不理想。\n\n### 算法3：树形分区设计\n\n均匀分区查询算法的失败是由于积分分布的非均匀性，那么我们自然就会想，能不能按二八定律，把score_range表设计为非均匀区间呢？比如，把低分区划密集一点，10分一个区间，然后逐渐变成100分，1000分，10000分 … 当然，这不失为一种方法，不过这种分法有一定的随意性，不容易把握好，而且整个系统的积分分布会随着使用而逐渐发生变化，最初的较好的分区方法可能会变得不适应未来的情况了。我们希望找到一种分区方法，既可以适应积分非均匀性，又可以适应系统积分分布的变化，这就是树形分区。\n我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量(Invariant)：非叶子结点的count值总是等于其左右子结点的count值之和。\n\n![树形分区](http://cdn.b5mang.com/2021119234321.png)\n\n以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！\n\n虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为200,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。\n算法特点\n\n优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。\n\n缺点：算法相对更复杂。\n\n### 算法4：积分排名数组\n\n算法3虽然性能较高，达到了积分变化的O(log(n))的复杂度，但是实现上比较复杂。另外，O(log(n))的复杂度只在n特别大的时候才显出它的优势，而实际应用中积分的变化情况往往不会太大，这时和O(n)的算法相比往往没有明显的优势，甚至可能更慢。\n\n考虑到这一情况，仔细观察一下积分变化对排名的具体影响，可以发现某用户的积分从s变为s+n，积分小于s或者大于等于s+n的其他用户排名实际上并不会受到影响，只有积分在$[s,s+n)$区间内的用户排名会下降1位。我们可以用于一个大小为100,000,000的数组表示积分和排名的对应关系，其中rank[s]表示积分s所对应的排名。初始化时，rank数组可以由user_score表在O(n)的复杂度内计算而来。用户排名的查询和更新基于这个数组来进行。查询积分s所对应的排名直接返回rank[s]即可，复杂度为O(1)；当用户积分从s变为s+n，只需要把rank[s]到rank[s+n-1]这n个元素的值增加1即可，复杂度为O(n)。\n\n算法特点\n\n优点：积分排名数组比区间树更简单，易于实现；排名查询复杂度为O(1)；排名更新复杂度O(n)，在积分变化不大的情况下非常高效。\n\n缺点：当n比较大时，需要更新大量元素，效率不如算法3。\n\n总结\n上面介绍了用户积分排名的几种算法，算法1简单易于理解和实现，适用于小规模和低并发应用；算法3引入了更复杂的树形分区结构，但是O(log(n))的复杂度性能优越，可以应用于海量规模和高并发；算法4采用简单的排名数组，易于实现，在积分变化不大的情况下性能不亚于算法3。本问题是一个开放性的问题，相信一定还有其他优秀的算法和解决方案，欢迎探讨\n","categories":["系统设计"]},{"title":"常见系统设计题系列-滑动TopK","url":"/backend_knowledge_architecture/system_design/topk_1h.html","content":"\n实时输出最近一个小时内访问频率最高的10个IP，要求：\n（1）实时输出\n（2）从当前时间向前数的1个小时\n（3）QPS可能会达到10W/s\n\n<!-- more -->\n\n解决思路：\n\n- 如何计算某一个IP最近一小时的访问次数？\n- 如何实现类似滑动窗口的功能，将过去1s的访问次数给去掉\n\n解决方案：\n\n- 滑动窗口：只是滑动窗口的元素是：HashMap<IP,Cnt>\n- 最近一小时某个IP的访问次数：累计所有窗口中IP对应的Cnt即可\n- 如何淘汰1个小时之前的数据：1s的定时器，定期移除过期的HashMap\n-如何维护Top10：自然是小顶堆（如果新来的IP超过堆顶元素，则上位；否则NOOP)\n","tags":["堆","哈希"],"categories":["系统设计"]},{"title":"常见系统设计题系列-Feed系统","url":"/backend_knowledge_architecture/system_design/feed.html","content":"\n\nFeed系统的本质就是一个相对更加简单的IM系统。\n\n### 推模式\n\n- 写入延迟问题：并行写入，对存储到写入压力大，更牛B的写入存储引擎：LevelDB、TokuDb等\n- 存储量特别大：压缩率更高的存储引擎 + 定期清理数据\n- 微博分组，更是扩大了写入量\n- 取消关注、删除微博等操作对该模式影响也很大（可以通过读时过滤来解决）\n\n问题重重，feed推模式，更适合粉丝有限的场景，例如朋友圈\n\n### 拉模式\n\n用户发件箱，来缓存UP最近5天发布的微博\n\n缓存节点的带宽成本比较高，可以通过多缓存副本来解决。\n\n#### 推拉结合\n\n1. 按照用户是否活跃在线与不在线\n2. 按照UP的粉丝数来划分\n3. 区分关注的普通人与大V\n","categories":["系统设计"]},{"title":"常见系统设计题系列-垃圾短信","url":"/backend_knowledge_architecture/system_design/garbage.html","content":"\n\n- 基于名单库\n\nhash、布隆过滤器等\n\n- 基于规则\n\n人为找出规则-包含哪些词的是垃圾｜需要有样本数据，然后进行机器学习-基于出现频次\n\n- 基于概率统计（朴素贝叶斯）\n\n如果一条短信包含了A，B，C等N个词，那么这条短信是垃圾短信的概率是多少呢\n","categories":["系统设计"]},{"title":"常见系统设计题系列-热门搜索TopK","url":"/backend_knowledge_architecture/system_design/hot_top_k.html","content":"\n问题：\n\n从300万字符串中找到最热门的10条搜索的输入信息是一个字符串，统计300万输入信息中的最热门的前10条，我们每次输入的一个字符串为不超过255byte，内存使用只有1G。请描述思想，写出算法（c语言），空间和时间复杂度。\n\n答案：\n\n300万个字符串最多（假设没有重复，都是最大长度）占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理。\n\n可以使用key为字符串（事实上是字符串的hash值），值为字符串出现次数的hash来统计每个字符串出现的次数。\n\n并用一个长度为K的堆来的数组/链表存储目前出现次数最多的10个字符串。\n","categories":["系统设计"]},{"title":"常见系统设计题系列-即时通信系统","url":"/backend_knowledge_architecture/system_design/im.html","content":"\n设计要点：\n\n长链接接入网关\n\n- 接入层：如何做负载均衡（基于IP 还是 基于7层的用户唯一标识）\n- 就近接入\n- 接入层如何升级：尽量减少升级，拆分为负责连接的进程与负责处理业务的进程，两者之间通过共享内存通信\n\n<!-- more -->\n\n心跳设计\n\n- 作用：保活\n- 原则：省电 PK 服务器压力\n\n通信协议：采用TCP/HTTP相结合的方式\n\n- TCP用于低延迟通知类\n- HTTP主要用于拉消息等对延迟不敏感的场景\n\n协议设计\n\n- 数据安全性\n- 编码复杂度\n- 协议通用型\n- 数据大小\n\n重连策略（客户端与服务端配合）\n\n当一台网关出现问题需要客户端进行重连时，还需要考虑到：不要因为重连问题导致了其他网关服务器也受影响，产生雪崩效应，此时需要考虑以下几点：\n\n- 打散重连时间：需要进行重连的客户端，在一个时间范围内选择一个随机的时间，这样将这些客户端的重连时间打散，不至于一下子都连接上来。\n- 指数退避：一次重连不上时，客户端还需要再次尝试进行多次重连，然而重连的时间需要像TCP协议那样在阻塞恢复时做指数退避，即第一次重连时间是1秒后，第二次2秒后，第三次4秒后，等等。这个策略也是为了避免由于重连导致的服务雪崩。\n- 服务器保护：上面两条是客户端的重连策略，然而服务器自身也需要进行保护，当服务器判断自己当前的负载到一定程度时，将拒绝客户端的连接请求。\n\n如何保证消息可达(不丢)/唯一(不重复)/保序(不乱序)\n\n- 不乱序：每条消息都有一条唯一且自增的msg_id\n- 不重复：\n\n消息防丢失\n\n- 逐条ACK\n- 引入seqno机制：为每一个用户维护一个自增的序列号\n\n存储设计\n\n- 消息存储库：存储每一个回话下的每一条消息，用于读扩散或者消息漫游；存储周期：长\n- 消息同步库：为每一个用户存储一个使用TIMELINE模型的收件箱，用于读取最新消息（一般是写扩散写入）；存储周期：短\n- 万人大群是例外，如果一定要支持的话，可以采用读写扩散混合模式。\n\n后端知识体系不完善，团队成员能力参差不齐\n服务或者模块划分混乱，编写的代码不符合DDD风格\n营销活动迭代效率急需提升，需要搭建高吞吐量的用户触达平台\n架构经验丰富，主导过多种大型系统的设计与开发；以及老系统的平滑重构\n\n","categories":["系统设计"]},{"title":"常见系统设计题系列- 带TTL的KV存储","url":"/backend_knowledge_architecture/system_design/kv_ttl.html","content":"\n设计一个带有有效时间TTL的KV存储系统，包含set（key，value，ttl）、get（key）方法、怎么优化\n\n首先是KV存储，可以使用levelDB作为我们的存储引擎；\n\n另外，需要考虑数据的复制与分片、去中心化等\n\n把TTL当作value，当进行compaction时，过期的数据会被忽略。\n","categories":["系统设计"]},{"title":"常见系统设计题系列-推送系统","url":"/backend_knowledge_architecture/system_design/push.html","content":"\n设计要点：\n\n1. 业务接入：频率限制、quota管理\n2. 接入队列：分队列，按照优先级、重要性等进行隔离\n3. 客户端接入：维护与客户端的长链接\n4. 用户状态的识别与路由：是否在线、是否获取、第三方接入等\n5. 调用第三方时的频率控制\n6. 接入安全：数据的加密\n7. 心跳保活\n8. 推模式，拉模式，推拉结合\n","categories":["系统设计"]},{"title":"常见系统设计题系列-秒杀系统","url":"/backend_knowledge_architecture/system_design/second_kill.html","content":"\n如何才能更好地理解秒杀系统呢？\n\n一个秒杀系统的架构，包括CDN，反向代理，session共享，由于分布式数据库我不熟，所以数据一致性那部分没有解决。\n\n![10wQPS量级架构](http://cdn.b5mang.com/2021319231635.png)\n\n主要技术点：\n\n（1）缓存\n\n（2）独立秒杀系统、独立集群\n\n（3）验证系统，防秒杀器\n\n![100wQPS量级架构](http://cdn.b5mang.com/2021319231913.png)\n\n主要技术点：\n\n（1）动静分离\n\n（2）本地缓存\n\n（3）热点隔离\n\n权衡点：要想获得极致性能，必然会牺牲通用型、易用性等\n\n#### 动静分离\n\n“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据\n\n第一，你应该把静态数据缓存到离用户最近的地方。\n\n第二，静态化改造就是要直接缓存 HTTP 连接。\n\n第三，让谁来缓存静态数据也很重要。（一般是web服务器来做，而不是应用服务器）\n\nURL 唯一化；分离浏览者相关的因素；分离时间因素；异步化地域因素；去掉 Cookie\n\n动态内容的处理通常有两种方案：ESI（Edge Side Includes）、CSI（Client Side Include）\n\n![实体机单机部署方案](http://cdn.b5mang.com/2021319233932.png)\n\nCache 分成若干组，是希望能达到命中率和访问热点的平衡。Hash 分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。\n\n不容易运维；浪费CPU\n\n![统一Cache 层](http://cdn.b5mang.com/2021319234014.png)\n\n网卡瓶颈、丢失数据\n\n![CDN部署](http://cdn.b5mang.com/2021319234237.png)\n\nCDN：失效问题、命中率问题、发布更新问题\n\n二级cache是指cdn设置了多级回源机制，就是如果缓存没有命中再到二级缓存中去取，而不是直接回服务端来请求。本质是减少回源的请求量\n\n#### 二八原则：有针对性地处理好系统的“热点数据”\n\n热点：热点操作（读操作、写操作）、热点数据（静态热点数据、动态热点数据）\n\n热点发现：对于静态热点（人工标识、大数据统计计算），以及实时热点发现方案\n\n![动态热点发现系统](http://cdn.b5mang.com/2021319235220.png)\n\n热点处理：\n\n（1）优化：缓存、LRU\n\n（2）限制：hash分桶，避免相互影响\n\n（3）隔离：从上到下三个层次，业务隔离、系统隔离、数据隔离\n\n#### 流量削峰\n\n常见做法：\n\n（1）排队-对发出来的请求进行缓冲（消息队列、文件缓存、内存队列、线程池加锁等）\n\n（2）答题-少发请求（两个功效：防止秒杀器；延缓请求，将请求峰值按照时间分片-从1s延长到2~10s）\n\n（3）分层过滤-不符合条件的请求进行过滤（交易性的写请求）\n\n![分层过滤](http://cdn.b5mang.com/20213200139.png)\n\n分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。\n\n#### 极致优化\n\n首先是“发现短板”，比如考虑以下因素的一些限制：光速（光速：C = 30 万千米 / 秒；光纤：V = C/1.5=20 万千米 / 秒，即数据传输是有物理距离的限制的）、网速（2017 年 11 月知名测速网站 Ookla 发布报告，全国平均上网带宽达到 61.24 Mbps，千兆带宽下 10KB 数据的极限 QPS 为 1.25 万 QPS=1000Mbps/8/10KB）、网络结构（交换机 / 网卡的限制）、TCP/IP、虚拟机（内存 /CPU/IO 等资源的限制）和应用本身的一些瓶颈等。\n\n其次是减少数据。事实上，有两个地方特别影响性能，一是服务端在处理数据时不可避免地存在字符到字节的相互转化，二是 HTTP 请求时要做 Gzip 压缩，还有网络传输的耗时，这些都和数据大小密切相关。\n\n再次，就是数据分级，也就是要保证首屏为先、重要信息为先，次要信息则异步加载，以这种方式提升用户获取数据的体验。\n\n最后就是要减少中间环节，减少字符到字节的转换，增加预处理（提前做字符到字节的转换）去掉不需要的操作。\n\n此外，要做好优化，你还需要做好应用基线，比如性能基线（何时性能突然下降）、成本基线（去年双 11 用了多少台机器）、链路基线（我们的系统发生了哪些变化），你可以通过这些基线持续关注系统的性能，做到在代码上提升编码质量，在业务上改掉不合理的调用，在架构和调用链路上不断的改进。\n\n#### 防超卖\n\n减库存的三种时机：\n\n（1）下单后\n\n优点：体验好，不超买\n\n不足：恶意下单\n\n（2）支付后\n\n优点：不会被人恶意刷单\n\n不足：存在付款后超卖的情况\n\n（3）预扣库存（为用户保留一段时间）\n\n优点：一定程度上缓解上面的问题\n\n不足：没有根治，需要结合风控策略来综合考虑\n\n解决大并发读问题，可以采用 LocalCache（即在秒杀系统的单机上缓存商品相关的数据）和对数据进行分层过滤的方式。\n\n像减库存这种大并发写无论如何还是避免不了，这也是秒杀场景下最为核心的一个技术难题\n\n一般的电商系统，通常采用第三种减库存的方式；\n\n而对于秒杀系统，我们更多的采用第一种方式。原因在于：\n\n（1）秒杀系统的商品对库存都有比较严格的管控\n\n（2）下单后不支付的概率比较小\n\n秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢？\n\n应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。\n\n数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。\n\n在活动开始之前一段时间，把商品库存放在Redis中。\n\n手段：通过Redis来抗，Lua脚本来完成CAS操作\n\nhttps://www.yuque.com/chenboxue/kb/gmy24m\n\n#### 高可用建设\n\n![高可用建设](http://cdn.b5mang.com/202132003655.png)\n\n运行时：\n体验降级：牺牲了一部分次要的功能和用户的体验效果\n限流\n拒绝服务，避免打死长时间无法恢复\n熔断\n\n网站的高可用建设是基础，可以说要深入到各个环节，更要长期规划并进行体系化建设，要在预防（建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测）、管控（做好线上运行时的降级、限流和兜底保护）、监控（建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警）和恢复体系（遇到故障要及时止损，并提供快速的数据订正工具等）等这些地方加强建设，每一个环节可能都有很多事情要做。\n\n## 设计难点\n\n解决秒杀这种特定业务场景，可以使用 CDN 的边缘结点来扛流量，然后过滤用户请求（限流用户请求），来保护数据中心的系统，这样才让整个秒杀得以顺利进行。\n\n<!-- more -->\n\n### 高并发问题\n\n限流：前端限流、后端限流\n\n异步化：要确保进入队列的购买请求一定能处理成功！\n\n### 防恶意请求\n\n目的：防止被黑产盯上之后通过脚本来请求服务端\n\n解决方案：动态获取秒杀地址\n","categories":["系统设计"]},{"title":"常见系统设计题系列-短网址系统","url":"/backend_knowledge_architecture/system_design/tiny_url.html","content":"\n有些时候，确认需求比思考方案更加重要、更加困难。\n\n在设计一个短网址系统时，我们需要考虑：\n\n* 重定向方式：301 还是 302\n\n302(临时重定向)更合适。永久重定向的话，浏览器会缓存重定向结果，造成某些依赖重定向的统计结果不准。\n\n<!-- more -->\n\n* 一个长URL对应一个短链接还是多个？\n\n对应多个，对应多个更加有利于数据统计。\n\n* 如何生成短链接？\n\n生成步骤，如下：\n\n1. 查重（如果需要）；\n2. 生成64位的自增ID；\n3. 保存url=>ID映射；\n4. 生成64位整数对应的62进制字符串\n\n* 如何获取短链接对应的长链接URL?\n\n查找步骤，如下：\n\n1. 将62进制数转换为对应的64位整数；\n2. 查找存储（KV更佳），获取对应的长URL\n\n* 额外要点\n  \n第一，限制主体的调用频率，防止ID耗尽；\n\n第二，短链接URL的过期清理；\n\nDesigning a URL shortener\n\nDesign a system to take user-provided URLs and transform them to a shortened URLs that redirect back to the original. Describe how the system works. How would you allocate the shorthand URLs? How would you store the shorthand to original URL mapping? How would you implement the redirect servers? How would you store the click stats?\n\nAssumptions: I generally don’t include these assumptions in the initial problem presentation. Good candidates will ask about scale when coming up with a design.\n\nTotal number of unique domains registering redirect URLs is on the order of 10s of thousands\nNew URL registrations are on the order of 10,000,000/day (100/sec)\n\nRedirect requests are on the order of 10B/day (100,000/sec)\n\nRemind candidates that those are average numbers - during peak traffic (either driven by time, such as ‘as people come home from work’ or by outside events, such as ‘during the Superbowl’) they may be much higher.\n\nRecent stats (within the current day) should be aggregated and available with a 5 minute lag time\n\nLong look-back stats can be computed daily\n\nAssumptions #\n\n1B new URLs per day, 100B entries in total the shorter, the better show statics (real-time and daily/monthly/yearly)\n\nEncode Url #\nhttp://blog.codinghorror.com/url-shortening-hashes-in-practice/\n\nChoice 1. md5(128 bit, 16 hex numbers, collision, birthday paradox, 2^(n/2) = 2^64) truncate? (64bit, 8 hex number, collision 2^32), Base64.\n\nPros: hashing is simple and horizontally scalable.\n\nCons: too long, how to purify expired URLs?\n\nChoice 2. Distributed Seq Id Generator. (Base62: a~z, A~Z, 0~9, 62 chars, 62^7), sharding: each node maintains a section of ids.\n\nPros: easy to outdate expired entries, shorter\n\nCons: coordination (zookeeper)\n\nKV store #\nMySQL(10k qps, slow, no relation), KV (100k qps, Redis, Memcached)\nA great candidate will ask about the lifespan of the aliases and design a system that purges aliases past their expiration.\n\nFollowup #\nQ: How will shortened URLs be generated?\n\nA poor candidate will propose a solution that uses a single id generator (single point of failure) or a solution that requires coordination among id generator servers on every request. For example, a single database server using an auto-increment primary key.\n\nAn acceptable candidate will propose a solution using an md5 of the URL, or some form of UUID generator that can be done independently on any node. While this allows distributed generation of non- colliding IDs, it yields large “shortened” URLs\n\nA good candidate will design a solution that utilizes a cluster of id generators that reserve chunks of the id space from a central coordinator (e.g. ZooKeeper) and independently allocate IDs from their chunk, refreshing as necessary.\n\nQ: How to store the mappings?\n\nA poor candidate will suggest a monolithic database. There are no relational aspects to this store. It is a pure key-value store.\n\nA good candidate will propose using any light-weight, distributed store. MongoDB/HBase/Voldemort/etc.\n\nA great candidate will ask about the lifespan of the aliases and design a system that purges aliases past their expiration\n\nQ: How to implement the redirect servers?\n\nA poor candidate will start designing something from scratch to solve an already solved problem\n\nA good candidate will propose using an off-the-shelf HTTP server with a plug-in that parses the shortened URL key, looks the alias up in the DB, updates click stats and returns a 303 back to the original URL. Apache/Jetty/Netty/tomcat/etc. are all fine.\n\nQ: How are click stats stored?\n\nA poor candidate will suggest write-back to a data store on every click\n\nA good candidate will suggest some form of aggregation tier that accepts clickstream data, aggregates it, and writes back a persistent data store periodically\n\nQ: How will the aggregation tier be partitioned?\n\nA great candidate will suggest a low-latency messaging system to buffer the click data and transfer it to the aggregation tier.\n\nA candidate may ask how often the stats need to be updated. If daily, storing in HDFS and running map/reduce jobs to compute stats is a reasonable approach If near real-time, the aggregation logic should compute stats\n\nQ: How to prevent visiting restricted sites?\n\nA good candidate can answer with maintaining a blacklist of hostnames in a KV store.\nA great candidate may propose some advanced scaling techniques like bloom filter.\n","categories":["系统设计"]},{"title":"常见系统设计题系列-抽奖系统","url":"/backend_knowledge_architecture/system_design/lottery.html","content":"\n## 不得不说的随机\n\n拿音乐播放器的随机播放举一个例子，一般音乐播放器的随机播放分两种：\n\n- 播放当前歌曲时才随机生成下一首，即完全随机（称为Random算法）\n- 将当前的list打乱顺序，然后依次播放，也就是大家所说的伪随机（称为Shuffle算法）\n\n对我们的Shuffle算法进行下抽象：\n\n> 一个从1到n的序列，随机打乱，保证每个数出现在任意一个位置的概率相同。\n\n<!-- more -->\n\n```cpp\n// 得到一个在闭区间 [min, max] 内的随机整数\nint randInt(int min, int max);\n\nvoid shuffle(int[] arr) {\n    int n = arr.length();\n    for (int i = 0 ; i < n; i++) {\n        // 从 i 到最后随机选一个元素\n        int rand = randInt(i, n - 1);\n        swap(arr[i], arr[rand]);\n    }\n}\n```\n\n### 按照权重生成随机数\n\n方法1: 如果随机选的话，在一个list中出现的次数多被选中的概率就会大。所以可以按照权重组合一个list，在这个list中A有50个，B有10个，C有100个，等等。有了list之后，从中随机选一个。这样选取的时间负责度是O(1)。但是如果数字很多，权重又很大的话，那么空间复杂度会很高。\n\n方法2: 对每个元素的权重进行加和记为sum，在1到sum之间随机选一个数。之后遍历整个集合，统计遍历到的项的权重之和，如果大于sum，则选择这个数。该方法需要遍历集合，时间复杂度为O(n)\n\n方案3: 上面方法最坏的情况是遍历完所有的元素，但是如果权重大的元素能够先被遍历的话可以减少遍历次数。基于此，可以先对元素按照权重排序。但是这样排序的话也会比较花时间。可以计算一个前项和序列，记录到每一项时的权重是多少。然后随机生成一个数，可以用二分查找找这个数对应的索引，也就可以找到对应的元素。\n\n跟nginx的WRR有什么区别呢？\n\n### 红包系统设计\n\n有以下几个要点：\n\n1. 预留足够的金额以确保每一个红包至少有钱（预留金额：0.01 * N)\n2. 对剩余金额进行分配，使分配结果符合某种需要的分布：截尾正态分布、纯随机分布等\n3. 考虑拆的时候实时算出来，而不预先分配的，采用的是纯内存计算，不需要预算空间存储。采取实时计算金额的考虑：预算需要占存储，实时效率很高，预先计算存起来才效率低。\n4. 数据库会累加已经领取的个数与金额，插入一条领取记录。入账则是后台异步操作。\n5. 二倍均值法，剩余红包金额为M，剩余人数为N，那么有如下公式：每次抢到的金额 = 随机区间?（0， M / N X 2）\n\n#### 微信红包架构\n\n方案一，使用内存操作替代实时的 DB 事务操作。\n    并发性能好，但是有可能丢失数据\n方案二，使用乐观锁替代悲观锁。\n    并发请求抢锁问题解决，但是用户体验不好\n\n正确姿势：\n\n1. 系统垂直 SET 化，分而治之。\n   1. 按照红包ID来hash分流\n2. 逻辑 Server 层将请求排队，解决 DB 并发问题。\n   1. 首先，将同一个红包 ID 的所有请求 stick 到同一台 Server。\n   2. 其次，设计单机请求排队方案。\n   3. 最后，增加 memcached 控制并发。\n3. 双维度库表设计，保障系统性能稳定\n   1. 按照db_{红包IDhash}.table_{红包日期1～31}\n\n### 蓄水池算法\n\n给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。\n\n考虑参加抽奖的用户基数很大且未知，也可以说是这个基数可能会动态地增加，那么在这种情况下，固定选取k个人中奖，如何保证实时参加抽奖的n个用户中每个人中奖的概率为k/n呢？（为何不在最终结果n出来时再来随机抽取k个样本，保证概率为k/n呢？其实这种想法有些时候是不可行的，数据是动态增长的，可能缓存系统存储不了所有的样本信息，但却足够存储k个样本的信息，即空间复杂度可以从O(n)降到O(k)，k相对n来说是非常小的。所以储水池算法还是很有应用价值的）\n","tags":["概率"],"categories":["系统设计"]},{"title":"常见系统设计题系列-地图最短路径","url":"/backend_knowledge_architecture/system_design/map_min_distance.html","content":"\n地图最短路径\n\n1. 建模：有向有环图，带权重，权重不为负数\n2. 选择合适的单源最短路算法（Dijkatra、BellmanFord)\n","tags":["图论"],"categories":["系统设计"]},{"title":"常见系统设计题系列-唯一ID生成","url":"/backend_knowledge_architecture/system_design/uniq_id.html","content":"\n## 唯一ID的用途\n\n- 作为业务数据的唯一标识，用该ID来进行分库分表\n- 使用绝对自增的ID作为绝对时钟的模拟\n\n## 业务系统对ID号的要求\n\n概括下来，那业务系统对ID号的要求有哪些呢？\n\n- 全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。\n\n- 趋势递增：可以作为排序字段\n- 单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。\n- 信息安全（防逆向）：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。\n- 一般会将该ID用作索引，为性能考虑考虑的话，一般使用64位整数。如果允许用字符串的话，用上面的UUID即可。\n- 实际项目中，我们更有可能使用53位整数作为唯一ID（主要考虑是JS等语言或者JSON协议等对int64的支持不好，其限制在于仅支持float)\n\n<!-- more -->\n\n## 常见实现方案\n\n### 借助数据库的主键ID\n\n优点：简单，绝对自增\n\n不足：该方案存在单点故障风险；另外，数据库能支撑的吞吐比较低\n\n优化：考虑多台Master，设置不同的步长\n\n### 借助Redis的incr\n\n优点：性能好、绝对自增\n\n不足：redis的定位是缓存，数据有丢失的可能。\n\n### 雪花算法\n\n实现思路：时间戳 + 机器ID + 自增ID（随机，而不要从0开始）\n\n优点：简单、性能好、趋势递增\n\n不足：依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成。\n\n#### 时钟回拨\n\n可以考虑通过历史时间（当自增ID发生回环时，进行+1）、扩展位（当检测到本次时间相比之前变小，则扩展位++）\n\n### 借助Zookeeper\n\n优点：唯一性有保证，上面雪花算法中的机器ID便可以考虑使用该方案来获取。\n\n不足：吞吐量低，仅32位\n\n### UUID\n\n本质：**去中心的生成方法本身没法保证唯一性**。一般降到实际可忽略的重复概率就能用了。分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。\n\n### Leaf算法\n\n实现思路：号段模式，由数据库先来负责分配号段，再由专门的分发服务来负责自增生成唯一ID\n\n优点：分布式，无单点；性能好\n\n不足：实现略复杂\n\n### 微信的自增ID生成\n\n给我们的一些启发：\n\n逻辑服务层：负责加载max_seq=>cur_seq，每次分配新的时，cur_seq++;如果超出，则持久化max_seq，从而减少了对store的读写\n\nstore层：负责存储每一个用户的max_seq，但是如果每一个用户都存储一个max_seq的话，使用的量有点大，可以考虑一个uid范围内的公用一个max_seqno\n\nstore的持久化：NRW策略（W +R > N)\n\nset化部署，号段隔离\n\n如何确保ID不回撤 等价于 如何确保一个号段的请求，总是落到同一个逻辑服务上。\n\n![租约机制](http://cdn.b5mang.com/202132014819.png)\n\n路由表：版本号\n\n第三方仲裁去更新路由表，逻辑服务去访问store层时去\n\n![动态号段迁移容灾](http://cdn.b5mang.com/202132014847.png)\n\n参考：https://www.infoq.cn/article/wechat-serial-number-generator-architecture\n","categories":["系统设计"]},{"title":"常见系统设计题系列-任务调度","url":"/backend_knowledge_architecture/system_design/task_scheduler.html","content":"\n## 单机版本\n\n核心数据结构：堆、时间轮、红黑树\n\n<!-- more -->\n\n触发机制\n\n如果时间还没有到，client的三种选择：\n\n- polling: 定期轮询检查是否有新的任务。缺点在于周期不好确定：太短的话造成CPU使用率过高，太长的话，任务得不到及时处理。\n- sleep时间差: sleep期间来了一个新的更紧急的任务呢？\n- 锁等待: 多个消费者，如果没有任务则等待；有任务，则leader负责await一段时间；如果来了更紧急的任务，其他线程也会被唤醒。\n\n## 分布式版本\n\nzset + zk watch机制\n\n其中zk watch实现的便是单机版的锁机制；zset则模拟了单机核心数据结构：堆\n\n参考：\n\ngithub.com/soulmachine/system-design/blob/master/cn/task-scheduler.md","tags":["堆"],"categories":["系统设计"]},{"title":"工作杂谈系列-普罗米修斯常用查询","url":"/work/Prometheus.html","content":"\n普罗米修斯字符串匹配查询语法：\n\n=: Select labels that are exactly equal to the provided string.\n!=: Select labels that are not equal to the provided string.\n=~: Select labels that regex-match the provided string.\n!~: Select labels that do not regex-match the provided string.\n\n具体可以看这里：\nhttps://prometheus.io/docs/prometheus/latest/querying/basics/\n"},{"title":"得到系列-《何帆宏观经济学30讲》","url":"/底层思维/宏观经济/hefan_economy50.html","content":"\n## 何帆宏观经济学30讲知识大纲\n\n宏观经济最初起源于\n\n### 宏观经济学-危机篇\n\n#### 识别危机\n\n纸老虎\n\n黑天鹅\n灰犀牛\n\n#### 正视危机：不是所有的危机都只有坏处？危机红利\n\n危机红利的两个层面：\n\n1. 危机是一种纠偏机制\n2. 前人的乐观加速了新技术基础设施的完善，为后人带来好处。\n\n带有技术创新的泡沫危机，对于我们来说是危机红利。\n\n#### 危机会持续多久：资本负债表危机\n\n资产的大幅缩水，使得企业资产负债表中的负债大幅增加。\n\n### 增长\n\n增长\n\nGDP\n\n促进经济增长的关键动力是什么：\n\n分工？\n重大创新？\n\n索洛模型是什么？\n\n与经济增长相关的几个要素：\n\n#### 人口\n\n人口总量\n\n人口结构\n\n人口红利\n\n#### 资本\n\n什么是资本？\n\n#### 技术创新\n\n技术创新源自哪里？\n\n#### 政治制度\n\n改革是万能的吗？\n\n休克疗法？\n\n小范围试点？\n\n### 政策\n\n#### 财政政策\n\n收入：税收\n\n支出：\n\n补贴 还是 减税？\n\n中央政府与地方政府的关系？\n\n积极财政：多花钱\n\n功能财政：少花钱\n\n#### 货币政策\n\n货币政策的目的\n\n货币政策的手段\n\n传导机制\n\n经济周期\n\n长期目标，短期目标\n\n### 开放\n\n#### 汇率\n\n汇率的定义：\n\n汇率制度的演变历史\n金本位=》\n\n每一种制度的优缺点\n\n金本位\n优点：汇率稳定，进出口投资方便\n不足：没有国内货币政策自主性\n\n降利率之后，大家会考虑\n\n两个国家\n\n#### 贸易\n\n贸易\n\n贸易\n\n#### 金融\n\n汇率是什么？\n\n贬值不可怕，可怕的是贬值预期！\n\n![经济增长后200年加速](http://cdn.b5mang.com/202112414023.png)\n\n人口问题的本质：虽然很难干预人口总量，但是我们干预人口在不同部门之间的分配。\n\n人口红利，不是一个总量概念，而是一个结构概念，他说的是人口从低生产率部门向高生产率部门的转移\n\n资本：可以用来交易的资产。\n\n法律保护的是：交易权，交易权比所有权更重要。\n\n资本不是看得见摸得着的实物积累，而是看不见摸不着的软性制度积累。\n\n制度的建设：法律、银行等金融的资金价格评估等\n\n持续增长，必须依靠技术创新。\n一方面，靠经验，本质上还是靠资本的积累（生产规模越大，累积的经验就越多）\n\n![库兹涅茨曲线](http://cdn.b5mang.com/202112415274.png)\n短期是对的，长期是错误的。放松管制以来，贫富差距一直在变大\n\n财富差距 vs 收入差距\n\n资本回报率超过经济增长率\n\n改变收入差距相对容易，但是改变财富差距很难。\n\n没有公平，就没有效率。\n\n如何开启工业化进程：\n（1）政府规划\n（2）靠市场来配置资源\n\n经济转型：\n轻工业（劳动力相对富足）\n能源、交通等基础设施（因为轻工业快速发展对这些基建提出了要求：前期是可以进口的，后期进口就不划算了）\n为大规模工业生产提供支持的行业（钢铁、机床、金融）\n\n工业GDP占总GDP的40%，是谓有足够的燃料，已经进入发达国家的既定轨道。\n\n教育、医疗、养老等问题，并不会因为经济增长而解决。\n\n社会主要矛盾：人们日益增长的美好生活需要和不平衡、不充分的发展之间的矛盾"},{"title":"计算机解决问题的通用套路-回溯","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/backtracking.html","content":"\n## 关于回溯，你一定要知道的\n\n* Q: 回溯的定义与核心思想\n\nA: 根据百度百科的定义，回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。回溯算法（Backtrack）是一种试错思想，本质上是深度优先搜索。即：从问题的某一种状态出发，依次尝试现有状态可以做出的选择从而进入下一个状态。递归这个过程，如果在某个状态无法做更多选择，或者已经找到目标答案时，则回退一步甚至多步重新尝试，直到最终所有选择都尝试过。\n\n* Q：回溯算法涉及到的一些概念\n\nA: 问题的解空间（Solution Space)：针对一个问题的某一种枚举元素，我们做出多次枚举，这样子下来所有的解会构成一个树形结构，树的每一个节点是该问题的一个可能解，我们把这些可能解的集合称之为解空间。\n\n状态（**State** of this problem)：当前的搜索深度，以及该深度的一些局面信息\n\n选择（avaiable **Choosen** based on current state) ：基于当前状态能够进一步做出的**选择**\n\n路径（**Path** of choosen for solving this problem）：为了解决这个问题，走到当前状态，每一步做出的选择构成了一个列表，这个列表称之为**路径**\n\n结果集（**Result**: all paths which can slove this problem)：对于求解可行解或者所有解类型的回溯问题，我们需要把所有的可行路径记录下来，这个用来存储可行路径的容器我们称之为**结果集**\n\nQ：回溯算法的三要素\n\nA：路径：已经做出的选择\n\n选择列表：当前状态可以做出的选择\n\n结束条件：选择列表为空，或者找到目标\n\n<!-- more -->\n\n* Q：每一类经典问题的解空间大小\n\n|  问题 | 解性质|枚举对象 |选择数   |搜索空间|原始解空间大小|\n|  ----  | ----|---- |----  |----|----  |\n|组合问题（从N个数字中选K个）|所有解| N个数字 |2（选OR不选）|子集树|$2^N$|\n|组合问题（从N个数字中选K个）|所有解| K个坑位 |N（每一个坑位都有N个数字）|N叉树|$N^K$或者${N \\choose K}$|\n|子集问题（求包含N个数字的集合的所有子集）|所有解| N个数字 |2（选OR不选）|子集树|$2^N$|\n|排列问题（求N个字符的全排列）|所有解| N个坑位 |N（每一个坑位都有N个数字）|排列树|$N!$|\n|排列问题（求N个字符的全排列）|所有解| N个数字 |N(每一个数字都有N个坑位）|排列树|$N!$|\n|N皇后问题|可行解  |N行|N列可以选择|排列树|$N!$|\n|N皇后问题| 可行解|$N^2$个格子 |2（选OR不选）|子集树|$2^{N^2}$|\n|01背包问题| 最优解|$N$个物品 |2（选OR不选）|子集树|$2^N$|\n\n![回溯算法的典型例题和适用特点](http://cdn.b5mang.com/202111402329.png)\n\n注意上图中的解描述向量，\n\n从上面的表格可以看出，即使是同一个问题，如果枚举对象不一样，就会得到完全的解空间树。我们在解决实际问题时，一定要谨慎选择枚举对象。\n\n另外，子集树、排列树是比较常见的两类解空间树。\n\n当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树。例如：n个物品的0-1背包问题所相应的解空间是一棵子集树，这类子集树通常有$2^n$个叶结点，其结点总数为$2^{n+1}-1$。\n\n当所给问题的确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有$n!$个叶结点，因此遍历排列树需要$n!$的计算时间。\n\n解空间树大小与树的深度以及宽度有关：深度（for循环的层数）与宽度（每层的选择数）\n\n* Q: 回溯算法解决问题的一般步骤\n\nA：\n\n```cpp\n    //某一个STATE，在CHOOSE的作用下，可以切换到一个新的STATE。有多少种CHOICE，就会有多少种新的STATE。\n    //退出条件：（1）对于最优解：选择列表为空（2）获取单个可行解问题：选择列表为空或者找到一组解\n    vector<PATH> result; //结果集用来存放路径-PATH\n    vector<CHOICE> path;\n    bool<STATE> visited;\n    void dfs(STATE cur_state) {\n        if (is_solution(cur_state)) {\n            result.push_back(path);\n            //这里是否return，取决于我们是仅需获取一个可行解还是要获取所有可行解\n            return;\n        }\n\n        vector<CHOICE> choices = get_all_choices_by_state(cur_state);\n        //这里隐含一个退出条件，如果该state下可以做出的可行选择为空，回溯也会结束。\n        for (each choice : choices) {\n            STATE new_state = trans_to_new_state_by_choice(cur_state, choice);\n            if (visited(new_state)) { \n                continue;\n            }\n            path.append(choice);\n            visited[new_state] = true;\n            dfs(new_state);\n            visited[new_state] = false;\n            path.remove(choice);\n        }\n    }\n```\n\n* Q：写出正确的回溯算法为什么那么难？\n\nA: 写不出正确的回溯算法主要有以下几个原因：\n\n第一，没有合适的代码模版。上面便提供了一个比较通用的模版，建议读者在理解的基础上背过它。\n\n第二，搞不清楚什么时候return,什么时候回溯，以及怎么回溯。一般而言，对于寻找最优解或者找到所有可行解的问题，我们需要在没有更多选择的时候进行return。\n而对于寻找一个合法解的情况，我们在找到一组合法解的时候，直接return即可。具体可以见：[findPathInTree](../findPathInTree.html)。\n\n第三，无重复元素的回溯搞得定，但是不会处理有重复元素的情况。这里需要理清楚**树枝去重**与**树层去重**两个概念\n\n可以参考：\n\nhttps://zhuanlan.zhihu.com/p/339849416\n\nhttps://www.jianshu.com/p/23737ee122bf\n\n## 回溯相关题目索引\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n|常规回溯| [机器人移动次数](moving_cnt.html)  ||\n|常规回溯| [是否有字符串路径](has_str_path.html)  ||\n|排列组合系列| [回溯系列-组合排列](combination_permutation.html)  ||\n","tags":["回溯"],"categories":["数据结构与算法"]},{"title":"回溯-机器人移动次数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/moving_cnt.html","content":"\n地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。\n\n一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。\n\n但是不能进入行坐标和列坐标的数位之和大于 k 的格子。\n\n请问该机器人能够达到多少个格子？\n\n样例1\n输入：k=7, m=4, n=5\n\n输出：20\n样例2\n输入：k=18, m=40, n=40\n\n输出：1484\n\n解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。\n但是，它不能进入方格（35,38），因为3+5+3+8 = 19。\n\n## 解题思路\n\n状态：<i, j> + 访问位图\n\n选择: 四个方向\n\n路径：该问题不需要\n\n结果集：计算总数\n\n结束条件： 没有更多选择\n\n## 示例代码\n\n```cpp\nclass Solution {\npublic:\n    int t;\n    vector<bool> visit;\n    int cnt;\n    \n    bool check(int i, int j) {\n        return (i / 10 + i % 10 + j / 10 + j % 10) <= t;\n    }\n    \n    void dfs(int i, int j, int rows, int cols){\n        if (!check(i, j)) return;\n        visit[i * cols + j] = true;\n        cnt++;\n        \n        int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n        \n        for (int k = 0; k < 4; ++k) {\n            int ni = i + dx[k], nj = j + dy[k];\n            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && !visit[ni * cols + nj]) {\n                dfs(ni, nj, rows, cols);\n            }\n        }\n    }\n    \n    int movingCount(int threshold, int rows, int cols)\n    {\n        if (!rows && !cols) return 0;\n        t = threshold;\n        visit = vector<bool>((rows + 1) * (cols + 1), false);\n        dfs(0, 0, rows, cols);\n        return cnt;\n    }\n};\n```\n","tags":["回溯"],"categories":["数据结构与算法"]},{"title":"回溯-矩阵中找字符串","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/has_str_path.html","content":"\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。\n\n路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。\n\n如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。\n\n注意：\n\n输入的路径不为空；\n所有出现的字符均为大写英文字母；\n样例\nmatrix=\n[\n[\"A\",\"B\",\"C\",\"E\"],\n[\"S\",\"F\",\"C\",\"S\"],\n[\"A\",\"D\",\"E\",\"E\"]\n]\n\nstr=\"BCCE\" , return \"true\"\n\nstr=\"ASAE\" , return \"false\"\n\n## 解题思路\n\n状态：<i, j> + 访问位图\n\n选择: 四个方向\n\n路径：该问题不需要\n\n结果集：不需奥\n\n结束条件： 找到任何一个解就可以推出。\n\n## 示例代码\n\n```cpp\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& matrix, string &str, int u, int x, int y) {\n        //视频中的错误写法（测试用例不全导致）\n        //if (u == str.length()) return true;\n        //if (matrix[sx][y] != str[u]) return false;\n\n        //肯定不合适\n        if (matrix[x][y] != str[u]) return false;\n        //已经到底了，返回ok\n        if (u == str.length() - 1) return true; \n\n        int t = matrix[x][y];\n        matrix[x][y] = '#';\n\n        int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\n        for (int i = 0; i < 4; ++i) {\n            int a = x + dx[i], b = y + dy[i];\n            if (a >= 0 && a < matrix.size() && b >= 0 && b < matrix[a].size()) {\n                if (dfs(matrix, str, u + 1, a, b)) return true;\n            }\n        }\n\n        matrix[x][y] = t;\n        return false;\n    }\n\n    bool hasPath(vector<vector<char>>& matrix, string &str) {\n        for (int i = 0; i < matrix.size(); ++i) {\n            for (int j = 0; j < matrix[i].size(); ++j) {\n                if (dfs(matrix, str, 0, i, j))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n};\n\n```\n","tags":["回溯"],"categories":["数据结构与算法"]},{"title":"二叉树系列-二叉树常用套路汇总&必知必会","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/index.html","content":"\n## 关于二叉树，你一定要知道的\n\n* Q：二叉树遍历\n\nA: 作为图的一种简单形式，树也有两种遍历方式：广度优先、深度优先；广度优先的话，即对应二叉树的按层次遍历；深度优先的话，我们可以按照中间节点的访问顺序， 进一步分为先序遍历（中、左、右）、中序遍历（左、中、右）、后序遍历（左、右、中）。\n\n* Q：二叉树的层次遍历（BFS遍历）\n\nA: 通常我们借助队列（queue)来辅助完成分层遍历。 还有某些情况，我们需要了解到每一个节点的深度（也就是位于第几层）。对于这种要求，我在下面的代码模版中给出了一种解决方案，供参考。\n\n<!-- more -->\n\n* Q：二叉树的常规遍历（DFS遍历）\n\nA: 如前面所讲，常规遍历分为前中后序三种；实现的话，又分为递归版本和迭代版本。具体可以参考下面的代码。\n\n* Q: 二叉树的遍历（前中后序遍历、层次遍历）与图的遍历（DFS、BFS）的联系与区别\n\nA: 联系在于二叉树遍历是图遍历的一种简化形式；区别在于，tree的遍历不需要st来保存访问状态，不需要通过遍历的方式来访问相邻节点，直接通过left、right即可。\n\n* Q: 回溯是什么？回溯一般用递归来实现，那如果有递归，一定会回溯吗？\n\nA: 关于回溯是什么，这里不展开讨论，后续会有专门文章来细讲。\n\n我们尝试着来回答第二个问题：有递归是否一定会有回溯。首先**递归是一种算法结构**，**回溯是一种思想**，一种通过枚举解空间来找到最优解的问题解决套路，两者本质是不同的，自然也就**没有有递归一定有回溯**的说法。\n\n例如，我通过递归来解决斐波那契数列数列的计算问题，$f(n)=f(n-1) + f(n-2)$ ，这里是有递归发生的，但完全不涉及回溯算法中保存现场、还原现场这些概念。\n\n* Q: 为什么二叉树的遍历过程中我感觉不到回溯？\n\nA: 这里我给出的答案是，“感觉不到有两方面原因：第一，感觉不到是由于实际上就没有发生回溯；第二，感觉不到是由于在回溯前后使用的是局部变量，系统自动帮我们进行了现场的保存与还原”。\n\n在遍历二叉树时是否发生回溯，取决于我们解决问题的视角。如果我们是从子问题视角去解决问题，那么我们大概是看不到回溯的影子的。\n\n但如果我们是从遍历整个树的视角去解决问题，那么我们就会看到回溯。\n\n* Q: 二叉树的遍历过程与回溯的联系与区别又是什么？\n\nA: 我们平常在利用回溯求解问题时，会把问题的解空间想像成一个二叉树或者多叉树，整个回溯的过程就是在进行这个树的遍历。\n\n所以要说两者的联系的话，我们可以把二叉树遍历当作是回溯的一种实现形式。回溯的代码写出来，都特别类似于我们在遍历一颗多叉树。\n\n## 二叉树相关的代码模版\n\n图的DFS一般形式\n\n```cpp\n    bool st[N]; //表示某一个节点是否访问过\n    void dfs(int u) {\n        //访问节点u\n        st[u] = true;\n        for (与节点u相邻的所有节点 x ) {\n             if (!st[x]) {\n                 dfs(x);\n             }\n        }\n    }\n```\n\n多叉树的DFS一般形式（以B树的先序遍历为例）\n\n与上面图的DFS很像，只是没有用st来记录某个节点是否被访问过。这是为什么呢？因为对于树的访问都是从父亲到孩子，从上到下，所以从来不会重复访问到之前访问过的节点，也就没有必要用st来保存访问状态了。\n\n```cpp\n    struct TreeNode {\n        int val;\n        TreeNode* children[N];\n    };\n\n    void dfs(TreeNode* root) {\n        //访问节点root\n        cout << root->val << endl;\n        for (child in root->children ) {\n            dfs(child);\n        }\n    }\n```\n\n树的DFS一般形式(以先序遍历为例)\n\n```cpp\n    struct TreeNode {\n        int val;\n        TreeNode* left;\n        TreeNode* right;\n    };\n    void dfs(TreeNode* root) {\n        //访问节点root\n        cout << root->val << endl;\n        //对于最常见的二叉树来说，与root相邻的节点只有左、右两个孩子节点，所以就不用for循环了。\n        dfs(root->left);\n        dfs(root->right);\n    }\n```\n\n树的BFS一般形式（仅需按照层的顺序访问到每一个节点即可）\n\n```cpp\n    void bfs(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        while (q.size()) {\n            auto x = q.front(); q.pop();\n            //访问当前节点x\n            if (x->left) q.push(x->left);\n            if (r->right) q.push(x->right);\n        }\n    }\n```\n\n树的BFS特殊形式（不仅要访问到节点，还要了解到节点的所属层次）\n\n```cpp\n    void bfs(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        while (q.size()) {\n            int n = q.size(); //注意这里不可以使用q.size()来代替n\n            for (int i = 0; i < n; ++i) {\n                auto x = q.front(); q.pop();\n                //访问当前节点x\n                if (x->left) q.push(x->left);\n                if (r->right) q.push(x->right);\n            }\n        }\n    }\n```\n\n二叉树的前、中、后序遍历（迭代版本）\n\n```cpp\n    void pre_dfs(TreeNode* root) {\n        cout << root->val << endl;  //访问节点root\n        pre_dfs(root->left);\n        pre_dfs(root->right);\n    }\n\n    void in_dfs(TreeNode* root) {\n        \n        cout << root->val << endl;  //访问节点root\n        in_dfs(root->left);\n        in_dfs(root->right);\n    }\n\n    void post_dfs(TreeNode* root) {\n        post_dfs(root->left);\n        post_dfs(root->right);\n        cout << root->val << endl;  //访问节点root\n    }\n```\n\n二叉树的前、中、后序遍历（统一非迭代版本）\n\n如同递归版本一样，非递归版本的代码形式也是完全一致的，区别仅在于节点的压栈顺序不同，特别容易记忆。\n\n```cpp\n    void pre_travel(TreeNode* root) {\n        stack<TreeNode*> s;\n        s.push(root);\n\n        while (s.size()) {\n            auto x = s.top(); s.pop();\n            if (x) {\n                //由于是前序遍历，所以节点访问序是：中，左，右；又由于是栈（后进先出），所以入栈顺序是：右、左、中\n                if (x->right) s.push(x->right);\n                if (x->left) s.push(x->left);\n                s.push(x);\n                s.push(NULL);\n            } else {  //前一个指针是null，说明下一个就是要访问的节点\n                x = s.top(); s.pop(); \n                cout << x->val << endl;  //访问节点x\n            }\n        }\n    }\n\n    void in_travel(TreeNode* root) {\n        stack<TreeNode*> s;\n        s.push(root);\n\n        while (s.size()) {\n            auto x = s.top(); s.pop();\n            if (x) {\n                //由于是中序遍历，所以节点访问序是：左，中，右；又由于是栈（后进先出），所以入栈顺序是：右、中、左\n                if (x->right) s.push(x->right);\n                s.push(x);\n                s.push(NULL);\n                if (x->left) s.push(x->left);\n            } else {  //前一个指针是null，说明下一个就是要访问的节点\n                x = s.top(); s.pop(); \n                cout << x->val << endl;  //访问节点x\n            }\n        }\n    }\n\n    void post_travel(TreeNode* root) {\n        stack<TreeNode*> s;\n        s.push(root);\n\n        while (s.size()) {\n            auto x = s.top(); s.pop();\n            if (x) {\n                //由于是后序遍历，所以节点访问序是：左，右，中；又由于是栈（后进先出），所以入栈顺序是：中、右、左\n                s.push(x);\n                s.push(NULL);\n                if (x->right) s.push(x->right);\n                if (x->left) s.push(x->left);\n            } else {  //前一个指针是null，说明下一个就是要访问的节点\n                x = s.top(); s.pop(); \n                cout << x->val << endl;  //访问节点x\n            }\n        }\n    }\n\n    //不关心访问顺序，仅需要每一个节点能够访问到（也就是前序遍历）\n     void no_care_travel(TreeNode* root) {\n        stack<TreeNode*> s;\n        s.push(root);\n\n        while (s.size()) {\n            auto x = s.top(); s.pop();\n            if (x) {\n                //visit x directly\n                if (x->right) s.push(x->right);\n                if (x->left) s.push(x->left);\n            } \n        }\n    }\n```\n\n树的深度求解（递归子问题的视角）\n\n如果从**递归子问题的视角**来看，为了求得树的深度，我们需要解决两个子问题：左右子树的深度分别是多少。在解决了这两个子问题之后，总的问题的解就等于 1 + max(left_depth, right_depth) 了。\n\n从这个视角来看，确实是没有回溯发生的。具体代码如下：\n\n```cpp\n  int treeDepth(TreeNode* root) {\n        if (!root) return 0;\n        int left_depth = treeDepth(root->right);\n        int right_depth = treeDepth(root->left);\n        return 1 + max(left_depth, right_depth);\n    }\n```\n\n树的深度求解（二叉树遍历的视角）\n\n如果从二叉树遍历的视角来看呢， 我为了求得树的深度，我需要**访问到所有的叶子节点**，并记录下每一个叶子节点的深度，然后与当前的最大深度去比较。\n\n```cpp\nclass Solution {\npublic:\n    int result;\n    void getDepth(TreeNode* node, int depth) {\n        result = depth > result ? depth : result; // 中\n\n        if (node->left == NULL && node->right == NULL) return ;\n\n        if (node->left) { // 左\n            depth++;    // 深度+1\n            getDepth(node->left, depth);\n            depth--;    // 回溯，深度-1\n        }\n        if (node->right) { // 右\n            depth++;    // 深度+1\n            getDepth(node->right, depth);\n            depth--;    // 回溯，深度-1\n        }\n        return ;\n    }\n    int maxDepth(TreeNode* root) {\n        result = 0;\n        if (root == 0) return result;\n        getDepth(root, 1);\n        return result;\n    }\n};\n```\n\n树的深度求解（二叉树遍历的视角，局部变量隐藏回溯细节）\n\n还是上面的思路，但是下面的写法会更加精简，同时也隐藏了回溯细节，让人感觉不到回溯的存在。\n\n```cpp\nclass Solution {\npublic:\n    int result;\n    void getDepth(TreeNode* node, int depth) {\n        result = depth > result ? depth : result; // 中\n\n        if (node->left == NULL && node->right == NULL) return ;\n\n        if (node->left) { // 左\n            //注意：这里depth+1作为一个临时变量传给子节点\n            getDepth(node->left, depth + 1);\n        }\n        if (node->right) { // 右\n            getDepth(node->right, depth + 1);\n        }\n        return ;\n    }\n    int maxDepth(TreeNode* root) {\n        result = 0;\n        if (root == 0) return result;\n        getDepth(root, 1);\n        return result;\n    }\n};\n```\n\n## 二叉树相关题目索引\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n|二叉树遍历| [获取树的深度](./treeDepth.html)  ||\n|二叉树遍历 | [最低公共祖先](./lowest_ancestor.html)  ||\n|二叉树遍历| [二叉树镜像](./mirror.html)  ||\n|二叉树遍历 | [判断二叉树是否对称](./isSymmetric.html)  ||\n|二叉树遍历 | [判定是否平衡树](./isBalanced.html)  ||\n|二叉树遍历 | [二叉树子结构](./hasSubtree.html)  ||\n|二叉树遍历 | [二叉树的序列化与反序列化](./deserialize.html)  |二叉树遍历|\n|二叉树构建 | [根据前序序列与中序序列重建二叉树](pre_in_build.html)  ||\n|二叉树层次遍历 | [从上往下打印出二叉树的每个结点](./printFromTopToBottom.html)  ||\n|二叉搜索树遍历| [二叉搜索树转有序双向链表](./tree2list.html)  ||\n|二叉搜索树遍历 | [获取第k个节点](./kthNode.html)  |全局变量技巧|\n|二叉搜索树遍历 | [判断该数组是不是某二叉搜索树的后序遍历的结果](../verifySequenceOfBST.html)  ||\n|二叉搜索树遍历 | [中序遍历序列的下一个节点](./inorderSuccessor.html)  ||\n|二叉树遍历系列 | [二叉树中结点值的和为输入整数的所有路径](./findPathInTree.html)  ||\n|二叉树遍历系列 | [求二叉树中节点的最大距离](GetMaxDistance.html)  |全局变量技巧|\n|二叉树遍历系列 | [二叉树的路径打印](node_path.html)  ||\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"位运算系列-分类索引","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/bit/index.html","content":"\n位操作\n\n## 关于位操作，你一定要知道的\n\n## 位操作的常见技巧\n\n第一个需要掌握的技巧是**n & (n - 1)**，通过该操作我们可以让n的**最后一个1变为0**。\n\n第二个需要掌握的技巧是**lowbit(n) = n & (-n)** ,lowbit操作可以让我们获取到n的低位。\n\n第三个需要知道的是**二进制表示下不进位**，例如：XOR又称作不进位加法。\n\n第四个技巧在于 **n XOR 1**成对变换。\n\n最后，掌握二进制位状态压缩的常见操作\n\n| 操作   | 运算 | 说明\n|  ----  | ----  | ----\n| 取出n的第k位   | n & (1 << k) | n & (00010000)\n| 取出n的后k位   | n & (1 << k) - 1 |n & (00011111)\n| n的第k位取反   | n xor (1 << k) | n xor 00010000\n| n的第k位置1  | n &#124; (1 << k) | n &#124; 000010000\n| n的第k位置0  | n & ~(1 << k) | n & 1111101111\n\n## 位操作相关的经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [比特位计数](bit_dp.html)  ||\n| | [找到序列中仅出现一次的数字](findNumsAppearOnce.html)  |位操作-XOR操作|\n| | [该数二进制表示中1的个数](NumberOf1.html)  |位操作-找1|\n| | [通过位运算来实现加法](../bit_add.html)  |XOR技巧|","tags":["位运算"],"categories":["数据结构与算法"]},{"title":"动态规划背包问题-01背包","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/bag/bag_01.html","content":"\n|  01背包问题  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N个物品，其中第i个物品的体积为$V_i$，价值为$W_i$。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。https://zhuanlan.zhihu.com/p/30959069|\n| 状态表示  |F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值|\n| 阶段划分 | 主阶段：已经处理的物品数，以背包中放入到的物品总体积为附加维度|\n| 转移方程  |$F[i,j]=\\begin{cases}F[i-1,j] & \\text { 不选第i个物品} \\\\ F[i-1,j-V_i] + W_i & \\text{if } j \\ge V_i  \\text{ 选第i个物品} \\end{cases}$|\n| 边界  | F[0,0]=0，其余为负无穷|\n| 目标  | $\\underset{0 \\le j \\le M}{\\mathrm{max}}{F[N,j]}$|\n| 优化  | 仅依赖前一项，可以通过滚动数组或者倒序循环做空间优化|\n\n另外，还有一种状态表示：\n即F[i; v] 表示前i 件物品恰放入一个容量为v 的背包可以获得的最大价值。则其状态转移方程便是：\n\nF[i,v] = max(F[i -1, v], F[i-1 , v-C[i]] + W[i])\n\n这样子表示状态后，目标变为F[N, M]\n\neg. 划分数组为两个相等的子集\n\n找sum一半\n","tags":["动态规划","背包问题"],"categories":["数据结构与算法"]},{"title":"动态规划背包问题-完全背包","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/bag/bag_complete.html","content":"\n|  完全背包问题  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N个物品，其中第i个物品的体积为$V_i$，价值为$W_i$，并且有无限个。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。|\n| 状态表示  |F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值|\n| 阶段划分 | 主阶段：已经处理的物品数，以背包中放入到的物品总体积为附加维度|\n| 转移方程  |$F[i,j]=\\begin{cases}F[i-1,j] & \\text {不选第i个物品} \\\\ F[i,j-V_i] + W_i & \\text{if } j \\ge V_i  & \\text{ 选第i个物品} \\end{cases}$|\n| 边界  | F[0,0]=0，其余为负无穷|\n| 目标  | $\\underset{0 \\le j \\le M}{\\mathrm{max}}{F[N,j]}$|\n| 优化  | 正循环做空间优化|","tags":["动态规划","背包问题"],"categories":["数据结构与算法"]},{"title":"动态规划背包问题-分组背包","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/bag/bag_group.html","content":"|  分组背包问题  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N个物品，其中第i组有$C_i$个物品。第i组的第j个物品的体积为$V_{ij}$，价值为$W_{ij}$。有一个容积为M的背包，要求选择一些物品放入背包，使得每组最多选择一个物品并且总体积不超过M的前提下，物品总价值和最大。|\n| 状态表示  |F[i,j]表示从前i组选出了总体积为j的物品放入背包，物品的最大价值|\n| 转移方程  |$F[i,j]=\\begin{cases}F[i-1,j] & \\text { 不选第i组的物品} \\\\ \\underset{1 \\le k \\le C_i}{\\mathrm{max}}{F[i - 1,j - V_{ik}] + W_{ik}} &\\text{ 选第i个物品} \\end{cases}$|\n| 阶段划分 | 主阶段：i物品组数是阶段，i与j共同组成状态，k是决策|\n| 边界  | F[0,0]=0，其余为负无穷|\n| 目标  | $\\underset{0 \\le j \\le M}{\\mathrm{max}}{F[N,j]}$|\n| 优化  | 正循环做空间优化|\n","tags":["动态规划","背包问题"],"categories":["数据结构与算法"]},{"title":"动态规划背包问题-多重背包","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/bag/bag_multiple.html","content":"\n|  多重背包问题  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N个物品，其中第i种物品的体积为$V_i$，价值为$W_i$，并且有$C_i$个。有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品总价值和最大。|\n| 问题转换  |将第i种物品看作独立的$C_i$个物品，从而转换为共有$\\sum\\limits_{i=1}^{N}C_i$个物品的0/1背包问题|\n| 问题转换  |将数量为$C_i$的第i个物品拆成p+2个物品，他们的体积分别为：$2^0V_i,2^1V_i,\\dots,2^pV_i,R_iV_i$，其中$R_i=C_i-2^0-2^1-\\dots-2^p$|\n| 问题优化  |可借助单调队列优化|\n","tags":["动态规划","背包问题"],"categories":["数据结构与算法"]},{"title":"动态规划分类索引","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/index.html","content":"### DP概念\n\n动态规划是运筹学的一个分支，是一种求解多阶段决策过程最优化问题的数学方法。要搞清楚它，首先需要搞清楚几个基本概念。\n\n阶段：整个决策过程可以按某个（空间、时间或其它）标准分为多个步骤，每一步称为一个阶段。比如下棋，走一步就可以认为是一个阶段。\n\n状态：状态表示在每个阶段我们关注的决策相关的影响因素的情况。比如下棋到某一步时，此刻棋盘上所有棋子的位置就是此阶段的状态。状态通常可以用一个或多个变量来描述。\n\n决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择行动方法称为决策。比如下棋到某一步时，决定下一步怎么走，就是一步决策，也叫单阶段决策。决策通常也可以用变量来描述。\n\n策略：由每个阶段的决策组成的序列称为策略，也就是多阶段决策。比如下棋，从开始下到结束的每一步走法构成了一个策略。策略可能有很多种，其中达到最优效果的策略称为最优策略。\n\n状态转移方程：从一个阶段到下一个阶段的状态变化，称为状态转移，如果这个变化可以用方程来描述，则称之为状态转移方程。\n\n无后效性：说的是一旦某个阶段的状态确定，则此后过程的演变不再受此前各种状态及决策的影响。也就是说历史信息不会影响我们以后的决策。比如下棋，现在已经有一个棋面，有可能是随机摆成的，也可能是认真下成这样的，但是不管怎样这不影响我们去决定下一步应该怎么下。当前的棋面是唯一影响未来的东西。\n\n最优⼦结构：如果每个阶段的最优状态可以从之前某个或某些阶段的某个或某些状态直接得到，也就是说一个问题的最优解可以由其子问题的最优解来得到，我们称其具有最优子结构。\n\n重叠⼦问题：在求解一个问题时需要先求解其子问题，子问题又有子问题，若在求解过程中需要重复求解某些子问题，这些子问题称为重叠子问题。对于重叠子问题不需要重复求解，只需要求解一次，然后记录下来，以后每次查询就可以了，可以大大降低运行时间，即用空间换时间。\n\n参考：https://blog.csdn.net/tyst08/article/details/106412008\n\n简单起见，下面用大家非常熟悉的求斐波拉契数列的过程来说明这几个概念。斐波拉契数列的公式为：\n\nf(1)=f(2)=1\n\nf(n)=f(n−1)+f(n−2)(n≥3)\n\n假设我现在想计算第10个非波那契数，那么计算每一个斐波拉契数的过程就是一个阶段，每一个斐波拉契数就是这个问题的一个状态。按照公式计算就是决策。每一步都按公式算就是策略。状态转移方程为 f ( n ) = f ( n − 1 ) + f ( n − 2 ) f(n) = f(n-1) + f(n-2)f(n)=f(n−1)+f(n−2)。求一个新数字只需要之前的两个状态，与怎么得到这个状态值无关，所以具有无后效性。每个阶段的状态即斐波拉契数可以由之前的两个状态得到，所以具有最优子结构。根据公式，求 f ( n ) f(n)f(n) 时需要求 f ( n − 2 ) f(n-2)f(n−2)，求 f ( n − 1 ) f(n-1)f(n−1) 时也需要求 f ( n − 2 ) f(n-2)f(n−2)，所以有重叠⼦问题。\n\n动态规划就是利用最优子结构，把**多阶段决策过程的最优化问题**转化为一系列**单阶段最优化问题**，然后逐个求解子问题。在每一个子问题的求解中，均可以利用了它前面的子问题的最优化结果，依次进行，直到得到最后一个子问题的最优解，也就是整个问题的最优解。\n\n动态规划的流程一般可以分为以下几步：\n\n1. 对决策过程划分阶段。\n2. 对各阶段确定状态变量。\n3. 根据状态变量确定每个决策的开销以及最终的目标函数。\n4. 建立各阶段状态变量的转移过程，确定状态转移方程。\n5. 根据状态转移方程用代码来实现，一般可以用递归，注意对重叠子问题要记录其解。\n\n### 动态规划优化策略\n\n1. 费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算\n2. 空间压缩\n\n### 经典问题\n\n常见的动态规划问题有哪些：\n\n|  打家劫舍（普通版本）  | |\n|  ----  | ----  |\n| 问题描述   |不能打结连续的两家人|\n| 状态表示  |F[i]表示前 i 间房屋能偷窃到的最高总金额|\n| 阶段划分 | 空间特征，子序列的结尾位置（数列A中的位置，从前到后） |\n| 转移方程  |$F[i]=max(F[i-1], F[i-2]+A[i])$|\n| 边界  | F[0]= 0|\n| 目标  | $F[N]$|\n| 优化点  | 只跟前2有关系，滚动数组|\n| 相关题目  |  |\n\n|  打家劫舍（环形数组）  | |\n|  ----  | ----  |\n| 问题描述   |不能打结连续的两家人|\n| 状态表示  |F[i]表示前 i 间房屋能偷窃到的最高总金额|\n| 阶段划分 | 空间特征，子序列的结尾位置（数列A中的位置，从前到后） |\n| 转移方程  |$F[i]=max(F[i-1], F[i-2]+A[i])$|\n| 边界  | F[0]= 0|\n| 目标  | $F[N]$|\n| 优化点  | 连续两次普通版本，分别是打结第一家 OR 不打结第一家|\n| 相关题目  |  |\n\n|  打家劫舍（二叉树版本）  | |\n|  ----  | ----  |\n| 问题描述   | |\n| 状态表示  |dp[HASH_KEY] = MONEY|\n| 阶段划分 |  |\n| 转移方程  ||\n| 边界  | |\n| 目标  |二叉树遍历 + 记忆化搜索加速|\n| 相关题目  |  |\n\n|  LIS（Longest Increasing Subsequence）问题  | |\n|  ----  | ----  |\n| 问题描述   | 最长上升子序列。给定一个长度为N的数列A，求数值单调递增的子序列的长度最长是多少。A的任意子序列B可表示为$B={A_{k_1},A_{k_2},A_{k_3},\\ldots,A_{k_p}}$，其中$k_1 < k_2 <\\ldots<k_p$|\n| 状态表示  |F[i]表示以A[i]为结尾的最长上升子序列的长度|\n| 阶段划分 | 空间特征，子序列的结尾位置（数列A中的位置，从前到后） |\n| 转移方程  |$F[i]=\\underset{0 \\le j \\lt i,A[j] \\lt A[i]}{\\mathrm{max}}\\{F[j] + 1\\}$ 需要遍历j|\n| 边界  | F[0]= 0|\n| 目标  | $\\underset{1 \\le i \\le N}{\\mathrm{max}}{F[i]}$|\n| 相关题目  | 俄罗斯信封套娃问题 |\n\n|  LCS问题  | |\n|  ----  | ----  |\n| 问题描述   | 最长公共子序列。给定两个长度分别为N和M的字符串A和B，求即是A的子序列又是B的子序列的字符串长度最长是多少。|\n| 状态表示  |F[i,j]表示前缀子串A[1-i]与B[1-j]的最长公共子序列的长度|\n| 阶段划分 | 空间特征，已经处理的前缀长两个字符串中的位置，即一个二维坐标 |\n| 转移方程  |$F[i,j]=\\begin{cases}F[i,j-1] \\\\ F[i-1,j] \\\\ F[i-1,j-1] + 1 & \\text{if } A[i] = B[j] \\end{cases}$|\n| 边界  | F[i,0]=F[0,j]=0|\n| 目标  | $F[N,M]$|\n\n|  数字三角形  | |\n|  ----  | ----  |\n| 问题描述   | 给定一个共有N行的三角矩阵A，其中第i行有i列。从左上角出发，每次可以向下方或者右下方走一步，最终到达底部。求把经过的所有位置上的数加起来，和最大是多少。|\n| 状态表示  |F[i,j]表示从左上角走到第i行，第j列，和最大是多少|\n| 阶段划分 | 空间特征，路径的结尾位置（矩阵中的行列位置），即一个二维坐标 |\n| 转移方程  |$F[i,j]=A[i,j]+\\begin{cases}F[i-1,j] \\\\ F[i-1,j-1] & \\text{if } j \\gt 1 \\end{cases}$|\n| 边界  | F[1,1]=A[1,1]|\n| 目标  | $\\underset{1 \\le j \\le N}{\\mathrm{max}}{F[N,j]}$|\n\n|  数字组合（01背包模型）  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   | $A_1,A_2,A_3,\\dots,A_N$，权重分别为$W_1,W_2,W_3,\\dots,W_N$|\n| 状态表示  |F[i,j]表示使用前i个数字拼凑出体积为j的物品的最大权重|\n| 阶段划分 | 主阶段：已经选择的数字，拼凑出的和是附加维度|\n| 转移方程  |$F[i,j]=max(F[i-1,j], F[i-1,j-A_i] + W_i)$ 第一项是不选择第i个数字，第二项是选择第i个数字|\n| 边界  | F[0,0]=1，其余为0|\n| 目标  | F[N,M]|\n| 空间优化  | 调整遍历顺序（V从大到小），确保可以用滚动数组，不会覆盖前值|\n| 相关题目  | 划分数组为两个相等的子集|\n\n|  数字组合（完全背包模型）  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   |$A_1,A_2,A_3,\\dots,A_N$，权重分别为$W_1,W_2,W_3,\\dots,W_N$|\n| 状态表示  |F[i,j]表示使用前i个数字拼凑出体积为j的物品的最大权重|\n| 阶段划分 | 主阶段：已经选择的数字，拼凑出的和是附加维度|\n| 【优化前】转移方程  |$F[i,j]=max{F[i,j- k * A_i] + k * W_i, k * A_i < V}$ 第一项是不选择第i个数字，第二项是选择第i个数字|\n| 【优化后】转移方程  |$F[i,j]=max(F[i-1,j], F[i,j-A_i])$ 第一项是不选择第i个数字，第二项是选择第i个数字|\n| 边界  | F[0,0]=1，其余为0|\n| 目标  | F[N,M]|\n| 空间优化  | 调整遍历顺序（V从小到大），确保可以用滚动数组，不会覆盖前值|\n\n|  数字组合（多重背包模型）  |背包问题系列 |\n|  ----  | ----  |\n| 问题描述   |$A_1,A_2,A_3,\\dots,A_N$，权重分别为$W_1,W_2,W_3,\\dots,W_N$，物品数量不超过$N_1,N_2,N_3,\\dots,N_N$|\n| 状态表示  |F[i,j]表示使用前i个数字拼凑出体积为j的物品的最大权重|\n| 阶段划分 | 主阶段：已经选择的数字，拼凑出的和是附加维度|\n| 【优化前】转移方程  |$F[i,j]=max{F[i,j- k * A_i] + k * W_i, k < N_i}$ 第一项是不选择第i个数字，第二项是选择第i个数字|\n| 【优化后】转移方程  |把$N_i$拆分为二进制，然后转换为01背包问题|\n| 边界  | F[0,0]=1，其余为0|\n| 目标  | F[N,M]|\n| 空间优化  | 调整遍历顺序（V从小到大），确保可以用滚动数组，不会覆盖前值|\n\n|  最少硬币数  |换硬币系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N种硬币，其中第i种面额为$C_i$，计算凑成总金额M所需的最少的硬币个数。每种硬币的数量是无限的。|\n| 状态表示  |F[i]表示凑出金额i用的最小硬币数|\n| 转移方程  |$F[i]=\\underset{1 \\le j \\le N}{\\mathrm{min}}{F[i - C_j] + 1}$|\n| 边界  | F[0]=0，其余为正无穷|\n| 目标  | F[M]|\n\n|  求硬币拼凑的总方案数  |换硬币系列 |\n|  ----  | ----  |\n| 问题描述   | 给定N种硬币，其中第i种面额为$C_i$，计算凑成总金额M的所有方案数|\n| 状态表示  |F[i,m]表示利用前i种硬币凑出金额m的方案数|\n| 转移方程  |$F[i]=\\sum\\limits_{j=1}^{N} {F[i - C_j]}$|\n| 边界  | F[0]=1，其余为0|\n| 目标  | F[M]|\n\n|  最大子数组  | |\n|  ----  | ----  |\n| 问题描述   |子数组和最大|\n| 状态表示  |F[i]表示利用以d[i]结尾的子数组的最大和|\n| 转移方程  |$F[i]= max(F[i-1] + A_i, A_i)$，其实等价于判断F[i-1]是否小于0|\n| 边界  | F[0]=1，其余为0|\n| 目标  | F[M]|\n| 相关题目  | 乘积最大连续子数组\\最大子矩阵：i~j列上的数字进行加和，然后二维转一维|\n| 相关题目  | 环形最大子数组：Copy一遍，长度*2，然后限制长度不超过n|\n| 相关题目  | 环形最大子数组：max(【跨末端】Sum - 最小子数组, 【原】最大子数组)|\n\n|  股票买卖  | |\n|  ----  | ----  |\n| 问题描述   | 交易K次 |\n| 状态表示  |F[Day, MaxTradeCnt, FullOrShort]表示利用前Day天，交易次数剩余MaxTradeCnt, 空仓满仓时能够获得的最大利润|\n| 转移方程  |$F[i,k,0]=max(F[i-1, k, 0], F[i-1,k,1] + prices[i])$|\n| 转移方程  |$F[i,k,1]=max(F[i-1, k, 1], F[i-1,k-1,0] - prices[i])$|\n| 边界  | F[0]=1，其余为0|\n| 目标  | F[M]|\n| 相关题目  | 交易一次，交易无限次，交易K次|\n\n|  字符串编辑距离问题  | |\n|  ----  | ----  |\n| 问题描述   |strA与strB变为一样所需要的最少操作次数|\n| 状态表示  | L(i,j)为使两个字符串和Ai和Bj相等的最小操作次数；Ai表示前i个字符|\n| 转移方程  |$L(i,j) = min( L(i-1,j-1), L(i-1,j), L(i,j-1) ) + 1$|\n\n|  最长回文串  | |\n|  ----  | ----  |\n| 问题描述   ||\n| 状态表示  |F[i][j] 表示 S[i] 至 S[j] 所表示的子串是否是回文子串|\n| 转移方程  |$F[i,j]=\\begin{cases}F[i+1,j-1] \\text{if } S_i = S_j \\\\ 0 & \\text{if } S_i \\ne S_j \\end{cases}$|\n\n|  正则匹配  | |\n|  ----  | ----  |\n| 问题描述   | |\n| 状态表示  ||\n| 转移方程  |见：https://leetcode.cn/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/|\n\n|  扔鸡蛋问题  | |\n|  ----  | ----  |\n| 问题描述   |dp[i,j]表示i层，j个鸡蛋，最坏情况下的最少扔鸡蛋次数|\n| 转移方程  |$dp(N,K)=\\underset{1 \\le i \\le N}{\\mathrm{min}}(1+max(dp(N-i,K), dp(i-1,K-1)))$|\n| 具体实现  |状态扭转特别复杂，用for循环有点困难，所以我们采用DFS + 记忆化搜索，时间复杂度：$O(N*N*K)$；上面方程中的i啥意思？他表示对于要探测的N层，有N种选择；我需要挨个去做**选择**，而不是在枚举**状态**；状态的枚举是通过DFS递归来实现的|\n| 二分搜索优化  |dp(N-i,K)与dp(i-1,k-1) 总是一个单调递增，一个单调递减；所以什么时候最小呢？所以两者的直线交点即为最小值；这种思路类似于峰谷问题，可以用二分解决！把时间复杂度将为$O(N * K * LgN)$|\n\n|  扔鸡蛋问题-进阶  | |\n|  ----  | ----  |\n| 问题描述   |F[i,j]表示最多允许i个鸡蛋，当前已经扔了j个，能确定的最高楼层数|\n| 转移方程  |$dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1$|\n\n## 动态规划相关的经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| 二维DP | [棋盘上获取最大价值的礼物](getMaxValue.html)  ||\n| 字符串DP | [获取不同的翻译方法次数](getTranslationCount.html)  ||\n| 二维DP | [求解一个矩阵中找一条最长的递增路径](long_path_in_2d_array.html)  ||\n| 二维DP | [骰子点数](num_of_slices.html)  ||\n| | [股票买卖系列](stock_common.html)  ||\n| | [子数组最大和](sub_array_sum_max.html)  |子数组最大和问题|\n\nhttps://zhuanlan.zhihu.com/p/410411231\n\n等差递减区间的个数【转斐波那契】","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"链表系列-分类汇总","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/index.html","content":"\n链表，作为一种最简单的数据组织方式，在平常工作中用处非常广泛。\n\n## 关于链表，你一定要知道的\n\n## 链表的常见技巧\n\n1. 链表中的哨兵节点\n2. 快慢指针\n3. 基于递归的反转问题\n\n```cpp\n//单链表 —— 模板题 AcWing 826. 单链表\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n\n//双链表 —— 模板题 AcWing 827. 双链表\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n```\n\n## 链表相关的经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [删除节点](delete_node.html)  |原地操作，该题并无普遍性|\n| | [复杂链表的复制](./copyRandomList.html)  |启发式思考，该题并无普遍性|\n| | [链表归并](../list_merge.html)  |归并排序|\n","tags":["链表"],"categories":["数据结构与算法","剑指Offer"]},{"title":"数组系列-分类汇总","url":"/backend_knowledge_architecture/structure_algorithm/structures/array/index.html","content":"\n数组，作为一种最简单的数据组织方式，在平常工作中用处非常广泛。\n\n## 关于数组你一定要知道的\n\n## 数组的常见技巧\n\n- 自Hash\n\n本质：把数组当作hash\n\n给出的数组中每个元素的范围都是 [1, n]，并且要求的空间复杂度是$O(1)$\n\n可以考虑：**原地修改数组**又叫**自Hash**，其本质上就是把数组当作hash\n\n修改方法：取反，总之需要有办法来识别打了标记的元素\n\n对元素打标记时，打的标记需尽量保存信息(对相反数取绝对值，就能够还原原始内容），不可影响问题的求解。\n\n- 原地交换\n\n还有另外一种技巧，我们称之为原地交换，其基本要求在于：\n\n每一个元素都需要有对应的坑位，如果我们在他对应的坑位上的话，就进行swap；如此往复\n\n1）检查某一个元素是否在他期望出现的位置上\n\n2）如果在了，就啥也不做\n\n3）如果不在，就与目标位置上的元素进行替换（替换之后，新的元素又不满足了，那我们就继续）\n\n## 数组相关的经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [缺失的第一个正数](firstMissingPositive.html)  |原地交换|\n| | [数组中重复的数据](duplicateInArray.html)  |原地交换)|\n| | [数组中重复的数据-无额外空间](duplicateInArrayNoSpace.html)  |二分查找|\n\n## Pattern: Cyclic Sort 循环排序\n\n参考：\nhttps://blog.csdn.net/weixin_43989102/article/details/111397072","categories":["数据结构与算法"]},{"title":"哈希系列-布隆过滤器","url":"/backend_knowledge_architecture/structure_algorithm/structures/hash/bloom_filter.html","content":"\n\nbloom Filter 布隆过滤器\nK个hash函数，当写入一个key的时候，设置H1(key), H2(key)...Hk(key)为1。当需要check key是否存在的时候，依次检测H1(key)...Hk(key)是否均为1，如果其中一个不为1，则表示key不存在；否则认为key存在。\n\n注意：有错误判断的可能性，所以仅仅适用于允许一定错误率的场景。\n\n应用：\n\n1. 爬虫程序url是否处理过\n2. 黑名单,垃圾邮件过滤\n3. 是否关注、判断用户关系（如果出现误判，顶多会多回源一次数据库）\n4. 【TODO，没看明白】Bloom filter在重复数据删除中的应用。主流的重复数据删除技术的基本原理是对文件进行定长或变长分块，然后利用hash函数计算数据块指纹，如果两个数据块指纹相同则认为是重复数据块（同样这里存在数据碰撞问题），只保存一个数据块副本即可，其他相同数据块使用该副本索引号表示，从而实现数据缩减存储空间并提高存储效率。\n","categories":["数据结构与算法"]},{"title":"哈希系列-概览","url":"/backend_knowledge_architecture/structure_algorithm/structures/hash/index.html","content":"\n### hash实现\n\n开放定址法：适合数据量小，装载因子小的场景\n\n拉链法：适合存储大对象、大数据量的散列表，更加灵活，有更多的优化策略\n\n```cpp\n一般哈希 —— 模板题 AcWing 840. 模拟散列表\n(1) 拉链法\n    int h[N], e[N], ne[N], idx;\n\n    // 向哈希表中插入一个数\n    void insert(int x)\n    {\n        int k = (x % N + N) % N;\n        e[idx] = x;\n        ne[idx] = h[k];\n        h[k] = idx ++ ;\n    }\n\n    // 在哈希表中查询某个数是否存在\n    bool find(int x)\n    {\n        int k = (x % N + N) % N;\n        for (int i = h[k]; i != -1; i = ne[i])\n            if (e[i] == x)\n                return true;\n\n        return false;\n    }\n\n(2) 开放寻址法\n    int h[N];\n\n    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\n    int find(int x)\n    {\n        int t = (x % N + N) % N;\n        while (h[t] != null && h[t] != x)\n        {\n            t ++ ;\n            if (t == N) t = 0;\n        }\n        return t;\n    }\n```\n\n### hash使用场景\n\n- RPC负载均衡\n- 数据分片，分布式存储，例如一致性hash\n\n#### 特殊hash\n\n1. 自hash， 用数组自身作为hash的container；\n2. 位图\n3. 布隆过滤器，多hash\n4. 地理坐标hash， geo hash，二维转一维。\n\n### 相关题目\n\n10亿url按照计数排序\n\n思路：\n\nhash统计次数，然后单机排序、或者多机器归并排序\n\n找出字符数组中只出现三次，且最早出现完三次的字符（eg：aabcbba输出b）\n\n思路：\n\nhashmap\n\n### 数据结构实现\n\nHashmap是用hash算法实现的，我们通过put一个key和value进行存储，用get（key）来获取，在传入key时，hashmap会根据key.hashCode（）计算出hash值存储到bucket里面，当发生hash值相同，也就是hash冲突时，会使用链表+红黑树存储相同的hash值的value，如果冲突少，就用链表，冲突多，就用红黑树\n\nHashmap扩容：\n\n·HashMap 初始化大小是 16 ，扩容因子默认0.75（可以指定初始化大小，和扩容因子）\n·存的对象*负载因子*0.75（默认）大于总量就要扩容，扩容是键值重新排布，重新对底层数组容量取余分布\n·JDK1.8之前是数组+链表结构、JDK1.8及之后是数组+链表+红黑树\n·HashMap集合可以存储null键和null值\n\n### java数据结构对比\n\nhashMap 数组 + 链表 （冲突链表过长时，转为红黑树）线程不安全 允许null\\null  不可以有序遍历\n\nhashTable 线程安全，通过synchronized 不允许null\\null  不可以有序遍历\n\ntreeMap 红黑树 线程不安全 可以有序遍历\n\n","categories":["数据结构与算法"]},{"title":"位运算系列-比特位计数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/bit/bit_dp.html","content":"\n## 比特位计数 - 题目描述\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n## 比特位计数 - 代码实现\n\n```cpp\nclass Solution {\npublic:\n    /*\n    int lowbit(int n) {\n        return n & (~n);\n    }\n    */\n    vector<int> countBits(int num) {\n        vector<int> dp(num + 1);\n        for (int i = 1; i <= num; ++i) {\n            dp[i] = dp[i & i - 1] + 1; //每次n&n-1会抹掉最后一个1\n        }\n\n        return dp;\n    }\n};\n```\n","tags":["位运算"],"categories":["数据结构与算法"]},{"title":"本地交换系列-缺失的第一个正数","url":"/backend_knowledge_architecture/structure_algorithm/structures/array/firstMissingPositive.html","content":"\n## 缺失的第一个正数 - 题目描述\n\n给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。\n\n## 缺失的第一个正数 - 总体思路\n\n本地交换法不太容易想到，所以该题目定级为困难。题目让我们找缺失的第一个正数？\n\n我们不妨做一下**逆向思考**，假设一个正数都不缺失呢？我们会得到什么？ 一般情况下，我们的元素下标与元素的值会一一对应，从1到N。\n\n所以，我们考虑尝试着把一个元素i都找到他对应的位置i上，如果位置i被占了，我也强制把位置i的元素移走，重复整个过程。\n\n## 缺失的第一个正数 - 代码实现\n\n```cpp\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        //1~N\n        //一定可以为i找到一个合适的坑；\n       for (int i = 1; i <= n; ++i) {\n           int x = nums[i - 1];\n            while (x >= 1 && x <= n && x != nums[x - 1]) {\n                swap(nums[x - 1], nums[i - 1]);\n                x = nums[i - 1];\n            }\n       }\n\n       for (int i = 1; i <= n; ++i) {\n           if (nums[i - 1] != i) {\n               return i;\n           }\n       }\n\n       return n + 1;\n    }\n};\n```\n","tags":["本地交换"],"categories":["数据结构与算法"]},{"title":"链表反转系列-m到n链表反转","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/reverse/reverse_m_n.html","content":"\n\n逆序第m～n个元素\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* successor;\n\n    //非递归实现\n    ListNode* reverseN(ListNode* head, int n) {\n        ListNode* pre = NULL;\n        auto cur = head;\n        while (cur && n > 0) {\n            auto next = cur->next; //记录下一个cur\n            cur->next = pre; //核心步骤---操作cur的next指针，让其指向pre；\n            pre = cur;  //记录前一个\n            cur = next; //给下一个cur赋值\n            n--;\n        }\n\n        head->next = cur;\n        return pre;\n    }\n\n    ListNode* reverseN(ListNode* head, int n) {\n        if (!head) return head;\n        //base \n        if (n == 1) {\n            successor = head->next; //这一步特别关键，记录当前元素的后继节点，则外面会使用。\n            return head;\n        }\n\n        //子问题-下一个节点\n        auto x = reverseN(head->next, n - 1);\n        //head->next 是递归之前的头，也就是递归之后的尾巴\n        (head->next)->next = head;\n        head->next = successor;\n        return x;\n    }\n\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        //base\n        if (m == 1) {\n            return reverseN(head, n);\n        }\n\n        auto x = reverseBetween(head->next, m - 1, n - 1);\n        head->next = x;\n        return head; //返回的是头\n    }\n};\n\n```\n","tags":["链表反转"],"categories":["数据结构与算法"]},{"title":"链表反转系列- 每K个一组链表反转","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/reverse/reverse_per_k.html","content":"\n\n每K个反转一次，剩余不到k个，不用反转。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverse(ListNode* head, ListNode* tail) {\n        if (head == tail) return head;\n\n        auto x = reverse(head->next, tail);\n        head->next->next = head;\n        head->next = NULL;\n        return tail;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (!head) return head;\n\n        auto p = head;\n        ListNode* pre = NULL;\n        for (int i = 0; i < k; ++i) { \n            //base 不足k个\n            if (!p) return head;\n            pre = p;\n            p = p->next;\n        }\n\n        //反转\n        reverse(head, pre);\n\n        auto x = reverseKGroup(p, k);\n        head->next = x;\n        return pre;\n    }\n};\n```\n","tags":["链表反转"],"categories":["数据结构与算法"]},{"title":"单调队列系列-支持最大值的队列","url":"/backend_knowledge_architecture/structure_algorithm/structures/queue/mono_queue/queue_with_max.html","content":"\n## 支持最大值的队列 - 题目描述\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1\n\n1 <= push_back,pop_front,max_value的总操作数 <= 10000\n\n1 <= value <= 10^5\n\n## 支持最大值的队列-实现思路\n\n首先，默写下普通队列的模版：\n\n```cpp\nint q[N];\nint hh = 0;\nint tt = -1;\n//push\nq[++tt] = x;\n//pop\nq[hh++];\n//is empty\nhh > tt;\n```\n\n其次，默写下单调队列的模版：\n\n```cpp\n    for (int i = 0; i < n; ++i) {\n        while (tt >= hh && check_out(q[hh])) hh++; //判断是否滑出窗口\n        while (tt >= hh && check(q[tt])) tt--;\n        q[++tt] = i;\n    }\n```\n\n最后为什么会想到单调队列？\n\n一句话：如果一个后入队的元素比我还大，那么我永无出头之日！\n\n## 支持最大值的队列-代码实现\n\n```cpp\n class MaxQueue {\npublic:\n    MaxQueue() {\n        memset(q, 0, sizeof(q));\n        hh = 0;\n        tt = -1;\n    }\n    \n    int max_value() {\n        if (dq.size()) return q[dq.front()];\n        else return -1;\n    }\n    \n    void push_back(int value) {\n        q[++tt] = value;\n        //if (dq.size() && value >= q[dq.front()]) dq.clear();\n        while (dq.size() && value > q[dq.back()]) dq.pop_back();\n        dq.push_back(tt);\n    }\n    \n    int pop_front() {\n       if (tt < hh) return -1;\n\n       //当前的hh\n       if (dq.size() && dq.front() == hh) {\n           dq.pop_front();\n       }\n\n       return q[hh++];\n    }\n\nprivate:\n    int q[10010];\n    int hh; //队头\n    int tt; //队尾\n    std::deque<int> dq;\n};\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj = new MaxQueue();\n * int param_1 = obj->max_value();\n * obj->push_back(value);\n * int param_3 = obj->pop_front();\n */\n```\n","tags":["队列","单调队列"],"categories":["数据结构与算法"]},{"title":"计算机解决问题的通用套路","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/search/problem_solve.html","content":"\n## 什么是熵？(Entropy)\n\n熵，代表了一个系统的混乱程度。一个系统越混乱，其熵越大。一个封闭系统的熵随着时间推移，会一直变大，且不可逆。\n\n![熵增定律](http://cdn.b5mang.com/202118134321.png)\n\n## 什么是信息熵？(Information Entropy)\n\n一条信息的信息量大小和它的不确定性有直接的关系。不确定性越大，其信息量越大。我们用信息熵被用来计算信息量，其计算公式如下：\nH(x) = -∑p(xi)log(p(xi)) (i=1,2,..n)    （其中p(x)是x事件出现的概率），信息熵的单位是bit。\n\n获得了新的信息后，不确定性减少，信息熵降低。\n\n## 问题的解空间与信息熵的关系\n\n这里提一个很重要的概念：问题的解空间。什么是问题的解空间呢？所有可能成为问题最优解的解所构成的空间。问题的解空间越大，不确定性就越大，问题就“越混乱”，熵也就越高。\n\n计算机求解问题的过程是怎样的呢？计算机算法在执行的过程中，获取更多信息，将要解决的问题的信息熵减小，直到减到0，该问题就被解决了。\n\n每一个问题都有一个固有的初始信息熵，这个初始信息熵的大小也就决定了这个问题的复杂程度。例如，N皇后这个问题就比“从N个数中找到最大值”问题更难，因为前者的解空间更大，有更多的可能性。\n\n![问题的信息熵与其解空间大小的关系](http://cdn.b5mang.com/2021181698.png)\n\n不同的算法为什么执行时间差别那么大？\n\n![算法执行时间与信息熵的关系](http://cdn.b5mang.com/202118164152.png)\n\n同一个问题，有不同的解法，也就会产生不同的解空间。\n\n一开始的时候，要解决的问题信息熵很大，不确定性就越大。从信息熵的角度来看，就是把这个问题的熵将为0的过程。\n什么是问题的求解呢？\n计算机算法是如何获取新的信息的呢？ 信息获取的越快，\n举个例子，从N个数中找到某一个数这个问题。一开始这个问题有N种可能性，\n搜索空间就是你算法的自变量构成的空间，而求解问题的解空间是你问题的解构成的空间。所以当你算法的自变量范围和求解问题的解范围相同时，这两个空间就是相同的。但是在很多时候，它们并不相同。这是因为求解的问题往往存在约束。大多数情况下，我们在处理约束时，都是采用惩罚函数的方式。这相当于我们把求解问题对解的约束放在了目标函数上。由此，变相地放大了自变量的空间，也就是算法的搜索空间。\n\n让我们结合几个例子来\n\n## 常见问题的解空间有多大\n\n子集问题\n$2^k$\n\n组合问题\n\n排列问题\nn!\n\n参考文章：\nhttps://stonema.github.io/2018/03/27/大话交叉熵/\n\n一条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。相反，如果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的多少。（摘自数学之美）\n\n香浓指出的信息熵的计算公式如下（本文的对数一律以2为准）\n\nH(x) = -∑p(xi)log(p(xi)) (i=1,2,..n)    （其中p(x)是x事件出现的概率）单位为bit\n算法时间复杂度，与信息熵\n\n数学之美里是用赛后怎么知道32个球队里谁是冠军来讲解了这个信息熵的概念。\n\n当概率相等时，每次询问用折半查找的原理（如“冠军队伍在1-16吗？”）可以减少一半的队伍，这样就需要5次就能知道结果了。这里就是log32 = 5\n\n而使用信息熵计算信息量，的确也是5。但是为什么信息熵这个公式会代表信息量呢\n\n按我的理解，在等概率事件里，1/p(x) 代表那一次所有可能出现的量、在球队问题里，就是32种可能性。\n\n而等概率事件里，因∑p（xi） = 1，所以信息熵可以看成\n\n信息熵H(x)= -∑p(xi)log(p(xi)) (i=1,2,..n) = -log(p(i)) = -（- log（1/p(x)））= log（1/p(x)）\n\n也就是说等概率事件里的信息量可以看成\n\nH（x）= log（所有可能性）\n\n为了加深对信息量的定义的理解，再回到上述32个球队的问题，我们已经知道他的信息量是5Bit\n\n问过一次之后，我们可以知道冠军在哪16个队伍中，也就是说我们获得了1bit的信息后不确定性减少，等于信息熵变成了log16 = 4bit =5bit -1bit\n\n而最大熵模型呢？它的原理就是保留全部的不确定性，将风险降到最少。\n\n最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主观假设这点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常说，“不要把所有的鸡蛋放在一个篮子里”，其实就是最大熵原理的一个朴素的说法，因为当我们遇到不确定性时，就要保留各种可能性。\n\n也就是说发现不确定信息的时候，不要对不确定的产物任何主观假设使他们的概率分布均匀，则能获得最客观的结果。而这时风险会最小，我们就可以用这个结果来进行最客观的决策。数学上来说貌似就是最优下界吧。这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。（摘自mindhacks快排为什么那么快）\n\n我再用算法的时间复杂度说明一下最大熵原理吧，用几个主流的算法对n个数据进行排序时间复杂度基本上都是从O（nlogn）到O（n2）。而一般情况下为什么O（nlogn）最优呢，因为n个数据的先后顺序是随机的，我们可以看做不确定性相等，则可以用最大熵原理获得最优(最稳定)结果。则信息熵则为\n\nH(x)= log（所有可能性）= log（n！） 而n—>00 则log（n！）近似于lognn= nlogn\n\n假设我们每次能获得1bit数据，就至少需要获得（nlogn）bit数据才能取消信息的不确定性，也就是要比较nlogn次。但因为各种排序算法策略不同，我们不可能每次都能获得1bit数据，所以按照信息熵的定义这是理论上最优的结果。而最佳的排序算法就是要每次获得1bit数据，越接近于1则越有效。\n\n而TopLanguage那个帖子里也说了，虽然快排和堆排序两个是都是时间复杂度O（nlogn）的算法,但是快速排序一般都会比堆排序快，就是因为堆排序每次获取的平均信息量比快排来的低。\n\n而上面，我们根本没提到具体算法，就算到了最优的时间复杂度。在实际生活中很多时候我们虽然不会想到具体的策略，但我们至少可以知道极限在哪里，可以知道还有没有提高余地。任何排序和猜数字的算法可以理解为通过获得信息量去消减原来的熵。（这句摘自eric的话）\n\n什么叫状态空间树？\n\n就是问题的解空间树，分为子集树和排列树\n\n当所给的问题是从n个元素的集合S中找到S满足某种性质的子集时，相应的解空间树称为子集树。\n\n当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。\n\n子集树和排列树的不同是每一步的选择策略不同。子集树每一步对应的是对应的元素的选择或不选择，排列树每一步对应的是剩下的元素选择其中一个。一个的可搜索的解为2**n，一个为n！，因此，一个高效的回溯法算法必须依赖于剪枝函数来避免无效搜索。\n\n面对许多实际问题时，需要求解满足特定条件的全部解或最优解，如著名的N皇后问题和旅行售货员问题。\n此类问题，一般没有特定的计算规则用于解题，通常我们采用试探性的方法，在包含问题所有可能解的解空间树中，将所有可能的结果搜索一遍，从而获得我们期望的那一个解，或者是那一些解，一般就是满足一定条件的最优解，或是全部解。那么这里用到的解空间树是什么呢？\n\n解空间树：\n依据待解问题的特性，用树结构表示问题的解结构，用叶子表示所有问题所有可能解的一棵树。\n\n解空间树的建立：\n就是将问题求解的一系列判断决策过程及各种可能的结果用树型结构呈现。\n事实上，我们解题的过程是一个不断判断决策的过程，我们把每一步判断决策的过程对应于解空间树的一个分支结点，而各种可能的不同结果，则对应得到结点的每一个孩子及各棵子树，而一系列判断决策的解题过程，就对应着解空间树的生长过程；而问题最终所有可能的解，都会呈现在这棵解空间树的叶子上。\n\n让我们先思考下我们之前做过的算法题都有哪些种类？\n\n解空间树T\n\n回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。\n\n发现当考虑了所有的操作时，还要对操作所得状态进行判断，是否已出现过，来避免重复搜索。这道题我纠结了好久，就是因为我想通过限制操作来避免出现重复状态，而出现重复状态的情况有很多，很难考虑全面。其实判断状态是否重复我之前也都做过，就是在搜索迷宫的过程中，操作就是移动的方向，而状态就是位置，为了避免重复搜索就在地图上做标记，当时这样做的时候觉得顺理成章，不过在这题里，却并没有能直接这样做。\n总结下，在搜索整个解空间时，首先是考虑所有的 操作，然后通过保存已出现 状态，来防止重复搜索。如果很容易通过对操作进行限制来防止状态的重复出现，或是保存状态所需的内存空间过大的话，那就不宜保存状态。\n\n a computational problem is a problem that a computer might be able to solve or a question that a computer may be able to answer.\n A computational problem can be viewed as an infinite collection of instances together with a, possibly empty, set of solutions for every instance. For example, in the factoring problem, the instances are the integers n, and solutions are prime numbers p that describe nontrivial prime factors of n.\n\nA **decision problem** is a computational problem where the answer for every instance is either yes or no.\n\nIn a **search problem**, the answers can be arbitrary strings. For example, factoring is a search problem where the instances are (string representations of) positive integers and the solutions are (string representations of) collections of primes.\n\n决策问题，给定一个正整数n，确定n是否是素数。\n\n搜索问题，找到一个正整数的所有非朴素因子。\n\nA counting problem asks for the number of solutions to a given search problem. For example, a counting problem associated with factoring is\n\n\"Given a positive integer n, count the number of nontrivial prime factors of n.\"\n\nAn **optimization problem** asks for finding a \"best possible\" solution among the set of all possible solutions to a search problem.\n\n求这n个实数在数轴上相邻2个数之间的最大差值，\n\nIn a **function problem** a single output (of a total function) is expected for every input, but the output is more complex than that of a decision problem, that is, it isn't just \"yes\" or \"no\". One of the most famous examples is the traveling salesman problem:\n\n\"Given a list of cities and the distances between each pair of cities, find the shortest possible route that visits each city exactly once and returns to the origin city.\"\nIt is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science.\n\n![function problem](http://cdn.b5mang.com/202117132959.png)\n\n我们要解决一个\n\n当不确定性降到了0，问题就解决了。\n\n信息：\n\n熵：\n\n高熵特征，低熵特征\n\n熵增定律\n\n多做一步的目的是为了减少更多的不确定性。\n","tags":["回溯"]},{"title":"一题目多解系列-柱状图中最大的矩形","url":"/backend_knowledge_architecture/structure_algorithm/problem/max_rectangle.html","content":"\n## 柱状图中最大的矩形 - 题目描述\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n## 柱状图中最大的矩形-一从暴力开始\n\n首先，思考一下问题的解空间有多大（也就是说有多少种选择），显然一个开始位置、一个结束位置，所以我们可以得到暴力解法的思路：\n（1）双层循环确定开始结束位置，也就是矩阵的长\n（2）从开始到结束扫描一遍，找到最小值，也就是矩阵的宽\n（3）长乘宽得到面积，与答案比较，并更新答案\n\n## 柱状图中最大的矩形-一暴力扫描代码实现\n\n```cpp\nint largestRectangleArea(vector<int>& heights) {\n    int n = height.size();\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; j++) {\n            int minv = INF;\n            for (int k = i; k <= j; ++k) {\n                minv = min(minv, height[k]);\n            }\n            res = max(res, (i - j + 1) * minv);\n        }\n    }\n    return res;\n}\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> s(heights.size() + 2);\n        vector<int> w(heights.size() + 2);\n        int p = 0;\n\n        heights.push_back(0);\n        int res = 0;\n        for (int i = 0; i < heights.size(); ++i) {\n            if (heights[i] > s[p]) {\n                s[++p] = heights[i];\n                w[p] = 1;\n            }\n            else {\n                int width= 0;\n                while (s[p] > heights[i]) {\n                    width += w[p];\n                    res = max(res, width * s[p]);\n                    p--;\n                }\n                s[++p] = heights[i];\n                w[p] = width + 1;\n            }\n        }\n        return res;\n    }\n};vf\n\npublic class Solution {\n    public int calculateArea(int[] heights, int start, int end) {\n        if (start > end)\n            return 0;\n        int minindex = start;\n        for (int i = start; i <= end; i++)\n            if (heights[minindex] > heights[i])\n                minindex = i;\n        return Math.max(heights[minindex] * (end - start + 1), Math.max(calculateArea(heights, start, minindex - 1), calculateArea(heights, minindex + 1, end)));\n    }\n    public int largestRectangleArea(int[] heights) {\n        return calculateArea(heights, 0, heights.length - 1);\n    }\n}\n\nint largestRectangleArea(vector<int>& heights) {\n    int n = height.size();\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        int minv = height[i];\n        for (int j = i; j < n; j++) { //确保j从小变大\n            int minv = INF;\n            //如果i看作一个定值，下面这个循环，其实每次都做了相同的工作，重复扫描[i, j]\n            //所以可以做累计处理\n            //for (int k = i; k <= j; ++k) {\n            //    minv = min(minv, height[k]);\n            //}\n            minv = min(minv, height[j]);\n            res = max(res, (i - j + 1) * minv);\n        }\n    }\n    return res;\n}\n\n```\n\n时间复杂度：$O(n^3)$ => $O(n^2)$\n空间复杂度：$O(1)$\n\n## 柱状图中最大的矩形-进一步思考\n\n还有一种解法，一种**更有智慧**的解法，不像前面的暴力解法那么粗暴，让我们先考虑下哪些肯定不会成为答案。\n如果一个格子往两边延伸，一直延伸到有比它更低的格子为止。\n![柱状图中最大的矩形-分治法](http://cdn.b5mang.com/202115224849.png)\n如果备选答案覆盖了矩形A，那么备选答案的宽度一定会延伸到绿色矩形这里。\n\n假设有N个像上面的这种备选答案，那么最终答案一定是出自这N个备选答案。\n\n为什么我们这么考虑呢？ 因为这样子考虑的话，有利于我们分解子问题。\n\n## 柱状图中最大的矩形-空间换时间版\n\n```cpp\nint dfs(vector<int>& height, int l, int r) {\n    int p = find_min(height, l, r);\n\n    int left_lower = 0； //往左查找，直到找到比height[p]更小的元素\n    int right_lower = 0；//往右查找，直到找到比height[p]更小的元素\n\n    return max(dfs(l, p - 1), dfs(p + 1, r), height[p] * (right_lower - left_lower);\n}\n\nint largestRectangleArea(vector<int>& height) {\n  return dfs(height, 0, height.size() - 1);\n}\n```\n\n递推公式：$T(n) = 2*T(n/2) + O(n)$\n时间复杂度：$O(nlgn)$\n空间复杂度：$O(1)$\n\n\n## 单调栈解法\n\n找右边，比我小的（利用递增栈）；找到了，就可以计算候选了。\n\n左边的都比我小，left确定了；\n\n新来的，比我小，right也确定了； 所以面积就确定了！\n","tags":["单调栈","一题多解"],"categories":["数据结构与算法"]},{"title":"一题目多解系列-丢失的数字","url":"/backend_knowledge_architecture/structure_algorithm/problem/missing_num_0_n.html","content":"\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n可能的解法：\n\n1. hash\n2. xor 位运算\n3. 推公式，高斯公式\n\n具体参考：https://blog.csdn.net/Sruggle/article/details/113789086\n","tags":["单调栈","一题多解"],"categories":["数据结构与算法"]},{"title":"一题目多解系列-盛水最多的容器","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/max_container.html","content":"\n给定一个数组height，长度为n，每个数代表坐标轴中的一个点的高度，height[i]是在第i点的高度，请问，从中选2个高度与x轴组成的容器最多能容纳多少水\n1.你不能倾斜容器\n2.当n小于2时，视为不能形成容器，请返回0\n3.数据保证能容纳最多的水不会超过整形范围，即不会超过2^31-1\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int res = 0;\n        int i = 0, j = height.size() - 1;\n        int lmax = 0, rmax = 0;\n        while (i < j) {\n            lmax = max(lmax, height[i]);\n            rmax = max(rmax, height[j]);\n            res = max(res, min(lmax, rmax) * (j - i));\n            if (lmax < rmax) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n\n        return res;\n    }\n};\n```\n","tags":["一题多解","双指针"],"categories":["数据结构与算法"]},{"title":"一题目多解系列-接雨水问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/rain_trap.html","content":"\n## 接雨水问题 - 题目描述\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n示例:\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n\n## 接雨水问题-一开始的思路\n\n经典解法包括：\n（1）单调栈，左右遇到的最大值\n（2）双指针\n\n首先，也是最重要的，先把题目搞清楚（好多时候解不出题是由于题目没有完全理解、没有理解完全或者完全没有理解）。\n按照题意，一个格子能够接的水，取决于该格子向前、向后遇到的最大值，两个最大值取最小值；而我之前曾经按照往前、往后遇到的比该格子高的格子来算了。\n\n其次，让我们考虑最暴力的做法是什么？暴力扫描。\n\n## 接雨水问题-一暴力扫描代码实现\n\n```cpp\nint trap(vector<int>& height) {\n    int n = height.size();\n    int res = 0;\n    for (int i = 1; i < n; ++i) {\n\n        //往左找到最大值\n        int lmax = 0;\n        for (int j = 0; j < i; ++j) {\n            lmax = max(lmax, height[j]);\n        }\n\n        //往右找到最大值\n        int rmax = 0;\n        for (int j = i + 1; j < i; ++j) {\n            rmax = max(rmax, height[j]);\n        }\n\n        res += min(rmax, lmax) - height[i];\n\n    }\n}\n```\n\n时间复杂度：$O(n^2)$\n空间复杂度：$O(1)$\n\n## 接雨水问题-进一步思考\n\n观察上面的代码，有很多重复计算，例如计算i左边的最大值时，扫描范围是[0, i - 1];当计算i+1左边的最大值时，扫描范围是[0, i]，显然是完全包含[0, i - 1]的，\n对于重复计算，我们继续采用空间换时间的套路，用数组lmax[i]来存储[0, i - 1]的最大值；这样子存储之后，如果再计算lmax[i + 1]只要拿lmax[i]跟height[i + 1]比较即可。\n\n## 接雨水问题-空间换时间版\n\n```cpp\nint trap(vector<int>& height) {\n    int n = height.size();\n    int res = 0;\n    int lmax[N], rmax[N];\n    //正序遍历\n    for (int i = 1; i < n; ++i) {\n        lmax[i] = max(lmax[i - 1], height[i - 1]);\n    }\n\n    //倒序遍历 \n    for (int i = n; i >= 0; --i) {\n        rmax[i] = max(rmax[i + 1], height[i + 1]);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        res += min(lmax[i], rmax[i]) - height[i];\n    }\n}\n```\n\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$\n\n## 接雨水问题-能不能把空间复杂度优化掉？\n\n其实，上面的时间复杂度已经是最优了，有没有可能把空间也优化掉呢？我们注意到lmax[i]仅跟lmin[i-1]有关系，这个对于我们做空间压缩是很好的；\n剩下的就是，我们能不能把lmax,rmax立即用上，而不需要存起来呢？答案是可以的。我们可以把上面的循环写在一起，用i、j两个指针分别指向左右两个端点，在遍历的过程中，直接把前面出的lmax, rmax立即用上。\n\n## 接雨水问题-双指针优化版\n\n```cpp\nint trap(vector<int>& height) {\n    int n = height.size();\n    int res = 0;\n    int lmax, rmax;\n    int i = 1, j = n - 2;\n\n    while (i < j) {\n        lmax = max(lmax, height[i - 1]);\n        rmax = max(rmax, height[j + 1]);\n        if (lmax < rmax) {\n            res += lmax - height[i];\n            i++;\n        }\n        else {\n            res += rmax - height[j];\n            j--;\n        }\n    }\n    return res;\n}\n```\n\n```cpp\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int lmax = 0, rmax = 0;\n        int l = 0, r = height.size() - 1;\n        int sum = 0;\n\n        while (l <= r) {\n            for (; l <= r && (lmax = max(height[l], lmax)) <= rmax; ++l) {\n                sum += lmax - height[l];\n            }\n            for (; r >= l && (rmax = max(height[r], rmax)) <= lmax; r--) {\n                sum += rmax - height[r];\n            }\n        } \n\n        return sum;\n    }\n};\n\n```\n\n时间复杂度：$O(n)$\n空间复杂度：$O(1)$\n\n单调栈解法\n\n```cpp\n\nclass Solution {\npublic:\n    /**\n     * max water\n     * @param arr int整型vector the array\n     * @return long长整型\n     */\n    long long maxWater(vector<int>& arr) {\n        stack<int> s;\n        s.push(-1);\n        int res = 0;\n        for (int i = 0; i < arr.size(); ++i) {\n            while (s.top() != -1 && arr[s.top()] < arr[i]) {\n                int cur = s.top(); //当前计算的格子\n                s.pop();\n                int left = s.top();\n                if (left >= 0) {\n                    res += (min(arr[left], arr[i]) - arr[cur]) * (i - left - 1);\n                    //cout << \"i:\" << i << \", cur:\"  << cur << \", res: \" << res << endl;\n                }\n            }\n\n            s.push(i);\n        }\n\n        return res;\n    }\n};\n\n```","tags":["一题多解","双指针"],"categories":["数据结构与算法"]},{"title":"前缀和系列-概览","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/prefix_sum/index.html","content":"\n前缀和和差分，通过空间来换时间，一般用来优化时间复杂度，从$O(n^2)$到$O(n)$\n\n//一维前缀和 —— 模板题 AcWing 795. 前缀和\n\n```cpp\nint prefix_sum() {\n    S[i] = a[1] + a[2] + ... a[i];\n    a[l] + ... + a[r] = S[r] - S[l - 1];\n}\n```\n\n//二维前缀和 —— 模板题 AcWing 796. 子矩阵的和\n\n```cpp\nint 2d_preifx_sum()\n{\n    S[i, j] = 第i行j列格子左上部分所有元素的和\n    //以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\n    S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n}\n```\n\n//一维差分 —— 模板题 AcWing 797. 差分\n给区间[l, r]中的每个数加上c：\n\n```cpp\nB[l] += c, B[r + 1] -= c\n```\n\n//二维差分 —— 模板题 AcWing 798. 差分矩阵\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\n\n```cpp\nS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n```\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n|前缀和系列| [不使用除法的特殊累乘](../multiply_no_div.html)  |前缀和、定序技巧|\n","tags":["前缀和"],"categories":["数据结构与算法"]},{"title":"滑动窗口系列-概览","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/sliding_wind/index.html","content":"\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [最长无重复字串](../longestSubstringWithoutDuplication.html)  |滑动窗口、字符串类|\n\n```cpp\n//滑动窗口 模版\nfor (int i = 0, j = 0; i < n; i ++ )\n{\n    //i是新进入窗口的元素\n    //[j,i]是窗口边缘，j是要滑出的下标，i是新进入的下标\n    while (j < i && check(i, j)) j ++ ; //j是可能要滑出窗口的元素\n\n    // 具体问题的逻辑\n}\n```\n","tags":["滑动窗口"],"categories":["数据结构与算法"]},{"title":"滑动窗口系列-最长无重复字串","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/sliding_wind/longestSubstringWithoutDuplication.html","content":"\n## 最长无重复字串 - 题目描述\n\n请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n\n假设字符串中只包含从’a’到’z’的字符。\n\n样例\n输入：\"abcabc\"\n\n输出：3\n\n## 最长无重复字串-实现思路\n\n首先，默写下滑动窗口的模版：\n\n```cpp\nint i = 0, j = 0, n;\nwhile (i < n) {\n    //对新进入窗口的元素i进行处理\n\n    while (j < i && check(xx)) {\n        //对出窗口的元素j进行处理\n        j++;\n    }\n}\n```\n\n其次，搞清楚滑动窗口是用来做什么的以及用什么数据结构来维护\n\n很明显，我们需要使用滑动窗口来存储每一个字母的出现次数，并且在**当前窗口内的字母不重复**；数据结构的话，hashmap即可\n\n## 最长无重复字串-代码实现\n\n```cpp\n int longestSubstringWithoutDuplication(string s) {\n       int i, j = 0, n =s.size();\n       unordered_map<char,int> counter;\n       int res = 0;\n       while (i < n) {\n           char c = s[i];\n           counter[c]++;\n           if (counter[c] == 1) { //新来了一个不重复元素，则窗口扩大了\n                res = max(res, i - j + 1)\n           }\n           i++;\n           while (j < i && counter[c] > 1) { //如果现在窗口已经不在符合条件，则一直往前移动left，直到窗口重新满足\n               counter[s[j]]--;\n               j++;\n           }\n       }\n    }\n```\n\n```cpp\nclass Solution {\npublic:\n    int maxLength(vector<int>& arr) {\n        unordered_map<int, int> counter;\n\n        int i = 0, j = 0, res = 0;\n        while (j < arr.size()) {\n            counter[arr[j]]++;\n            while (counter[arr[j]] > 1) {\n                counter[arr[i++]]--;\n            }\n\n            res = max(j - i + 1, res);\n            j++;\n        }\n\n        return res;\n    }\n};\n```\n","tags":["滑动窗口"],"categories":["数据结构与算法"]},{"title":"滑动窗口系列-最短覆盖子串","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/sliding_wind/shortest_cover_substr.html","content":"\n```cpp\n\nclass Solution {\npublic:\n    unordered_map<char, int> pattern;\n\n    string minWindow(string src, string tt) {\n        //将目标串转换为方便检查处理的hashmap\n        for (auto x : tt) {\n            pattern[x]++;\n        }\n        int cnt = pattern.size();\n\n        string res;\n        for (int i = 0, j = 0, c = 0; i < src.size(); ++i) {\n            if (pattern[src[i]] == 1 ) c++;\n            pattern[src[i]]--; //将src[i]标记为缺少状态\n            //满足了，并且某一个字符是缺的【非pattern中的字符一定缺；并且一定会被补上】，则往前移动\n            while (c == cnt && pattern[src[j]] < 0) {\n                pattern[src[j++]]++; \n            } \n            if (c == cnt) {\n                if (res.empty() || res.size() > i - j + 1) res = src.substr(j, i - j + 1);\n            }\n        }\n        return res;\n    }\n};\n```","tags":["滑动窗口"],"categories":["数据结构与算法"]},{"title":"链表系列-有序链表合并","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/list_merge.html","content":"\n## 有序链表合并-题目描述\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n样例\n输入：1->3->5 , 2->4->5\n\n输出：1->2->3->4->5->5\n\n<!-- more -->\n\n## 二叉树子结构-总体思路\n\n考察点：链表上的归并排序\n\n## 二叉树子结构-代码实现\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* merge(ListNode* l1, ListNode* l2) {\n        //dummy是一个哨兵节点，用来简化后续的判定是否为空逻辑\n        auto dummy = new ListNode(-1);\n        auto tail = dummy;\n        while (l1 && l2){\n            if (l1->val <= l2->val) {\n                tail = tail->next = new ListNode(l1->val); //追加一个新的node\n                l1 = l1->next; //往后移动一个元素\n            }\n            else {\n                tail = tail->next = new ListNode(l2->val);\n                l2 = l2->next;\n            }\n        }\n        \n        //遍历剩下\n        while (l1) {\n            tail = tail->next = new ListNode(l1->val);\n            l1 = l1->next;\n        }\n        while (l2) {\n            tail = tail->next = new ListNode(l2->val);\n            l2 = l2->next;\n        }\n        \n        return dummy->next;\n    }  \n};\n```\n","tags":["链表","归并排序"],"categories":["数据结构与算法","剑指Offer"]},{"title":"数组系列-奇偶重排","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/reOrderArray.html","content":"\n## 奇偶重排-题目描述\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序。\n\n使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。\n\n样例\n输入：[1,2,3,4,5]\n\n输出: [1,3,5,2,4]\n\n<!-- more -->\n\n## 奇偶重排-总体思路\n\n考察点：快速排序思想，双指针（对碰指针技巧）\n\n## 奇偶重排-代码实现\n\n```cpp\nclass Solution {\npublic:\n    void reOrderArray(vector<int> &nums) {\n         int i = 0; \n         int j = nums.size() - 1;\n         while (i < j) {\n             while (i < j && (!(nums[j] & 1))) {j--;}\n             while (i < j && (nums[i] & 1)) {i++;}\n  \n             if (i < j) {\n                 swap(nums[i], nums[j]);\n             }\n         }\n    }\n};\n\n```\n","tags":["双指针","快速排序"],"categories":["数据结构与算法","剑指Offer"]},{"title":"链表系列-链表反转","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/reverse/reverseList.html","content":"\n## 链表反转-题目描述\n\n定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。\n\n思考题：\n\n请同时实现迭代版本和递归版本。\n样例\n输入:1->2->3->4->5->NULL\n\n输出:5->4->3->2->1->NULL\n\n<!-- more -->\n\n## 链表反转-总体思路\n\n## 链表反转-非递归版代码实现\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n\n    ListNode* reverseList(ListNode* head) {\n       if (!head) return head;\n       \n       ListNode* pre = NULL;\n       while (head) {\n           auto t = head->next;\n           head->next = pre;\n           pre = head;\n           head = t;\n       }\n       \n       return pre;\n    }\n};\n\n```\n\n## 链表反转-递归版代码实现\n\n```cpp\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (!head) return NULL;\n        //base\n         if (!head->next) return head;\n\n        //对子问题进行递归-当前节点的下一个\n        auto nh = reverseList(head->next);\n        head->next->next = head;\n        head->next = NULL;\n        return nh;\n    }\n};\n```\n","tags":["链表反转"],"categories":["数据结构与算法"]},{"title":"链表系列-链表逆序打印到数组","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/reverse/reverse_to_array.html","content":"\n输入一个链表的头结点，按照 从尾到头 的顺序返回节点的值。\n\n返回的结果用数组存储。\n\n样例\n输入：[2, 3, 5]\n返回：[5, 3, 2]\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> printListReversingly(ListNode* head) {\n        vector<int> r;\n        while (head) {\n            r.push_back(head->val);\n            head = head->next;\n        }\n        return vector<int>(r.rbegin(), r.rend()); \n    }\n};\n\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> res;\n\n    void reverse(ListNode* head) {\n        if (!head) return;\n        reverse(head->next);\n        res.push_back(head->val);\n    }\n\n    vector<int> reversePrint(ListNode* head) {\n        reverse(head);\n        return res;\n    }\n};\n```\n","tags":["链表反转"],"categories":["数据结构与算法"]},{"title":"链表系列-链表环入口","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/slow_fast_pointer/entryNodeOfLoop.html","content":"\n## 链表环入口-题目描述\n\n给定一个链表，若其中包含环，则输出环的入口节点。\n\n若其中不包含环，则输出null。\n\n样例\nQQ截图20181202023846.png\n\n给定如上所示的链表：\n[1, 2, 3, 4, 5, 6]\n2\n注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。\n\n则输出环的入口节点3.\n\n<!-- more -->\n\n## 链表环入口-总体思路\n\n考察点：双指针（一前一后的快慢指针）\n\n## 链表环入口-代码实现\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *entryNodeOfLoop(ListNode *head) {\n        if (!head || !head->next || !head->next->next) return NULL;\n        \n        auto fast = head, slow = head;\n        while (fast && fast->next && slow) {\n            slow = slow->next; /慢的走一步\n            fast = fast->next->next;  //快的走两步\n            if (slow == fast) {\n                break;\n            }\n        }\n        \n        if (fast != slow || !fast || !fast->next || !slow) {\n            return NULL;\n        }\n        \n        //再重新走一遍\n        slow = head;\n        while (fast != slow) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        \n        return fast;\n    }\n};\n```\n","tags":["链表","快慢指针"],"categories":["数据结构与算法","剑指Offer"]},{"title":"链表-快慢指针","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/slow_fast_pointer/index.html","content":"## 链表快慢指针相关经典题目\n\n|  题目分类 | 题目名称 |考察点   |其他说明|\n|  ----  | ---- |----  |----  |\n| | [排序链表删除重复节点](./deleteDuplication.html)  |哨兵、双指针|\n| | [链表中环的入口](../entryNodeOfLoop.html)  |双指针之快慢指针|\n| | [链表倒数第K个节点](../findKthToTail.html)  |双指针之快慢指针|\n| | [两个链表的公共节点](findFirstCommonNode.html)  |双指针之快慢指针|\n","tags":["链表","快慢指针"],"categories":["数据结构与算法","剑指Offer"]},{"title":"链表系列-链表倒数第K个节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/slow_fast_pointer/findKthToTail.html","content":"\n## 链表倒数第K个节点-题目描述\n\n输入一个链表，输出该链表中倒数第k个结点。\n\n注意：\n\nk >= 0;\n如果k大于链表长度，则返回 NULL;\n样例\n输入：链表：1->2->3->4->5 ，k=2\n\n输出：4\n\n<!-- more -->\n\n## 链表倒数第K个节点-总体思路\n\n考察点：双指针（一前一后的快慢指针）\n\n先让一个指针往前走k步；然后双指针一起走，如果快的到了尾巴了，则慢的就指向了倒数k。\n\n## 链表倒数第K个节点-代码实现\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findKthToTail(ListNode* head, int k) {\n        auto fast = head;\n        auto slow = head;\n        while (fast && k) {\n            k--;\n            fast = fast->next;\n        }\n        \n        if (k > 0) return NULL;\n        if (slow == fast) return NULL;\n        \n        while (fast) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        \n        return slow;\n    }\n};\n```\n","tags":["链表","快慢指针"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二叉树系列-二叉树子结构","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/hasSubtree.html","content":"\n## 二叉树子结构-题目描述\n\n输入两棵二叉树A，B，判断B是不是A的子结构。\n\n我们规定空树不是任何树的子结构。\n\n样例\n树A：\n\n     8\n    / \\\n   8   7\n  / \\\n 9   2\n    / \\\n   4   7\n树B：\n\n   8\n  / \\\n 9   2\n返回 true ,因为B是A的子结构。\n\n<!-- more -->\n\n## 二叉树子结构-总体思路\n\n明确一下子结构匹配的三种情况：\n\n（1）当前子树与Target匹配\n\n（2）当前子树的右子树与Target匹配\n\n（3）当前子树的左子树与Target匹配\n\n遍历方式：先序遍历\n\n参数：两棵子树的根节点\n\nbase condition: nullptr判定\n\n处理逻辑：\n\n（1）重点考虑是否覆盖了所有的子结构匹配的情况\n\n返回值：是否匹配\n\n## 二叉树子结构-代码实现\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasSubtree(TreeNode* r1, TreeNode* r2) {\n        if (!r2) {return false;}\n        \n        if (!r1)  return false;\n        \n        //如果当前节点不匹配，需要继续遍历子树；而不是返回\n        if (r1->val == r2->val) {\n            bool ret = true;\n            if (r2->left || r2->right) {\n                ret = (r2->left ? (hasSubtree(r1->left, r2->left)) : true) && (r2->right ? hasSubtree(r1->right, r2->right) : true);\n            }\n            if (ret) return ret;\n        }\n\n        return hasSubtree(r1->left, r2) || hasSubtree(r1->right, r2);\n     }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二叉树系列-判断二叉树是否对称","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/isSymmetric.html","content":"\n## 判断二叉树是否对称-题目描述\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。\n\n如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n样例\n如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：\n    1\n   / \\\n  2   2\n   \\ / \\\n   4 4  3\n\n<!-- more -->\n\n## 判断二叉树是否对称-总体思路\n\n这个问题比较tricky的地方在于：根节点的处理是不同于其他节点呢？\n\n那么为什么root节点比较特殊呢？ 根因在于：对称轴便是在于root上，root一定是一个特例！\n\n想明白这一点之后，自然就是遍历顺序了：前序遍历\n\n## 判断二叉树是否对称-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        /*\n        这么写会segment fault? why?\n        if (!root) true;\n        return dfs(root->left, root->right);\n        */\n        return !root || dfs(root->left, root->right);\n    }\n    \n    bool dfs(TreeNode* p1, TreeNode* p2) {\n        if (!p1 || !p2) return !p1 && !p2;\n        \n        //cout << p1 << p2 << endl;\n        if (p1->val != p2->val) return false;\n        \n        return dfs(p1->left, p2->right) && dfs(p1->right, p2->left);\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二叉树系列-二叉树镜像","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/mirror.html","content":"\n## 二叉树镜像-题目描述\n\n输入一个二叉树，将它变换为它的镜像。\n\n样例\n输入树：\n      8\n     / \\\n    6  10\n   / \\ / \\\n  5  7 9 11\n\n [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] \n输出树：\n      8\n     / \\\n    10  6\n   / \\ / \\\n  11 9 7  5\n\n [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]\n\n<!-- more -->\n\n## 二叉树镜像-总体思路\n\n这个问题与[判断二叉树是否对称](isSymmetric.html)差别还是蛮大的，一定要注意区分开来。\n\n遍历方式：后序遍历\n\n参数：当前节点\n\n处理逻辑：在完成子节点的迭代之后，swap指针即可。\n\n返回值：当前节点\n\n## 二叉树镜像-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* dfs(TreeNode* root) {\n        if (!root) return nullptr;\n        \n        auto new_left = dfs(root->right);\n        auto new_right = dfs(root->left);\n        \n        root->left = new_left;\n        root->right = new_right;\n        return root;\n    }\n    \n    void mirror(TreeNode* root) {\n       root = dfs(root);\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"数组系列-从外向里以顺时针的顺序打印矩阵","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/printMatrix.html","content":"\n## 从外向里以顺时针的顺序打印矩阵-题目描述\n\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n\n样例\n输入：\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n\n<!-- more -->\n\n## 从外向里以顺时针的顺序打印矩阵-总体思路\n\n该题目的核心考察点在于：方向数组的应用\n\n```cpp\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    for (int d = 0; d < 4; d++) {\n        //do sth\n    }\n```\n\n另一个考察点是访问bitmap的使用。\n\n## 从外向里以顺时针的顺序打印矩阵-代码实现\n\n```cpp\nclass Solution {\npublic:\n    vector<int> printMatrix(vector<vector<int> > matrix) {\n        vector<int> res;\n        int rows = matrix.size();\n        if (!rows)  return res;\n        int cols = matrix[0].size();\n        if (!cols) return res;\n        \n        vector<int> visited(rows * cols + 1, false);\n        \n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n        for (int i = 0, j = 0, d = 0, k = 0; k < rows * cols; ++k) {\n            res.push_back(matrix[i][j]);\n            visited[i * cols + j] = true;\n            i += dx[d], j += dy[d];\n            if (i < 0 || i >= rows || j < 0 || j >= cols || visited[i * cols + j]) {\n                i -= dx[d], j-=dy[d]; //撤销原来走的路\n                d = (d + 1) % 4;    //改变方向\n                i += dx[d], j += dy[d]; //重新走一遍\n            }\n        }\n        \n        return res;\n    }\n};\n```\n","tags":["数组","方向数组"],"categories":["数据结构与算法"]},{"title":"栈系列-支持min操作的栈","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/minStack.html","content":"\n## 支持min操作的栈-题目描述\n\n设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。\n\npush(x)–将元素x插入栈中\npop()–移除栈顶元素\ntop()–得到栈顶元素\ngetMin()–得到栈中最小元素\n样例\nMinStack minStack = new MinStack();\nminStack.push(-1);\nminStack.push(3);\nminStack.push(-4);\nminStack.getMin();   --> Returns -4.\nminStack.pop();\nminStack.top();      --> Returns 3.\nminStack.getMin();   --> Returns -1.\n\n## 支持min操作的栈-总体思路\n\n空间换时间，用另外一个stack去储存最小值。\n\n另外，如果要求额外存储空间控制在$O(1)$呢？\n\n思路：\n\n1. 用一个数字来存储当前最小值\n2. 栈中存差值，确保可以根据栈中存的值 与 最小值，能够还原出 原始值。\n\n如果新来的元素NewCome，比之前的最小值oldMin更小；oldMin存的就是当前元素了； 现在的问题变成“当当前元素被pop出之后，如何计算出新的最小值）？” 新存入的diff = newMin - oldMin; oldMin = newMin - diff ; 因为diff小于0，所以oldMin更大； \n\n3. 当发生pop时，能够计算得出新的最小值\n\n## 支持min操作的栈-代码实现\n\n```cpp\nclass MinStack {\npublic:\n    stack<int> ms;\n    stack<int> hs;\n    \n    /** initialize your data structure here. */\n    MinStack() {\n        \n    }\n    \n    void push(int x) {\n        ms.push(x);\n        if (hs.empty()) hs.push(x);\n        else hs.push(min(x, hs.top()));\n    }\n    \n    void pop() {\n        ms.pop();\n        hs.pop();\n    }\n    \n    int top() {\n        return ms.top();\n    }\n    \n    int getMin() {\n        return hs.top();\n    }\n\n    //O(1)额外空间的解法【注意：下面的代码有错误！调试未通过！】\n  stack<int> diff;\n    int minE;\n\n    void push(int value) {\n        if (diff.empty()) {\n            minE = value;\n            diff.push(0);\n            return;\n        }\n\n        if (minE <= value) {\n            diff.push(value - minE);\n            return;\n        }\n        else { //进入了一个更小的元素\n            diff.push(value - minE); \n            minE = value;\n        }\n    }\n\n    void pop() {\n        int t = diff.top();\n        diff.pop();\n        if (t < 0) { //更新最小值\n            minE = minE - t;\n        }\n    }\n\n    int top() {\n        int t = diff.top();\n         if (t >= 0) {\n             return t + minE;\n         } else {\n             return minE;\n         }\n    }\n\n    int min() {\n        return minE;\n    }\n\n     //O(1)额外空间的解法【注意：下面的代码可能有错误！调试未通过！】\n\n    stack<int> diffs;\n    int m = MAX_INT;\n\n    void push(int x) {\n\n        if (diffs.empty()) {\n            m = x;\n            diffs.push(0);\n            return;\n        }\n\n        diffs.push(m - x);\n        if (x > m) {\n            m = x;\n        }\n    }\n    \n    void pop() { \n        int s = diffs.top();\n        if  (s < 0) {\n           m = m + s; //更新max\n        } \n        diffs.pop();\n    }\n    \n    int top() {\n        int s = diffs.top();\n        return m - s;\n    }\n    \n    int getMax() {\n        return m;\n    }\n\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n","tags":["栈"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-二叉树的序列化与反序列化","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/deserialize.html","content":"\n## 二叉树的序列化与反序列化-题目描述\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。\n\n样例\n你可以序列化如下的二叉树\n    8\n   / \\\n  12  2\n     / \\\n    6   4\n\n为：\"[8, 12, 2, null, null, 6, 4, null, null, null, null]\"\n注意:\n\n以上的格式是AcWing序列化二叉树的方式，你不必一定按照此格式，所以可以设计出一些新的构造方式\n\n## 中二叉树的序列化与反序列化-总体思路\n\n重点考虑反序列化，我们需要考虑一种很容易找到root节点的遍历方式。\n\n如果我无法找到root节点，是无法通过递归来完成反序列化的。\n\n在前中后三种遍历中，我们可以选择先序遍历。 先序遍历，最容易找到root节点\n\n## 中二叉树的序列化与反序列化-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    string s;\n    \n    void dfs_s(TreeNode* root, string& res) {\n        if (!root) {\n            res += \"null \";\n            return;\n        }\n        \n        res += (to_string(root->val) + \" \");\n        dfs_s(root->left, res);\n        dfs_s(root->right, res);\n    }\n    \n    \n    //1, 2, 4, 5, 6, null, null, null\n    // 注意此处是引用类型\n    // 如果不用下标，直接用字符串char*呢？ 他应该是char*& ,而不可以是char* \n    // char* 是指针，但是确是值传递！！对于值传递，当递归到内部时，外层无法感知到内部变化；\n    TreeNode* dfs_us(int& u) {\n        if (u >= s.size()) {\n            return NULL;\n        }\n        \n        //如果是nullptr\n        if (s[u] == 'n') {\n            u += 5;\n            return nullptr;\n        }\n        \n        //如果是有意义的内容\n        int val = 0;\n        int flag = 1;\n        if (s[u] == '-') {flag = -1; u++;}\n        while (s[u] != ' ') {\n            val = val * 10 + s[u++] - '0';\n        }\n        val *= flag;\n        u++;\n        \n        //上面都是处理当前节点\n        \n        auto r = new TreeNode(val);\n        auto left = dfs_us(u); //处理左边\n        auto right = dfs_us(u);\n        r->left =left, r->right = right;\n        return r;\n    }\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string res;\n        dfs_s(root, res);\n        return res;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        s = data;\n        int c = 0;\n        return dfs_us(c);\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"动态规划系列-获取不同的翻译方法次数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/getTranslationCount.html","content":"\n## 获取不同的翻译方法次数-题目描述\n\n给定一个数字，我们按照如下规则把它翻译为字符串：\n\n0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。\n\n一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。\n\n请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。\n\n样例\n输入：\"12258\"\n\n输出：5\n\n## 获取不同的翻译方法次数-总体思路\n\n首先最容易想到的解法是递归，但是我们注意到有很多重复计算，所以更优的做法应该是DP\n\ndp[i]表示0到s[i]这个字符串能够包含的翻译方法。\n\n启发式思考：对于字符串类的DP问题，dp[i]一般是表示以i为结尾的字符串要计算的值。\n\nd[i] = dp[i - 1] + dp[i - 2] when as a ALHPA OR  dp[i - 1] when other\n\n## 获取不同的翻译方法次数-代码实现\n\n```cpp\nclass Solution {\npublic:\n    string s;\n    \n    int dfs(int u) {\n        int res = 0;\n        if (u == s.size()) {\n            return 1;\n        }\n        \n        res += (1 * dfs(u + 1)); //长度为1的结果数量\n        if (u + 1 < s.size()) {\n           int val = 10 * (s[u] - '0') + s[u + 1] - '0';\n           if (10 <= val && val <= 25) { \n               res += (1 * dfs(u + 2)); //长度为2的结果数\n           }\n        }\n        \n        return res;\n    }\n    \n    int getTranslationCount(string _s) {\n        s = _s;\n        return dfs(0);\n    }\n};\n```\n","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"链表系列-复制复杂链表","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/copyRandomList.html","content":"\n## 复制复杂链表-题目描述\n\n请实现一个函数可以复制一个复杂链表。\n\n在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。\n\n注意：\n\n函数结束后原链表要与输入时保持一致。\n\n## 复制复杂链表-总体思路\n\n有两种思路：\n\n第一种思路，比较容易想到\n\n（1）遍历一遍，复制出新的node, 并维护好node之间的next关系，同时使用HashMap存储新旧node的映射关系\n\n（2）再遍历一遍，借助hashMap找到新节点对应的random指向过去。\n\n时间复杂度：$O(2n)$, 空间复杂度：$O(n)$\n\n那么我们是否可以不使用额外的空间吗？答案是可以的（此处需要启发式思考，实在想不出我觉得也问题不大！）\n\n（1）遍历一遍，复制新的节点，作为原节点的下一个节点插入到链表中\n\n（2）遍历一遍，如果有random指针，则借助新插入的节点找到新的random指针目标节点\n\n（3）再遍历一遍，访问链表，去掉老的链表节点\n\n时间复杂度：$O(3n)$, 空间复杂度：$O(1)$\n\n## 复制复杂链表-代码实现\n\n```cpp\n/**\n * Definition for singly-linked list with a random pointer.\n * struct ListNode {\n *     int val;\n *     ListNode *next, *random;\n *     ListNode(int x) : val(x), next(NULL), random(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *copyRandomList(ListNode *head) {\n        if (!head) return NULL;\n        \n        for (auto p = head; p;) {\n            auto np = new ListNode(p->val);\n            auto next = p->next;\n            np->next = next;\n            p->next = np;\n            p = next;\n        }\n    \n        for (auto p = head; p; p = p->next->next) {\n            if (p->random) {\n                p->next->random = p->random->next;\n            }\n        }\n        \n        auto dummy = new ListNode(-1);\n        auto tail = dummy;\n        \n        for (auto p =head; p;) {\n            tail = tail->next = p->next;\n            p = p->next = p->next->next;\n        }\n        \n        \n        return dummy->next;\n    }\n};\n```","tags":["链表"],"categories":["数据结构与算法","剑指Offer"]},{"title":"栈系列-检查合法Stack的弹出序列","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/isPopOrder.html","content":"\n## 检查合法Stack的弹出序列-题目描述\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。\n\n假设压入栈的所有数字均不相等。\n\n例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。\n\n注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。\n\n样例\n输入：[1,2,3,4,5]\n      [4,5,3,2,1]\n\n输出：true\n\n## 检查合法Stack的弹出序列-总体思路\n\n模拟一遍；\n\n对于每一个pushed序列元素，\n\n对于栈有两个操作：\n（1）当前元素入栈\n（2）弹出栈。\n\n如果弹出序列的当前元素与栈顶元素相同，则弹出；否则继续入栈。\n\n首先压入第一个元素；\n\n然后紧接着此时栈有两个操作？ 弹出当前元素 或者 继续压入新的元素。\n\n如何区分呢？\n\n要看top与弹出序列的当前是否一致；如果一致，说明弹出了元素； 如果不一致，说明压入了新的元素。\n\n接着再继续比较...\n\n## 检查合法Stack的弹出序列-代码实现\n\n```cpp\nclass Solution {\npublic:\n/*\n[1,2,3,5]\n1,2,3, 5, \nq: [4,5,3,1,2]\n\n*/\nbool isPopOrder(vector<int> p,vector<int> q) {\n        if (p.size() != q.size()) return false;\n        stack<int> s;\n        int i = 0, j = 0;\n        while (j < int(q.size())) {\n            if (s.empty() || s.top() != q[j]) {\n                if (i == int(p.size())) {\n                    return false;\n                }\n                s.push(p[i++]);\n            }\n            else {\n                s.pop();\n                j++;\n            }\n        }\n        return true;\n    }\n};\n```\n","tags":["栈"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-二叉树最远距离","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/GetMaxDistance.html","content":"\n如果我们把二叉树视为一个图，父子节点之间的连线视为双向的，我们姑且定义为“举例”为两节点之间边的个数。写一个程序求一颗二叉树中相距最远的两个节点之间的距离（《编程之美》3.8）\n\n### 解题思路\n\n该题目的技巧在于 全局变量的 应用。\n\n需要克服的惯性思维：更多的题目的计算结果会作为递归函数的返回变量。\n\n这个函数的返回值其实是root节点的高度。\n\n在计算高度的过程中，**顺便**完成全局变量的更新。\n\n### code\n\n```cpp\nint GetMaxDistance(TreeNode* root) {\n    if (root == NULL) return 0;\n    \n    int max_distance = INT_MIN;\n\n    dfs(root, INT_MIN);\n\n    return max_distance\n}\n\nint dfs(TreeNode* root, int &max_distance) {\n    if (root == NULL) return -1;\n\n    int left_max_depth = dfs(root->left, &max_distance);\n    int right_max_depth = dfs(root->right, &max_distance);\n\n    int temp_distance = left_max_depth + right_max_depth + 2;\n\n    if (temp_distance > max_distance) max_distance = temp_distance;\n\n    return left_max_depth > right_max_depth ? left_max_depth + 1 : right_max_depth + 1;\n}\n```","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-二叉树中结点值的和为输入整数的所有路径","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/findPathInTree.html","content":"\n## 二叉树中结点值的和为输入整数的所有路径-题目描述\n\n输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。\n\n从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n\n样例\n给出二叉树如下所示，并给出num=22。\n      5\n     / \\\n    4   6\n   /   / \\\n  12  13  6\n /  \\    / \\\n9    1  5   1\n\n输出：[[5,4,12,1],[5,6,6,5]]\n\n## 二叉树中结点值的和为输入整数的所有路径-总体思路\n\n这里，我在下面的代码中写了很多种写法，我们需要好好体会以下几个点：\n\n（1）我的return条件是什么？（是遇到空节点return还是遇到叶子结点return)\n\n（2）我应该如何处理当前访问到的节点\n\n（2）我应该如何还原现场（是pop一次还是pop两次）\n\n（3）return条件与还原现场的关系是什么？\n\n## 二叉树中结点值的和为输入整数的所有路径-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> path;\n    \n    //一种写法【正确】---如果到达空节点，则返回\n    void dfs(TreeNode* root, int sum) {\n        if (!root) return;\n        \n        path.push_back(root->val);\n        sum -= root->val;\n        if (!root->left && !root->right && !sum) {\n            res.push_back(path);\n            //这里不会return;\n            //假设最后一个叶子结点是一个错误答案，我们显然需要把这个节点pop出来？\n            //那我pop的时机是什么呢？ 显然是在遍历完左右子树之后再pop出来。\n        }\n       \n        dfs(root->left, sum);\n        dfs(root->right, sum);\n        path.pop_back();\n    }\n    \n    //一种正确的写法：注意这里，非叶子节点才会被push进去，所以只需要pop一次；\n    void dfs(TreeNode* root, int sum) {\n        //结束条件\n        if (!root->left && !root->right) { \n            if (sum == root->val) {\n                path.push_back(root->val);\n                ret.push_back(path);\n                path.pop_back();\n            }\n            return;\n        }\n\n        path.push_back(root->val);\n        if (root->left) dfs(root->left, sum - root->val);\n        if (root->right) dfs(root->right, sum- root->val);\n        path.pop_back();\n    }\n\n\n    //另一种正确的写法---如果到达叶子节点，则返回\n     void dfs2(TreeNode* root, int sum) {\n        path.push_back(root->val);\n        sum -= root->val;\n        if (!root->left && !root->right) {\n            if (!sum) {\n                res.push_back(path);\n            }  \n            return; //注意这里有一个return\n            //注意这里return了，现在path中有一个错误的节点，我这个节点需要什么时候pop出来呢？\n            //显然只能在外层调用的时候。\n        }\n       \n        if (root->left) {\n            dfs(root->left, sum);\n            path.pop_back();\n        }\n\n        if (root->right) {\n            dfs(root->right, sum);\n            path.pop_back();\n        }\n    }\n\n     //错误的写法---如果到达叶子节点，则返回; 但是只pop了一次！！！\n     void dfs3(TreeNode* root, int sum) {\n        path.push_back(root->val);\n        sum -= root->val;\n        if (!root->left && !root->right) {\n            if (!sum) {\n                res.push_back(path);\n            } \n            return;  //注意这里有一个return\n        }\n       \n        if (root->left) {\n            dfs(root->left, sum);\n        }\n\n        if (root->right) {\n            dfs(root->right, sum);\n        }\n\n        path.pop_back();\n    }\n    \n    vector<vector<int>> findPath(TreeNode* root, int sum) {\n        dfs(root, sum);\n        return res;\n    }\n};\n```","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-中序遍历序列的下一个节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/inorderSuccessor.html","content":"\n## 中序遍历序列的下一个节点-题目描述\n\n给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。\n\n注意：\n\n如果给定的节点是中序遍历序列的最后一个，则返回空节点;\n二叉树一定不为空，且给定的节点一定不是空节点；\n样例\n假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。\n\n则应返回值等于3的节点。\n\n解释：该二叉树的结构如下，2的后继节点是3。\n  2\n / \\\n1   3\n\n## 中序遍历序列的下一个节点-总体思路\n\n需要我们明确中序遍历的定义\n\n模拟题\n\n其实模拟题就是分情况讨论。\n\n## 中序遍历序列的下一个节点-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode *father;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* p) {\n        //如果有右孩子，则一直遍历找到其左左左..\n        if (p->right) {\n            p = p->right;\n            while (p->left) p = p->left;\n            return p;\n        }\n        \n        //判断他自己是左孩子，还是右孩子。\n        //如果是左孩子，则直接访问其父亲\n        //如果是右孩子，则一直访问，直到不是右孩子。\n        \n        while (p->father && p->father->left != p) p = p->father;\n        return p->father;\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二叉树遍历系列-从上往下打印出二叉树的每个结点","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/printFromTopToBottom.html","content":"\n## 从上往下打印出二叉树，同层从左到右-题目描述\n\n从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。\n\n样例\n输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]\n    8\n   / \\\n  12  2\n     /\n    6\n   /\n  4\n\n输出：[8, 12, 2, 6, 4]\n\n## 从上往下打印出二叉树，同层从左到右-总体思路\n\n借助queue来实现层次遍历\n\n## 从上往下打印出二叉树，同层从左到右-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n \n    vector<int> printFromTopToBottom(TreeNode* root) {\n         vector<int> res;\n        queue<TreeNode*> q;\n    \n        if (!root) return res;\n        \n        q.push(root);\n        while (!q.empty()) {\n            auto r = q.front();\n            q.pop();\n            res.push_back(r->val);\n            if (r->left) q.push(r->left);\n            if (r->right) q.push(r->right); \n        }\n        \n        return res;\n    }\n    \n};\n```\n\n## 从上往下打印出二叉树，同层从左到右，分行打印-题目描述\n\n从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。\n\n样例\n输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]\n    8\n   / \\\n  12  2\n     /\n    6\n   /\n  4\n\n输出：[[8], [12, 2], [6], [4]]\n\n## 从上往下打印出二叉树，同层从左到右，分行打印-总体思路\n\n相对上题，难点在于如何识别分行，一般而言我们有以下几种办法：\n\n（1）使用nullptr作为分隔符，每次遇到nullptr进行分行处理，并压入新的nullptr。nullptr是当前层的终止符。\n\n（2）借助size, 每次遍历size个元素，size为上一次压入的元素个数。通过size来代表该层有多少元素。\n\n## 从上往下打印出二叉树，同层从左到右，分行打印-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> printFromTopToBottom(TreeNode* root) {\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        \n        if (!root) return res;\n        \n        q.push(root);\n        q.push(nullptr);\n        vector<int> level;\n        \n        while (q.size()) {\n            auto t = q.front();\n            q.pop();\n            \n            if (!t) {\n                if (level.empty()) break;\n                res.push_back(level);\n                level.clear();\n                q.push(nullptr);\n                continue;\n            }\n            \n            level.push_back(t->val);\n            if (t->left) q.push(t->left);\n            if (t->right) q.push(t->right);\n            \n        }\n    }\n\n     vector<vector<int>> printFromTopToBottom2(TreeNode* root) {\n        vector<vector<int>> res;\n        vector<int> level;\n        queue<TreeNode*> q;\n        \n        if (!root) return res;\n        q.push(root);\n        while (q.size()) {\n            int qs = q.size();  //必须赋值到局部变量\n            for (int i = 0; i < qs; ++i) {\n                auto t = q.front();\n                q.pop();\n                level.push_back(t->val);\n                if (t->left) q.push(t->left);\n                if (t->right) q.push(t->right);\n            }\n            res.push_back(level);\n            level.clear();   \n        }\n    }\n};\n```\n\n## 从上往下打印出二叉树，同层从左到右，之字形打印-题目描述\n\n请实现一个函数按照之字形顺序从上向下打印二叉树。\n\n即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n\n样例\n输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]\n    8\n   / \\\n  12  2\n     / \\\n    6   4\n输出：[[8], [2, 12], [6, 4]]\n\n## 从上往下打印出二叉树，同层从左到右，之字形打印-总体思路\n\n基于上题，在res加入元素之前，判定res是否奇数，如果是奇数的话，就reverse一下子level数组\n\n## 从上往下打印出二叉树，同层从左到右，之字形打印-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> printFromTopToBottom(TreeNode* root) {\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        \n        if (!root) return res;\n        \n        q.push(root);\n        q.push(nullptr);\n        vector<int> level;\n        \n        bool flag = false;\n        \n        while (q.size()) {\n            auto t = q.front();\n            q.pop();\n            \n            if (!t) {\n                if (level.empty()) break;\n                if (flag) reverse(level.begin(), level.end());\n                res.push_back(level);\n                level.clear();\n                q.push(nullptr);\n                flag = !flag;\n                continue;\n            }\n            \n            level.push_back(t->val);\n            if (t->left) q.push(t->left);\n            if (t->right) q.push(t->right);\n            \n        }\n    }\n\n    vector<vector<int>> printFromTopToBottom2(TreeNode* root) {\n        vector<vector<int>> res;\n        vector<int> level;\n        queue<TreeNode*> q;\n        \n        if (!root) return res;\n        q.push(root);\n        while (q.size()) {\n            int qs = q.size();\n            for (int i = 0; i < qs; ++i) {\n                auto t = q.front();\n                q.pop();\n                level.push_back(t->val);\n                if (t->left) q.push(t->left);\n                if (t->right) q.push(t->right);\n            }\n            if (res.size() % 2) {\n                reverse(level.begin(), level.end());\n            }\n            res.push_back(level);\n            level.clear();   \n        }\n    }\n};\n```\n\n## 垂直打印二叉树\n\n解答思路：\n\n1. 依旧是通过层次打印\n2. 放入队列的不仅是tree node， 还需要放入当前的横向坐标\n3. root坐标为0， 左节点减1， 右节点加1\n\n```cpp\ntypedef std::pair<int, TreeNode*> PIT;\n\nclass Solution {\npublic:\n    vector<vector<int>> printV(TreeNode* root) {\n        unsorted_map<int, vector<int>&> m;\n        queue<PIT> q;\n\n        q.push_back(make_pair(0, root));\n        while (!q.empty()) {\n            int n = q.size();\n            for (int i = 0; i < n; i++) {\n                PIT p = q.top(); q.pop();\n                m[p.first].push_back(p.second.val);\n                if (p.second->left)\n                    q.push_back(make_pair(p.first - 1, p.second->left));\n                if (p.second->right)\n                    q.push_back(make_pair(p.first - 1, p.second->right));\n            }\n        }\n    }\n\n};\n```","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-二叉搜索树转有序双向链表","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/tree2list.html","content":"\n## 二叉搜索树转有序双向链表-题目描述\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。\n\n要求不能创建任何新的结点，只能调整树中结点指针的指向。\n\n注意：\n\n需要返回双向链表最左侧的节点。\n例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。\n\n## 二叉搜索树转有序双向链表-总体思路\n\n两种思路：\n\n第一种思路，dfs的主要任务是返回子树对应链表的头尾节点；按照这种思路的话，我们的遍历方式是后序遍历。\n\n第二种思路，dfs的主要任务就是按照顺序访问到每一个node，同时记录一个全局的pre，然后将pre与node建立双向关联即可。\n\n## 二叉搜索树转有序双向链表-代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\npair<Node*, Node*> dfs(Node* root) {\n    if (!(root->left) && !(root->right)) {\n        root->left = root;\n        root->right = root;\n        return {root, root};\n    }\n    \n    //访问左边\n    pair<Node*, Node*>  left = {root, root};\n    if (root->left) {\n        left = dfs(root->left);\n    }\n\n    //访问右边\n    pair<Node*, Node*>  right = {root, root};\n    \n    if (root->right) {\n        right = dfs(root->right);\n    }\n\n    //访问中间节点\n    if (left.first != root) {\n        left.second->right = root;\n        root->left = left.second;\n    }\n\n    if (right.first != root) {\n        root->right = right.first;\n        right.first->left = root;\n    }\n \n    return {left.first, right.second};\n}\n```\n\n```cpp\n void  dfs(Node* root) {\n        if (!root) return;\n        \n        //访问左边\n        dfs(root->left);\n\n        //中序遍历\n        if (!pre) {\n            head = root;\n        }\n        else {\n            pre->right = root;\n            root->left = pre;\n        }\n        pre = root;\n\n        //访问右边\n        dfs(root->right);\n    }\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"二叉树遍历系列-判断该数组是不是某二叉搜索树的后序遍历的结果","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/verifySequenceOfBST.html","content":"\n## 判断该数组是不是某二叉搜索树的后序遍历的结果-题目描述\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。\n\n如果是则返回true，否则返回false。\n\n假设输入的数组的任意两个数字都互不相同。\n\n样例\n输入：[4, 8, 6, 12, 16, 14, 10]\n\n输出：true\n\n## 判断该数组是不是某二叉搜索树的后序遍历的结果-总体思路\n\n分为几步：\n（1）根据后序遍历序列的定义，最右边的元素是中间节点X，并且左子树的元素均小于X，右子树的元素均大于X\n（2）顺序扫描，找到左右子树的分割点Y(分割点左边都小于X)\n（3）从分割点Y继续扫描，确认是否有bad case，有的话，直接返回不合法\n（4）递归处理左右两部分\n\n## 判断该数组是不是某二叉搜索树的后序遍历的结果-代码实现\n\n```cpp\nclass Solution {\npublic:\n    vector<int> s;\n    bool dfs(int l, int r) {\n        if (l >= r) return true;\n        \n        //找到分界点\n        int k = l;\n        while (k < r && s[k] < s[r]) k++;\n        \n        //确认分界点之后的元素是否都足够大\n        for (int i = k; i< r; ++i) {\n            if (s[i] < s[r]) {\n                return false;\n            }\n        }\n        \n        //递归处理\n        return dfs(l, k - 1) && dfs(k, r - 1);\n        \n    }\n    \n    bool verifySequenceOfBST(vector<int> sequence) {\n        s = sequence;\n        if (s.empty()) return true;\n        return dfs(0, s.size() - 1);\n    }\n};\n\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"翻手法则-字符串反转问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/string_reverse.html","content":"\n## 反转单词-题目描述\n\n输入一个英文句子，单词之前用一个空格隔开，且句首和句尾没有多余空格。翻转句子中单词的顺序，但单词内字符的顺序不变。\n\n为简单起见，标点符号和普通字母一样处理。\n\n例如输入字符串\"I am a student.\"，则输出\"student. a am I\"。\n\n样例\n输入：\"I am a student.\"\n\n输出：\"student. a am I\"\n\n## 反转单词-代码实现\n\n```cpp\nclass Solution {\npublic:\n    void reverse(string& s, int i, int j) {\n        while (i < j) {\n            swap(s[i++], s[j--]);\n        }\n    }\n    \n    string reverseWords(string s) {\n        int i = 0, j = 0;\n        while (s[j] != '\\0') {\n            if (s[j] == ' ') {\n                reverse(s, i, j - 1); //反转每一个\n                i = j + 1;\n            }\n            j++;\n        }\n        reverse(s, i, j - 1); //处理上面的最后一次循环\n\n        //整体反转一次\n        reverse(s, 0, j - 1);\n        return s;\n    }\n};\n```\n\n## 字符串左旋转-题目描述\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。\n\n请定义一个函数实现字符串左旋转操作的功能。\n\n比如输入字符串\"abcdefg\"和数字2，该函数将返回左旋转2位得到的结果\"cdefgab\"。\n\n注意：\n\n数据保证n小于等于输入字符串的长度。\n样例\n输入：\"abcdefg\" , n=2\n\n输出：\"cdefgab\"\n\n## 字符串左旋转-代码实现\n\n```cpp\nclass Solution {\npublic:\n    void reverse(string& s, int i, int j ) {\n        //对撞指针，往中间凑\n        while (i < j) {\n            swap(s[i++], s[j--]);\n        }\n    }\n    string leftRotateString(string str, int k) {\n        int n = str.size();\n        if (k == 0) return str;\n        \n        reverse(str, 0, k - 1);\n        reverse(str, k, n - 1);\n        reverse(str, 0, n - 1);\n        return str;\n    }\n};\n```\n","tags":["字符串"],"categories":["数据结构与算法","剑指Offer"]},{"title":"经典题目系列-N数之和问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/sum_234.html","content":"\n## 二数之和-题目描述\n\n输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。\n\n如果有多对数字的和等于s，输出任意一对即可。\n\n你可以认为每组输入中都至少含有一组满足条件的输出。\n\n样例\n\n输入：[1,2,3,4] , sum=7\n\n输出：[3,4]\n\n## 二数之和-总体思路\n\n（1）Hash $O(n)$\n\n（2）排序后，双指针 $O(nlgn)$\n\n## 二数之和-代码实现\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findNumbersWithSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); ++i) {\n            hash[nums[i]] = i;\n        }\n        vector<int> res(2, 0);\n        for (int i = 0; i < nums.size(); ++i) {\n            auto r = hash.find(target - nums[i]);\n            if (r != hash.end()) {\n                res[0] = nums[i];\n                res[1] = nums[r->second];\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 连续序列和-题目描述\n\n输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。\n\n例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。\n\n样例\n输入：15\n\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n\n## 连续序列和-总体思路\n\n首先最容易想到的思路：\n（1）用两个下标i,j分别指向序列的开始结束位置\n（2）用等差序列求和公式计算和是否等于S，如果等于S，则记录答案\n\n```cpp\nclass Solution {\npublic:\n        vector<vector<int> > findContinuousSequence(int t) {\n        int i = 1, j = 1;\n        int sum = 0;\n        for (int i = 1; i < t; i++) { //结束位置\n            for (j = 1; j < i; j++) { //开始位置\n                if (S[i, j] == t) {\n                    //add to result\n                }\n            }\n        }\n        return res; \n    }\n};\n```\n\n以上时间复杂度为$O(n^2)$\n\n这里有一个经验：\n如果你的算法需要从$O(n^2)$优化到$O(n)$, 一般情况下我们可以考虑三种常用手段：**双指针、单调队列、单调栈**。这三种常用手段都充分利用了这个基本事实：内层循环变量j伴随外层循环变量i单调变化，此处单调变化指的是：i往前走一步，j也只会增加而不会回退。\n\n根据上面的经验，我们重新审视变量j与变量i的关系发现，确实有单调性，所以我们可以通过**双指针**来优化。\n\n还有一点特别重要，那就是代码模版，我们需要非常熟悉各种常见的算法模版，以下为双指针算法的代码模版：\n\n```cpp\nvoid two_pointer() {\n    int i, j;\n    while (i < n) {\n        //新来一个元素\n        while (j < n && check(j)) j++; \n    }\n}\n\n```\n\n## 连续序列和-代码实现\n\n```cpp\nclass Solution {\npublic:\n        vector<vector<int> > findContinuousSequence(int t) {\n        int i = 1, j = 1;\n        int sum = 0;\n        vector<vector<int> > res; //[i, j-1]的和，明确sum的含义\n        while (j < t) {\n            if (sum > t) {\n                while (sum > t) {\n                    sum -= i;\n                    i++;\n                }\n            }\n            else {\n                sum += j;\n                j++;\n            }\n            \n            if (sum == t) {\n                int p = i;\n                vector<int> one;\n                while (p <= j - 1) {\n                    one.push_back(p++);\n                }\n                res.push_back(one);\n            }\n        }  \n\n        return res; \n    }\n};\n```\n","tags":["哈希","双指针"],"categories":["数据结构与算法"]},{"title":"找到仅出现一次的数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/bit/findNumsAppearOnce.html","content":"\n## 找到仅出现一次的数，其他数出现二次\n\n一个整型数组里除了两个数字之外，其他的数字都出现了两次。\n\n请写程序找出这两个只出现一次的数字。\n\n你可以假设这两个数字一定存在。\n\n样例\n输入：[1,2,3,3,4,4]\n\n输出：[1,2]\n\n## 实现思路-基于XOR\n\n## 代码实现-基于XOR\n\n```cpp\nclass Solution {\npublic:\n        vector<int> findNumsAppearOnce(vector<int>& nums) {\n        int s = 0;\n        for (auto x: nums) {\n            s ^= x;\n        }\n\n        int u = s & -s; //找到lowbit\n        vector<int> g0, g1;\n\n        for (auto x: nums) {\n            if (x & u ) g1.push_back(x);\n            else g0.push_back(x); \n        }\n\n        vector<int> res(2, 0);\n        for (auto x : g0) {\n            res[0] ^= x;\n        }\n        for (auto x : g1) {\n            res[1] ^= x;\n        }\n\n        return res;\n    }\n};\n```\n\n## 找到仅出现一次的数，其他数都出现三次\n\n在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。\n\n请找出那个只出现一次的数字。\n\n你可以假设满足条件的数字一定存在。\n\n思考题：\n\n如果要求只使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？\n样例\n输入：[1,1,1,2,2,2,3,4,4,4]\n\n输出：3\n\n## 实现思路-基于Bit位\n\n如果可以用hash，存下每一个数字出现次数就可以了。\n\n但是如果要求O(1)的时间复杂度呢？考虑用位运算。\n\n## 代码实现-基于Bit位\n\n```cpp\nclass Solution {\npublic:\n    int findNumberAppearingOnce(vector<int>& nums) {\n        vector<int> bitmap(32, 0);\n        for (auto x: nums) {\n            for (int i = 0; i < 32; ++i) {\n                if (x & (1 << i)) bitmap[i]++;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < 32; ++i) {\n            if (bitmap[i] % 3) {\n                res += 1 << i;\n            }\n        }\n        return res;\n    }\n};\n\n```\n","tags":["位运算"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-判定是否平衡树","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/isBalanced.html","content":"\n## 题目描述\n\n输入一棵二叉树的根结点，判断该树是不是平衡二叉树。\n\n如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n\n注意：\n\n规定空树也是一棵平衡二叉树。\n样例\n输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示，\n    5\n   / \\\n  7  11\n    /  \\\n   12   9\n\n输出：true\n\n## 实现思路\n\n第一，我们要搞清楚几个概念：树的深度、一个节点的深度与高度。\n\n第二，我们需要知道：深度是从上往下的，我们需要前序遍历。\n\n第三，我们需要知道：高度是从下往上的，我们需要后序遍历。\n\n最后，根节点比较特殊，树的深度，等于根节点的高度，也就是root到所有leaf的最长路径。\n\n综上，该题目还是后序遍历。\n\n## 代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n * \n */\n \ntypedef pair<bool, int> PBI;\n \nclass Solution {\npublic:\n    \n    //没有正确使用全局变量\n    PBI dfs(TreeNode* root) {\n        if (!root) return {true, 0};\n\n        auto lbi = dfs(root->left);\n        if (!lbi.first) return {false, 0};\n\n        auto rbi = dfs(root->right);\n        if (!rbi.first) return {false, 0};\n\n        if (abs(lbi.second - rbi.second) > 1) {\n            return {false, 0};\n        } \n        else {\n            return {true, 1 + max(lbi.second, rbi.second)};\n        }\n    }\n\n    //学会使用全局变量， flag\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n\n        int lh = dfs(root->left);\n        int rh = dfs(root->right);\n\n        if (abs(lh - rh) > 1) {\n            g_flag = false;\n            return 0;\n        }\n\n        return 1 + max(lh, rh);\n    }\n\n    bool isBalanced(TreeNode* root) {\n        return dfs(root).first;\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-获取树的深度","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/treeDepth.html","content":"\n## 题目描述\n\n输入一棵二叉树的根结点，求该树的深度。\n\n从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n\n样例\n输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：\n    8\n   / \\\n  12  2\n     / \\\n    6   4\n\n输出：3\n\n## 实现思路\n\n第一，我们要搞清楚几个概念：树的深度、一个节点的深度与高度。\n\n第二，我们需要知道：深度是从上往下的，我们需要前序遍历。\n\n第三，我们需要知道：高度是从下往上的，我们需要后序遍历。\n\n最后，根节点比较特殊，树的深度，等于根节点的高度，也就是root到所有leaf的最长路径。\n\n## 代码实现\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int dfs(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + max(dfs(root->right), dfs(root->left));\n\n    }\n    int treeDepth(TreeNode* root) {\n        return dfs(root);\n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法","剑指Offer"]},{"title":"位运算系列-不使用四则运算符的加法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/bit/bit_add.html","content":"\n## 题目描述\n\n写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷ 四则运算符号。\n\n样例\n输入：num1 = 1 , num2 = 2\n\n输出：3\n\n## 思路\n\n经验知识1：位运算的特点之一是在**二进制表示下不进位**，参与位运算的各个bit之间是独立无关的。\n\n经验知识2: XOR又称作无进位加法\n\n经验知识3: 计算机便是通过XOR，与操作，移位操作来实现加法的，具体的做法可以见下面的代码。\n\n相信如果你有上面三块知识储备，想出该题目的解法是没有问题的。\n\n这里多说一句，为什么别人可以想出正确的解法，而我们不可以。原因有两个：\n\n第一，别人知道某块知识，而我们不知道。\n\n第二，（需要使用到的知识我们是知道的）别人能够通过发散思维，或者启发式思考调取需要用到的知识储备，而我们却不行。\n\n针对以上两点，我们的解法是：\n\n第一，学习更多的知识、经验、技巧，有更多的知识储备。\n\n第二，不仅仅要学习知识、经验、技巧，还要去尝试着去做深度、广度的思考。深度的话，我们多问几个为什么，去剖析本质，找到他们的第一性原理。广度的话，我们要去做类比，要去做关联，了解两块知识的区别与联系。\n\n第三，去做更多的刻意练习：多刷题，多解题，多推理证明，保证自己思维的严密性。\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    int add(int num1, int num2){\n        while (num2) {\n            /*\n            经过XOR操作后，1/0,0/1,0/0都已经符合预期了，只是1/1？ 本来应该成为10，却变成了0？\n            我们怎样才能找回丢失的进位呢？ 只有&操作才能将两个1变为1，也许是我们好的选择？\n            实际上，这就是计算机执行加法的底层原理。\n            */\n            int sum = num1 ^ num2;\n            int carry = (num1 & num2) << 1;\n            num1 = sum;\n            num2 = carry;\n            //用计算出来的结果重新赋值，有点辗转相除法的感觉。\n        }\n        return num1;\n    }\n\n    int sub(int num1, int num2) {\n        //a - b = a + (-b)\n        return add(num1, add(~num2, 1)))\n    }\n\n    \n    int mul(int a, int b) {\n        //最笨的方法是for循环--b次； 有没有更好的办法呢？ \n        //都转为正数先\n        int a1 = a >= 0 ? a : add(~a, 1);\n        int b1 = b >= 0 ? b : add(~b, 1);\n        int sum = 0;\n        //整个过程跟手动乘法类似\n        while (b1) {\n            if (b1 & 0x01) {\n                sum = add(sum, a1);\n            }\n            a1 <<= 1;\n            b1 >>= 1;\n        }\n\n        //异号，相反数\n        if (a ^ b < 0) {\n            sum = add(-sum, 1);\n        }\n\n        return sum;\n    }\n\n    int div(int a, int b, int& reminder) {\n        int r = 0;\n        //都转为正数先\n        int a1 = a >= 0 ? a : add(~a, 1);\n        int b1 = b >= 0 ? b : add(~b, 1);\n        for (int i = 31; i >= 0; i--) {\n            if ((a1 >> i) >= b1) { // a >= (b << i)\n                r = add(r, 1 << i);\n                a1 = sub(a1, b1 << i);\n            }\n        }\n\n         //异号，相反数\n        if (a ^ b < 0) {\n            r = add(~r, 1);\n        }\n\n        reminder = a1;\n        return r;\n    }\n};\n\n\n```\n","tags":["位运算"],"categories":["数据结构与算法"]},{"title":"奇技淫巧-特殊的累加","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/misc/special_acc.html","content":"\n求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n\n样例\n输入：10\n\n输出：55\n\n## 思路\n\n**常用技巧**： 通过!n来判定n是否等于0\n\n## 代码\n\n```cpp\ntypedef int (*handler)(int);\nhandler fn[2]; \n\nint dfs(int n) {\n    handler myfn= fn[!!n];\n    return myfn(n);\n}\n\nint dfs_base(int n) {\n    return 0;    \n}\n\nint dfs_normal(int n) {\n    return n + dfs(n - 1);\n}\n\nclass Solution {\npublic:\n    int getSum(int n) {\n        fn[0] = dfs_base;\n        fn[1] = dfs_normal;\n        return dfs(n);\n    }\n};\n\n```\n"},{"title":"二分系列-旋转数组找最值","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/find_min_in_rotated_array.html","content":"\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n\n输入一个升序的数组的一个旋转，输出旋转数组的最小元素。\n\n例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。\n\n数组可能包含重复项。\n\n注意：数组内所含元素非负，若数组大小为0，请返回-1。\n\n样例\n输入：nums=[2,2,2,0,1]\n\n输出：0\n\n```cpp\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        if (nums.empty()) return -1;\n        int n = nums.size() - 1;\n        //特判\n        while (nums[0] == nums[n]) {n--;}\n        //特判\n        if (nums[0] <= nums[n]) {\n            return nums[0];\n        }\n        \n        //二分模版\n        int l = 0, r = n;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (nums[0] > nums[mid]) r = mid;\n            else  l = mid + 1;\n        }\n        \n        return nums[r];\n    }\n};\n\n```\n","tags":["二分"],"categories":["数据结构与算法"]},{"title":"二分系列-数字在排序数组中出现的次数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/getNumberOfK.html","content":"\n统计一个数字在排序数组中出现的次数。\n例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。\n\n样例\n输入：[1, 2, 3, 3, 3, 3, 4, 5] ,  3\n\n输出：4\n\n```cpp\nclass Solution {\npublic:\n    int getNumberOfK(vector<int>& nums , int k) {\n    if (nums.empty())  return 0;\n    int l = 0, r = nums.size() - 1;\n    // 左边界\n    while (l < r) {\n        int mid = l + r >> 1;\n        if (nums[mid] < k) {\n            l = mid + 1;\n        }\n        else {\n            r = mid;\n        }\n    }\n    if (nums[r] != k) return 0;\n    int left = r;\n\n    // 右边界\n    l = 0, r = nums.size() - 1;\n    while (l < r) {\n        int mid = l + r  + 1 >> 1;\n        if (nums[mid] > k) {\n            r = mid - 1;\n        }\n        else {\n            l = mid;\n        }\n    }\n\n    return r - left + 1;\n}\n};\n```\n","tags":["二分"],"categories":["数据结构与算法"]},{"title":"二分系列-找数值等于下标的元素","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/getNumberSameAsIndex.html","content":"\n假设一个单调递增的数组里的每个元素都是整数并且是唯一的。\n\n请编程实现一个函数找出数组中任意一个数值等于其下标的元素。\n\n例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。\n\n样例\n输入：[-3, -1, 1, 3, 5]\n\n输出：3\n注意:如果不存在，则返回-1。\n\n```cpp\nclass Solution {\npublic:\n    int getNumberSameAsIndex(vector<int>& nums) {\n        int l = 0, r = nums.size();\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (nums[mid] >= mid) {\n                r = mid;\n            }\n            else { //[mid + 1, r] 都不可能满足满足；因为递增\n                l = mid + 1;\n            }\n        }\n\n        if (nums[r] != r) {\n            return -1;\n        }\n        else {\n            return r;\n        }\n    }\n};\n```\n","tags":["二分"],"categories":["数据结构与算法"]},{"title":"二叉树遍历系列-最低公共祖先","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/lowest_ancestor.html","content":"\n## 题目描述\n\n给出一个二叉树，输入两个树节点，求它们的最低公共祖先。\n\n一个树节点的祖先节点包括它本身。\n\n注意：\n\n输入的二叉树不为空；\n输入的两个节点一定不为空，且是二叉树中的节点；\n样例\n二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：\n    8\n   / \\\n  12  2\n     / \\\n    6   4\n\n1. 如果输入的树节点为2和12，则输出的最低公共祖先为树节点8。\n\n2. 如果输入的树节点为2和6，则输出的最低公共祖先为树节点2。\n\n## 最普通的实现思路\n\n实现考虑容易想到的实现思路：\n\n第一步，找到从root到节点A的路径，计作pa；时间复杂度$O(n)$，空间复杂度$O(n)$\n\n第二步，找到从root到节点B的路径，计作pb；时间复杂度$O(n)$，空间复杂度$O(n)$\n\n第三步，同时遍历pa、pb，找到最后一个相同的元素，便是A、B的最低公共祖先。时间复杂度$O(n)$\n\n综上，总的时间复杂度为$O(3n)$，空间复杂度$O(2n)$\n\n## 常规的二叉树遍历讨论\n\n拿到一个二叉树遍历的题目，\n\n（1）我们首先要思考的是：要解决这个问题，哪种遍历方式最合适？\n\n前序遍历、后序遍历、中序遍历还是层次遍历？\n\n（2）其次，我们做出一个假设：假设我已经调用了dfs(child),并解决了这个子问题\n\n（3）最后，基于上面的假设去思考如何解决整个问题。\n\n针对上面的第一个问题，我们想要**从下往上遍历整棵树，所以我们需要后序遍历**。\n\n同时我们做出假设，dfs(child,p,q)会返回p,q在child子树中的最低公共祖先。那么我们的代码大概会长这样：\n\n```cpp\nTreeNod* dfs(TreeNode* root, TreeNode* p, TreeNode* q) {\n    //基本情况\n    TreeNode* left = dfs(root->left, p, q);\n    TreeNode* right = dfs(root->right, p, q);\n    //更多处理：要充分理解题目的要求，明确每一个概念的定义，将其转换为代码。\n}\n```\n\n如果在left中找到了p/q， 并且在right中也找到了p/q, 那么显然root就是最低公共祖先。\n\n如果left中p/q, 而right没有找到，显然遍历left得到的返回值就是最低公公祖先。\n\n另外需要注意，此处你有一个假设：p\\q一定在tree中能够找到；如果该假设被打破的话，这段代码会出问题。\n\n## 最终代码\n\n```cpp\nTreeNod* dfs(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == p || root == q || root == null) return root;\n    TreeNode* left = dfs(root->left, p, q);\n    TreeNode* right = dfs(root->right, p, q);\n    if (left && right) return root;\n    if (left) return left; else return right;\n}\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"网络-traceroute","url":"/backend_knowledge_architecture/network/trace_rt.html","content":"\ntraceroute\n\nICMP  ttl递减\n\n给目标主机的不可达端口（30000+）发送UDP数据包，并且设置TTL\n\n他从源主机到目的主机发送一连串的IP数据报p1-pn，并且数据报是无法交付的udp数据报。第一个数据报的TTL设置为1，这样当这个数据报转发到第一个路由器的时候，路由器收到后TTL减1，减完1之后发现TTL变为0，路由器会向源主机发送一个超时差错报告报文。\n\n然后是第二个，第二个数据报的TTL设置为2，这样转发到第二个路由器的时候，TTL变为0，并会向源主机在发送一个超时差错报告报文，依次进行此操作。直到第n个数据报pn到达目的主机，但是由于数据报无法交付，因此目的主机会向源主机发送终点不可达差错报告报文。\n通过这种方式，源主机就可以通过发送过来的超时差错报告报文和终点不可达差错报告报文来的得到经过的路由器以及往返时间等信息，达到路由跟踪的目的。\n"},{"title":"操作系统之epoll","url":"/backend_knowledge_architecture/os/epoll.html","content":"\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.40pnce8w2uy0.webp)\n\n正常一个fd会有等待队列，表示有哪一些进程在等待fd可用；\n\n当一个进程在等待一个fd时，内核会把进程结构体从运行队列摘除，放在fd的等待队列上【这样子内核就不会调度到该进程了】\n\n当某个端口有数据可读时，内核会跟进端口查索引表，找到对应的fd\n\n对于select，会频繁的将进程挂在所有FD的等待队列上，然后在select返回的时候，再重新将进程从等待队列中移除，放回到运行队列上。\n\n当进程被唤醒的时候，用户程序也需要遍历fd array，去GET哪些FD可读。\n\n性能极其差！\n\n---\n\neventpoll作为一个中间结构，替代进程，挂在对应的等待队列\n\n而调用epoll_wait的进程当被阻塞的时候是挂在在eventpoll的等待队列上。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4ifaujjeqx40.webp)\n\nselect低效的另一个原因在于程序不知道哪些socket收到数据，只能一个一个的遍历。如果内核维护一个“就绪列表”，引用收到的数据的socket，就能避免遍历。\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.4lmelvefxg80.webp)\n\n---\n\n使用场景：\n\nepoll 在应对大量网络连接时，只有活跃连接很少的情况下才能表现的性能优异。换句话说，epoll 在处理大量非活跃的连接时性能才会表现的优异。如果15000个 socket 都是活跃的，epoll 和 select 其实差不了太多。\n\n---\n\nepoll 的 edge-trigger 和 level-trigger 模式处理逻辑差异极小，性能测试结果表明常规应用场景 中二者性能差异可以忽略。\n? 使用 edge-trigger 的 user app 比使用 level-trigger 的逻辑复杂，出错概率更高。\n? edge-trigger 和 level-trigger 的性能差异主要在于 epoll_wait 系统调用的处理速度，是否是 user app 的性能瓶颈需要视应用场景而定，不可一概而论。\n\n但从 kernel 代码来看，edge-trigger/level-trigger 模式的处理逻辑几乎完全相同，差别仅在于 level-trigger 模式在 event 发生时不会将其从 ready list 中移除，略为增大了 event 处理过程中 kernel space 中记录数据的大小。\n\n然而，edge-trigger 模式一定要配合 user app 中的 ready list 结构，以便收集已出现 event 的 fd，再通过 round-robin 方式挨个处理，以此避免通信数据量很大时出现忙于处理热点 fd 而导致非热点 fd 饿死的现象。统观 kernel 和 user space，由于 user app 中 ready list 的实现千奇百怪，不一定都经过仔细的推敲优化，因此 edge-trigger 的总内存开销往往还大于 level-trigger 的开销。\n\n一般号称 edge-trigger 模式的优势在于能够减少 epoll 相关系统调用，这话不假，但 user app 里可不是只有 epoll 相关系统调用吧？为了绕过饿死问题，edge-trigger 模式的 user app 要自行进行 read/write 循环处理，这其中增加的系统调用和减少的 epoll 系统调用加起来，有谁能说一定就能明显地快起来呢？\n\n---\n\n当然操作系统开发人员也会意识到这些缺陷，并且在设计poll接口时解决了大部分问题，因此你会问，还有任何理由使用select吗？为什么不直接淘汰它了？其实还有两个理由使用它：\n\n1.第一个原因是可移植性。select已经存在很长时间了，你可以确定每个支持网络和非阻塞套接字的平台都会支持select，而它可能还不支持poll。另一种选择是你仍然使用poll然后在那些没有poll的平台上使用select来模拟它。\n2.第二个原因是select的超时时间理论上可以精确到微秒级别。而poll和epoll的精度只有毫秒级。这对于桌面或者服务器系统来说没有任何区别，因为它们不会运行在纳秒精度的时钟上，但是在某些与硬件交互的实时嵌入式平台，降低控制棒关闭核反应堆．可能是需要的。(这就可以作为一个更加精确的sleep()来用)\n\n---\n\n什么时候应该选择使用Poll：\n跨平台\n同一时刻你的应用程序监听的套接字少于1000（这种情况下使用epoll不会得到任何益处）。\n您的应用程序需要一次监视超过1000个套接字，但连接非常短暂（这是一个接近的情况，但很可能在这种情况下，您不太可能看到使用epoll的任何好处，因为epoll 的加速将这些新描述符添加到集合中会浪费等待 - 见下文\n您的应用程序的设计方式不是在另一个线程正在等待它们更改事件（即您没有使用kqueue或IO完成端口移植应用程序）。\n\n---\n\nEPoll的缺点：\n1.改变监听事件的类型（例如从读事件改为写事件）需要调用epoll_ctl系统调用，而这在poll中只需要在用户空间简单的设置一下对应的掩码。如果需要改变5000个套接字的监听事件类型就需要5000次系统调用和上下文切换（直到2014年epoll_ctl函数仍然不能批量操作，每个描述符只能单独操作），这在poll中只需要循环一次pollfd结构体。\n2.每一个被accept()的套接字都需要添加到集合中，在epoll中必须使用epoll_ctl来添加–这就意味着每一个新的连接都需要两次系统调用，而在poll中只需要一次。如果你的服务有非常多的短连接它们都接受或者发送少量数据，epoll所花费的时间可能比poll更长。(解释了上文)\n3.epoll是Linux上独有的，虽然其他平台上也有类似的机制但是他们的区别非常大，例如边沿触发这种模式是非常独特的（FreeBSD的kqueue对它的支持非常粗糙）。\n什么情况下使用Epoll：\n1.你的程序通过多个线程来处理大量的网络连接。如果你的程序只是单线程的那么将会失去epoll的很多优点。并且很有可能不会比poll更好。\n2.你需要监听的套接字数量非常大（至少1000）；如果监听的套接字数量很少则使用epoll不会有任何性能上的优势甚至可能还不如poll。\n3.你的网络连接相对来说都是长连接；就像上面提到的epoll处理短连接的性能还不如poll因为epoll需要额外的系统调用来添加描述符到集合中。\n4.你的应用程序依赖于Linux上的其他特性"},{"title":"操作系统之fork","url":"/backend_knowledge_architecture/os/fork.html","content":"\npid1 = fork()\npid2 = fork()\n\nprintf(\"pid1:%d, pid2:%d\", pid2, pid2);\n\n一共创建了四个进程\n"},{"title":"操作系统之信号机制","url":"/backend_knowledge_architecture/os/signal.html","content":"信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟，\n\n阻塞信号\n信号有几种状态，首先是信号的产生 (Genertion)，而实际执行信号处理动作时，状态为递达 (Delivery)，信号在产生到递达中的状态被称为未决 (Pending)\n\n进程可以选择阻塞 (Blocking)某些信号，被阻塞的信号在产生后将保持在未决状态，直到进程解除对该信号的阻塞，才执行递达的动作\n\n![signal](https://img-blog.csdnimg.cn/img_convert/a110097ed46dba672cfdd5613699d363.png)\n\n1.4 信号的处理时机\n\n信号是在什么时候被处理的呢？是在被投递的时候处理的吗，不是的。信号是在线程将要返回用户空间之前进行处理的。线程返回用户空间有两种情况，一是从系统调用返回，二是从中断返回。返回之前，线程会检查队列里有没有信号要处理，有的话就处理。\n\n1.5 信号与多线程\n\n信号的发送既可以发送给进程，也可以发送给线程，但是同步信号(也就是和当前线程执行相关而产生的信号)应当发送给当前线程。进程发送信号可以选择不同的接口函数，有的接口是发给进程的，有的接口是发给线程的。线程信号队列中的信号只能由线程自己处理，进程信号队列中的信号由进程中的线程处理，具体是由哪个线程处理是不确定的。\n\n信号掩码(mask)的设置是线程私有的，每个线程都可以设置不同的信号掩码。\n\n信号处理方式的设置是进程全局的，后面线程设置的方式会覆盖前面线程的设置。\n\n信号处理的效果是进程全局的。"},{"title":"事务一致性总体说明","url":"/backend_knowledge_architecture/distributed_system/tx/index.html","content":"消息事务是指一系列的生产、消费操作可以要么都完成，要么都失败，类似数据库的事务。这个特性在0.10.2的版本是不支持的，从0.11版本开始才支持。华为云DMS率先提供Kafka 1.1.0的专享版服务，支持消息事务特性。      \n\n<!-- more -->\n\n支持事务消息有什么作用？消息事务是实现分布式事务的一种方案，可以确保分布式场景下的数据最终一致性。例如最常用的转账场景，小王 转账到小明，实际操作是小王账户减去相应金额，小明的账户增加相应金额，在分库分表的前提下，2个账户存储在不同的数据库中，这时需要分布式事务才能保证数据库一致性，单个数据库的事务无法保证跨库之间的原子性。如果小王账户先扣钱，再去发送消息到小明所在的数据库去通知增加钱，在没有事务消息的情况下，无论是先扣钱或者先发送通知增加钱，都会有数据不一致的问题，因为无法保证两者的原子性。而有了事务消息，可以保证发送通知与本地事务（扣钱）是一个原子操作，本地事务与发送通知可以同时成功或者同时失败，确保数据一致。\n\n除了数据最终一致性外，还实现了消息Exactly once语义。所谓Exactly once语义是消息传递语义中最难实现的一种，包括At most once：最多一次（不会重复，但是可能丢失数据）； At least once：至少投递一次（不会丢失，但是会导致重复）和Exactly  once: 刚好一次（不丢不重），也即幂等性。Kafka的幂等性可以保证生产只对一个分区实现Exactl once语义，需要多个分区也实现这个语义，还需要引入消息事务确保原子性。\n\n分布式事务介绍\n\n当前系统架构主流是分布式架构与微服务架构，在这种架构下数据源不是单一的数据库，业务逻辑往往需要在多个数据库中实现原子操作，单个数据库中的强大的本地事务无法保证多节点原子操作。 此时需要分布式事务来确保数据的一致性。目前使用较多的分布式事务解决方案有几种：\n\n1、XA事务：两阶段/三阶段提交\n\nXA是由X/Open组织提出的分布式事务的规范。XA规范主要定义了(全局)事务管理器(Transaction Manager)和(局部)资源管理器(Resource Manager)之间的接口。XA接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。实现XA事务的关键是两阶段和三阶段提交协议。\n\n两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器C和若干事务参与者Si两种角色，这里的事务参与者就是具体的数据库，协调器可以和事务参与者在一台机器上，如下图\n\n二阶段提交协议主要包括由2个阶段：第一个阶段为准备阶段（prepare），第二阶段为提交阶段。准备阶段由事务协调者向事务参与者发送prepare消息，各个参与者处理本地事务但不提交，然后向事务协调者返回事务状态。 提交阶段根据准备阶段各参与者的执行请求，协调者确定事务是提交或者回滚，向各个参与者发送命令。\n\n二阶段提交协议主要的问题是在提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样**效率及其低下**。特别是当协调者发出提交通知到部分参与者后宕机，其他参与者就会阻塞。\n\n2PC的缺点：\n\n性能问题：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作\n单点问题：协调者（TM）在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者（RM）会一直等待状态，无法完成其它操作。\n数据一致性问题：协调者如果因为网络问题或者宕机了，向一部分参与者发送了commit，另一部分还没来得及发就宕机了，就会造成数据不一致。\n局限性：只适用于数据库层面的分布式事务\n\n针对二阶段提交存在的问题，三阶段提交协议在prepare与commit阶段之间增加一个pre-commit阶段。Prepare阶段只询问参与者而不做事务，而在pre-commit阶段各个参与者才会执行本地事务但不提交。Commit阶段就是直接提交。这样做可以避免二阶段当协调者迟迟没有发出commit或者rollback通知，参与者在超时后可以自行提交或者回滚，避免阻塞事务（这是因为经过了prepare阶段已经确认了各个参与者是可以执行的，最后第三阶段直接执行即可）。 三阶段提交也存在很多问题，也**不能完全保证数据一致**，完全一致需要用到Paxos算法。\n\n优点：引进了超时机制，变相的优化了参与者同步阻塞的范围，也避免了协调者单点问题，阶段3协调者出现问题参与者也会提交事务\n\n缺点：依旧存在数据不一致问题，阶段三假设协调者发出回滚命令，而某个参与者因网络问题没有收到命令，受机制影响也会提交事务，此时数据就不一致了；同时因为多引进了一个阶段，性能方面也会有所下降\n\n### SAGE协议\n\nSaga模式\nSaga模式属于长事务解决方案，其核心思想把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块，当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。\n\nSaga模式由三部分组成：\nLLT（Long Live Transaction）：由一个个本地事务组成的事务链。\n\n本地事务：事务链由一个个子事务（本地事务）组成，LLT = T1+T2+T3+...+Ti。\n\n补偿：每个本地事务 Ti 有对应的补偿 Ci。\n\n在业务流程中，正常情况下每个参与者都在一阶段提交本地事务，按照T1->T2->T3->…->Ti的顺序执行。当出现异常时，则会发起补偿，将之前提交的事务回滚，执行顺序变成T1->T2->T3->C3->C2->C1。如下图所示：\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.61al5p9753g0.webp)\n\nSaga模式的恢复其实有两种：向后恢复（Backward Recovery）和向前恢复（Forward Recovery）\n向后恢复（Backward Recovery）：撤销掉之前所有成功子事务。如果任意本地子事务失败，则补偿已完成的事务。如异常情况的执行顺序T1,T2,T3,..Ti,Ci,...C3,C2,C1。\n\n向前恢复（Forward Recovery）：即重试失败的事务，适用于必须要成功的场景，该情况下不需要Ci。执行顺序：T1,T2,...,Tj（失败）,Tj（重试）,...,Ti。\n\nSaga模式满足事务的ACD三个特性：\n原子性：Saga协调器协调事务链中的本地事务要么全部提交，要么全部回滚\n\n一致性：Saga事务可以实现最终一致性\n\n持久性：基于本地事务，所以这个特性可以很好实现\n\n但是缺乏隔离性会引发脏读、幻读和不可重复读等问题，因此需要在业务设计上去解决这个问题，通常在应用层面通过逻辑锁或者串行化操作来确保读取数据的准确性。\n\n实现Saga的注意事项：\n\n(1)\tTi和Ci必须是幂等的。如向后恢复和向前恢复时候如果不是幂等操作会导致数据不一致。\n\n(2)\tCi必须是能够成功的，如果无法成功则需要人工介入。\n\n(3)\tTi->Ci和Ci->Ti的执行结果必须是一样的。\n\n### TCC补偿性事务解决方案\n\nTCC分别对应Try、Confirm和Cancel三种操作，含义如下：\n\n- Try：预留业务资源\n\n- Confirm：确认执行业务操作，执行事务\n\n- Cancel：取消执行业务操作\n\nTCC解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。\n\nTCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，**规避了数据库层的2PC性能低下问题**。\n\nTCC需要业务提供使用，代码侵入性强，开发复杂和成本高。\n非强一致性，属于补偿事务，实现最终一致\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.3oowdayolei0.webp)\n\n对于 TCC 的工作机制，我们举一个比较简单的例子。在一个理财 App 中，用户通过账户余额购买一个理财产品，这里涉及两个事务操作：\n\n在账户服务中，对用户账户余额进行扣减。\n\n在理财产品服务中，对指定理财产品可申购金额进行扣减。\n\n这两个事务操作在微服务架构下分别对应的是两个不同的微服务，以及独立的数据库操作，在 TCC 的工作机制中，首先针对账户服务和理财产品服务分别提供 Try、Confirm 和 Cancel 三个方法。\n\n在账户服务的 Try 方法中对实际申购金额进行冻结，Confirm 方法把 Try 方法冻结的资金进行实际的扣减，Cancel 方法把 Try 方法冻结的资金进行解冻。\n\n理财产品服务的 Try 方法中将本次申购的部分额度进行冻结，Confirm 方法把 Try 方法冻结的额度进行实际扣减，Cancel 方法把 Try 方法中冻结的额度进行释放。\n\n在一个主业务方法中，分别调用这两个服务对外提供的处理方法（资金扣减、理财产品可申购额度扣减），这两个服务处理实际业务时，会先调用 Try 方法来做资源预留，如果这两个方法处理都正常，TCC 事务协调器就会调用 Confirm 方法对预留资源进行实际应用。否则 TCC 事务协调器一旦感知到任何一个服务的 Try 方法处理失败，就会调用各个服务的 Cancel 方法进行回滚，从而保证数据的一致性。\n\n在一些特殊情况下，比如理财产品服务宕机或者出现异常，导致该服务并没有收到 TCC 事务协调器的 Cancel 或者 Confirm 请求，怎么办呢？没关系，TCC 事务框架会记录一些分布式事务的操作日志，保存分布式事务运行的各个阶段和状态。TCC 事务协调器会根据操作日志来进行重试，以达到数据的最终一致性。\n\n需要注意的是，TCC 服务支持接口调用失败发起重试，所以 TCC 暴露的接口都需要满足幂等性。\n\n### 本地消息表\n\n本地消息表的核心思想是将分布式事务拆分成本地事务进行处理，本质上是一个消息异步处理的过程，其处理流程如下：\n事务发起方在同一个事务里同时写业务表和消息表\n\n事务发起方本地有个定时任务，定时查询消息表的状态，将未处理的消息通过消息中间件发送到事务消费方进行处理。\n\n事务消费方读取消息队列中的消息，并写入本地的业务表中\n\n消息正常处理完成后，事务消费方会通过消息中间件，通知事务发起方消息已处理\n\n事务发起方在接收到结果后，会更新消息表中的状态为已处理\n\n![image](https://cdn.staticaly.com/gh/neowei1987/blog_assets@main/image.6415enrsols0.webp)\n\n从上述流程上看，本地消息表方案是基于消息中间件的可靠性来达到事务的最终一致性。在这个过程中，当中间出现一些异常时，这里进一步分析：\n当①和②处理出错，由于写业务数据和写消息表仍然在本地事务中，直接回滚即可\n\n当③处理出错，发送消息失败，由于消息数据在本地消息表中有保存，只需要通过轮询任务定时发送到事务消费方，重新读取消息处理业务即可\n\n如果是业务上⑥执行失败，事务消费方需发消息到事务发起方主动回滚事务\n\n如果是事务发起方回滚事务但是消息已经被消费了，则需要通知到事务消费方发起回滚\n\n总之，本地消息表方案整体简单易于实现，从应用设计开发的角度实现了消息数据的可靠性。但是本地消息表有以下缺点：\n消息数据和业务数据耦合，占用业务库资源\n\n消息表需要根据具体的业务场景制定，不具备通用性\n\n性能上受限于数据库的性能，高并发场景下会有性能瓶颈\n\n只适用于最终一致性的场景\n\n### 一致性事务消息\n\n基于消息中间件的事务消息来完成分布式事务。事务消息可以确保本地执行事务与消息发送是原子的：先发送一条消息到消息中间件（例如RabbitMQ)，然后执行本地事务(本地DB操作），当本地事务成功后再发送提交确认（Confirm)到消息中间件，然后这条消息才能被其他业务消费者所能感知，从而确保原子性；如果本地事务失败，则Rollback消息中间件。\n\n 所以，我们这里最核心的就是A银行通过本地事务保证日志记录+后台线程轮询保证消息不丢失。B银行通过本地事务保证日志记录从而保证消息不重复消费！B银行在回调A银行的接口时会通知处理结果，如果转账失败，A银行会根据处理结果进行回滚。\n\n rabbit MQ通过query本地事务状态来实现消息事务。\n\n ---\n\n当然，分布式事务最好的解决方案是尽量避免出现分布式事务！\n\nkafka实现的多条消息的事务性，要么一起被消费到，要么一起丢失。\n\n参考：\n\nhttps://blog.csdn.net/weixin_39785970/article/details/110844239\nhttps://xie.infoq.cn/article/7b55d37b619256f9fa4ca4777\nhttps://www.modb.pro/db/424506","tags":["一致性协议"]},{"title":"Paxos协议介绍","url":"/backend_knowledge_architecture/distributed_system/tx/paxos.html","content":"\nBasic-Paxos解决的问题：在一个分布式系统中，如何就一个提案达成一致。\n\n<!-- more -->\n\n需要借助两阶段提交实现：\n\nPrepare阶段：\n\nProposer选择一个提案编号n并将prepare请求发送给 Acceptor。\n\nAcceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息，则Acceptor将自己上次接受的提案回复给Proposer，并承诺不再回复小于n的提案。\n\nAccept阶段：\n\n当一个Proposer收到了多数Acceptor对prepare的回复后，就进入批准阶段。它要向回复prepare请求的Acceptor发送accept请求，包括编号n和根据prepare阶段决定的value（如果根据prepare没有已经接受的value，那么它可以自由决定value）。\n\n在不违背自己向其他Proposer的承诺的前提下，Acceptor收到accept请求后即接受这个请求。\n\n---\n\nMulit-Paxos\nMulit-Paxos解决的问题：在一个分布式系统中，如何就一批提案达成一致。\n\n当存在一批提案时，用Basic-Paxos一个一个决议当然也可以，但是每个提案都经历两阶段提交，显然效率不高。Basic-Paxos协议的执行流程针对每个提案（每条redo log）都至少存在三次网络交互：1. 产生log ID；2. prepare阶段；3. accept阶段。\n\n\n所以，Mulit-Paxos基于Basic-Paxos做了优化，在Paxos集群中利用Paxos协议选举出唯一的leader，在leader有效期内所有的议案都只能由leader发起。\n\n这里强化了协议的假设：即leader有效期内不会有其他server提出的议案。因此，对于后续的提案，我们可以简化掉产生log ID阶段和Prepare阶段，而是由唯一的leader产生log ID，然后直接执行Accept，得到多数派确认即表示提案达成一致（每条redo log可对应一个提案）。\n\n---\n","tags":["一致性协议"]},{"title":"RAFT协议介绍","url":"/backend_knowledge_architecture/distributed_system/tx/raft.html","content":"\nhttps://blog.csdn.net/yangmengjiao_/article/details/120191314\n\nraft将共识问题分解成两个相对独立的问题，leader election，log replication。\n\n<!-- more -->\n### leader选举\n\nelection timeout\n\nThe election timeout is the amount of time a follower waits until becoming a candidate.\n\n选举时间到了之后，starts a new election term\n\nIf the receiving node **hasn't voted yet in this term** then it votes for the candidate...\n\nheartbeat timeout\n\nMESSAGE: Append Entries\n\nThis election term will continue until a follower stops receiving heartbeats and becomes a candidate.\n【如果一个follower没有及时收到来自leader的heartbeat，那他就会成为一个candidate，申请成为leader】\n\n【每一个任期，进行多数派选举】\n\n可以看出所有节点启动时都是follower状态；在一段时间内如果没有收到来自leader的心跳，从follower切换到candidate，发起选举；如果收到majority的造成票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到follower。\n\n总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。\n\nleader election约束：\n\n1. 同一任期内最多只能投一票，先来先得\n2. 选举人必须比自己知道的更多（比较term，log index）\n\n### log replication\n\n1. first appended to the leader's log\n    [set 5， add 2]\n2. then the change is sent to the followers on the next heartbeat by **Append Entries**\n3. 如果多数accept, 则commit； 否则保持为uncommited\n\nleader append log entry\nleader issue AppendEntries RPC in parallel\nleader wait for majority response\nleader apply entry to state machine\nleader reply to client\nleader notify follower apply log\n\n网络恢复后，如果有更高任期的leader， 则step down。 之前的需要被rollback\n\n流程是先选举出leader，然后leader负责复制、提交log（log中包含command）\n\n为了在任何异常情况下系统不出错，即满足safety属性，对leader election，log replication两个子问题有诸多约束\n\nlog replication约束：\n\n一个log被复制到大多数节点，就是committed，保证不会回滚\nleader一定包含最新的committed log，因此leader只会追加日志，不会删除覆盖日志\n不同节点，某个位置上日志相同，那么这个位置之前的所有日志一定是相同的\nRaft never commits log entries from previous terms by counting replicas.\n","tags":["一致性协议"]},{"title":"cpp语言-内存模型","url":"/backend_knowledge_architecture/language/cpp/base.html","content":"\nvirtual destructor()\n\n将Base析构函数声明为virtual函数时，执行delete base ;语句就会删除subModel的对象；\n\nexception\n\ntry catch\n\n![CPP内存模型](https://img-blog.csdnimg.cn/bf280dc2bc534d07a21a559aa6f643b6.png)\n\nvoid *operator new (size_t size,void *pbuffer)\n\n可以做某一个类的静态成员函数\n\n参考：\nhttps://www.toutiao.com/article/6956573052414984712/?wid=1670850368129","tags":["cpp"],"categories":["编程语言"]},{"title":"java语言-classloader","url":"/backend_knowledge_architecture/language/java/class_load.html","content":"\nbootstrap classloader\nextension classloader\napplication classloader\ncustom classloader\n\n双亲委派模型\n\n当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载\n\n参考：\nhttps://blog.csdn.net/w1lgy/article/details/126434976\n\n","tags":["java"],"categories":["编程语言"]},{"title":"问题排查系统命令","url":"/backend_knowledge_architecture/language/java/cpu_mem.html","content":"\ntop 查看cpu使用率，重点关注：内核还是用户态、load值\n\ncpu使用率2500%左右(40核系统，但平时才300%左右)，并确认当前系统load值是否很高，如果很高(超过cpu核数)，说明当前系统出现大量线程排队现象，如果load比较低但cpu很高，说明系统运行很顺畅，而是业务比较繁忙导致。\n\n\ntop -H pid 查看哪些线程cpu占比高\n\njstat -gc pid 查看java内部状态\n\njstack 查看调用stack \n\nstrace 查看系统调用\n\n查看函数/接口耗时\n\n调整jvm 内存参数，调整gc方式（cms->g1)\n\narthas\n\ndashboard：当前系统的实时数据面板\n\nthread：查看当前 JVM 的线程堆栈信息\n\njvm：查看当前 JVM 的信息\n\nsc：查看JVM已加载的类信息\n\nsm：查看已加载类的方法信息\n\njad：反编译指定已加载类的源码\n\nclassloader：查看classloader的继承树，urls，类加载信息，使用classloader去getResource\n\nmonitor：方法执行监控\n\nwatch：方法执行数据观测\n\ntrace：方法内部调用路径，并输出方法路径上的每个节点上耗时\n\nstack：输出当前方法被调用的调用路径\n\ntt：方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\n\nreset：重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类\n\nquit：退出当前 Arthas 客户端，其他 Arthas 客户端不受影响\n\nshutdown：关闭 Arthas 服务端，所有 Arthas 客户端全部退出\n\n---\n\nmemory 各种查看\n\n---\n\nnetstat 查看timewait closewait, 查看数据包长什么样，是否符合预期等\n"},{"title":"java语言-object","url":"/backend_knowledge_architecture/language/java/object.html","content":"\nequals VS  == \n\n（1）对象类型不同(一个是object的成员方法，一个是操作符)\n\n（2）比较的对象不同 一个是对象内容是否ok， 一个是引用或者地址是否ok\n\n（3）执行速度不同\n\n在每个类中，在重写equals方法的时侯，一定要重写hashcode方法。\n\n根据Object规范，规范约定：\n\n如果两个对象通过equals方法比较是相等的，那么它们的hashCode方法结果值也是相等的。\n\n如果两个对象通过equals方法比较是不相等的，那么不要求它们的hashCode方法结果值是相等的。\n\n当在一个应用程序执行过程中， 如果equals方法比较中没有修改任何信息，那么在同一个对象上重复调用hashCode方法时，它必须始终返回相同的值。但如果从一个应用程序到了另一个应用程序，两个应用程序汇中调用hashCode方法的返回值可以是不一致的。","tags":["java"],"categories":["编程语言"]},{"title":"java语言-reflect","url":"/backend_knowledge_architecture/language/java/reflect.html","content":"\nhttps://cloud.tencent.com/developer/article/1856972\n\n优点：\n\n1.能够运行时动态地获取类的实例，提高灵活性\n\n2.与动态编译结合\n\n缺点：\n1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。\n\n解决方案：\n\n1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；\n\n2、多次创建一个类的实例时，有缓存会快很多\n\n3、ReflflectASM工具类，通过字节码生成的方式加快反射速度\n\n2）相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）","tags":["java"],"categories":["编程语言"]},{"title":"java语言-线程同步","url":"/backend_knowledge_architecture/language/java/sync.html","content":"### volatile\n\nvolatile 的三点：\n（1）保证可见性（ 主内存 VS JAVA内存）\n（2）禁止指令重排\n\nInstance = new Singleton();可以分为以下三步：\nMemory = allocate();//1.分配对象内存空间\nInstance(memory)//2.初始化对象\nInstance = memeory //3.设置初始化的对象指向刚分配的内存地址，此时instacne ! =null\n\n步骤2和步骤3不存在数据依赖关系，所以这种重排序是允许的\n\nMemory = allocate();\nInstance = memeory\nInstance(memory)//2.初始化对象\n\n所以这个时候出现的问题为多个线程在这里获得单例对象，第一个访问者在instance = new Singleton();这一步骤时由于指令重排序，底层先给对象分配好了地址，此时不为空，这个时候其他线程访问，instacne不为空，但是得不到实例对象。\n\n（3）不保证原子性\n\nvolatile的应用场景\n\nDCL（Double Check Lock双端检索机制）\n\n双端检索机制不一定安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排。 在某一个线程执行到第一次检测时，此时instance不为null，但是insatnce的引用对象可能没有初始化完成\n\n如何保证原子性\n\n 这种问题可以使用synchronized 或者使用原子变量 来解决。原子变量通过调用unsafe类的cas方法实现了原子操作，由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题。\n\n\n### synchronized 的锁升级过程\n\n无锁-》偏向锁-》轻量级CAS自旋锁-》重量级锁\nhttps://blog.csdn.net/weixin_45606067/article/details/126766885\n\n\n### synchronized 与 lock的区别\n\n区别如下：\n \n1.Lock是显示锁（手动开启和关闭锁）, synchronized时隐式锁，出来作用域自动释放\n \n2.Lock只有代码块锁，synchronized有代码块锁和方法锁\n \n3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供了更多子类）\n \n4.lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；\n \n5.异常是否释放锁： \n    synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）\n \n6.是否响应中断 \n    lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；\n\n7.是否知道获取锁 \n    Lock可以通过trylock来知道有没有获取锁，而synchronized不能；\n\n8.Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）\n\n9.在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。\n\n10.synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度\n\nAQS\n\ncondtion是通过Reentlock的newCondtion方法创建出来的\n\nrwlock也是基于AQS实现的读写锁\n\nSemaphore 是一套单独的机制，用来实现信号量，多个线程共同访问一个资源。\n","tags":["java"],"categories":["编程语言"]},{"title":"java语言-spring","url":"/backend_knowledge_architecture/language/java/spring.html","content":"### spring cloud 组件\n\neuraka\n\nrobbin\n\nhystrix\n\nZuul\n\nconfig\n\nFeign\n\n\n\n### AOP 切面编程\n\n在不侵入业务代码的情况下，实现日志打印、登录鉴权等功能。\n\n动态代理技术，标准JDK动态代理 OR CGLIB代理\n\n### spring VS  spring MVC VS  spring BOOT\nSpring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。\n\nSpring MVC的功能Spring MVC提供了一种轻度耦合的方式来开发web应用。Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。\n\n\n### IOC \n\ninversion of control\n\nDI 依赖注入\n\n第三方容器来管理，底层实现是基于反射。\n\n### 循环依赖的解决\n\n通过三个map（一级，二级，三级）创建中的对象数组\n只能解决通过set + 单例模式； 无法解决：基于构造函数的循环依赖、通过set + 多例模式","tags":["java"],"categories":["编程语言"]},{"title":"回溯-序列切分","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/cut_sum.html","content":"\n给定数字N和M，你需要从数字1到N的序列中添加+或-，使得序列的和等于M。\n\n打印出所有满足此关系的序列，例如，给定N=4 M=6,则满足条件得序列是1-2+3+4=6(一定存在此序列)\n\n```cpp\n\nvoid dfs(int u) {\n    //剪枝，如果当前明确的sum已经超了，则直接return\n    if (exceed_already()) {\n        return false;\n    }\n\n    if (u == n) {\n        //check 是否满足\n        //cmd存了切割位置，我们按照cmd寸的切割位置，把字符串切割出来，转为整数，然后求和\n        return true;\n    }\n\n    //分割\n    cmd[u] = 1;\n    if (dfs(u + 1)) {\n        return true;\n    }\n    \n    //不分割\n    cmd[u] = 0;\n    return dfs(u + 1);\n}\n\n```"},{"title":"股票买卖系列-通用解法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/stock_common.html","content":"\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）\n\n<!-- more -->\n\n#### 解题思路\n\n动态规划有三要素：阶段、状态和决策。\n\n阶段：\n\n把一个问题的过程，恰当地分为若干个相互联系的阶段，以便于按一定的次序去求解。描述阶段的变量称为阶段变量。阶段的划分，一般是根据**时间和空间的自然特征**来进行的，但要便于问题转化为多阶段决策。\n\n状态：\n\n表示每个阶段开始所处的自然状况或客观条件。通常一个阶段有若干个状态（也可能只有一个状态），描述过程状态的变量称为状态变量。\n\n决策：\n\n表示当过程处于某一阶段的某个状态时，可以作出不同的决定，从而确定下一阶段的状态，这种决定称为决策。\n\n一般流程：\n\n划分阶段 -> 正确选择状态变量 -> 确定状态转移方程\n\n-> 确定阶段指标函数和最优指标函数，建立动态规划基本方程。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int dp[100010][3][2];\n\n    int maxProfit(vector<int>& prices) {\n        //状态机dp\n        //阶段----当前是第i天，也就是时间。\n        //状态：剩余交易次数、股票持有状态下的股票收益\n        //决策：卖出股票、啥也不做、买入股票\n        int n = prices.size();\n        int k = 2;\n        //base\n        for (int k = 0; k <= 2; k++) {\n            dp[0][k][0] = 0;\n            dp[0][k][1] = -inf;\n        }\n\n        for (int i = 0; i <= n; ++i) {\n            dp[i][0][0] = 0;\n            dp[i][0][1] = -inf;\n        }\n        \n        for (int i = 1; i <= n; ++i) {\n            for (int k = 1; k <= 2; k++) {\n                              //前一天没有股票；昨天有股票，今天卖出；\n                dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i - 1]);\n                                //前一天有股票；昨天没有股票，今天买入\n                dp[i][k][1] =  max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i - 1]); \n            }\n        }\n\n        return dp[n][2][0];\n    }\n};\n```\n","tags":["动态规划"],"categories":["数据结构与算法"]},{"title":"股票买卖系列-仅买卖一次","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/greedy/stock_1time.html","content":"\n## 题目描述\n\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？\n\n例如一只股票在某些时间节点的价格为[9, 11, 8, 5, 7, 12, 16, 14]。\n\n如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。\n\n样例\n输入：[9, 11, 8, 5, 7, 12, 16, 14]\n\n输出：11\n\n## 思路\n\n1. 暴力做法-$O(n^2)$\n2. 调整迭代顺序（找最大值改为着最小值）本质：减元素会让之前找到的的最值失效；而加元素只需要拿新加的元素与前最值比较即可\n\n## 最直观的思路-暴力做法\n\n```cpp\nclass Solution {\npublic:\n    int maxDiff(vector<int>& nums) {\n        int min_price = INT_MAX;\n        int max_profit = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j>) {\n                max_profit = max(max_profit, nums[j] - nums[i]);\n            }\n        }\n        return max_profit;\n    }\n};\n```\n\n## 优化思路\n\n你需要知道的两个前置技巧：\n\n**双层定值拆分原则**：当涉及两层循环时，可以将外层循环变量当成定值，对循环的整体结构进行整体审视，确定是否可以优化掉一层。 把外层变量当成定植之后，观察内层循环导致在干嘛。\n\n**最值计算的累积效应**：当涉及最值计算时，减元素会让之前找到的的最值失效；而加元素只需要拿新加的元素与前最值比较即可\n\n我们的优化，需要你知晓上面的两个技巧，然后做适当的**启发式思考**，具体过程我已经呈现在下面的注释中了。\n\n```cpp\nclass Solution {\npublic:\n    int maxDiff(vector<int>& nums) {\n        int min_price = INT_MAX;\n        int max_profit = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            //如果把i当作定值，那么下面的这层循环是在寻找num[j]的最大值\n            //i每增加1,内层循环会减少一个元素，根据之前的启发式，减少元素会让之前计算的最大值失效，所以不得不重新计算最大值；\n            //我们尝试着调整迭代顺序。\n            for (int j = i + 1; j < nums.size(); ++j>) {\n                max_profit = max(max_profit, nums[j] - nums[i]);\n            }\n        }\n        return max_profit;\n    }\n};\n```\n\n那么，我们更换迭代顺序之后。\n\n```cpp\n\nclass Solution {\npublic:\n    int maxDiff(vector<int>& nums) {\n        int min_price = INT_MAX;\n        int max_profit = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            //调整迭代顺序后，如果把i当作定值，那么下面的这层循环是在寻找num[j]的最小值\n            //i每增加1,内层循环会增加一个元素，增加一个元素后，只需比较新的元素与之前的最小值；\n            //便可以得到新的最小值，而不需要循环查找\n            //nums[i]是每次的新元素\n            /*\n            写法1\n            寻找哪一天买入【调整顺序】\n            for (int j = 0; j < i - 1; ++j>) {\n                max_profit = max(max_profit, nums[i] - nums[j]);\n            }\n            */\n            \n            //写法2\n            for (int j = 0; j < i - 1; ++j>) {\n                min_price = max(min_price, nums[j]);\n            }\n            max_profit = max(max_profit, nums[i] - min_price);\n\n            //写法3\n            min_price = min(min_price, nums[i]); \n            max_profit = max(max_profit, nums[i] - min_price);\n        }\n        return max_profit;\n    }\n};\n```\n","tags":["贪心"],"categories":["数据结构与算法"]},{"title":"股票买卖系列-无限买卖","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/greedy/stock_inf_time.html","content":"\n## 题目描述\n\n假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益\n\n1. 你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票\n2. 如果不能获取收益，请返回0\n3. 假设买入卖出均无手续费\n\n## 思路\n\n我是上帝，要想利润最大，就是吃到所有的波段！低买高卖！\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        if (prices.empty()) {\n            return res;\n        }\n        for (int i = 1; i < prices.size(); ++i) {\n            if (prices[i] > prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            } \n        }\n\n        return res;\n    }\n};\n```","tags":["贪心"],"categories":["数据结构与算法"]},{"title":"矩阵旋转90度","url":"/backend_knowledge_architecture/structure_algorithm/structures/array/rotate_90.html","content":"\n矩阵90度旋转\n\n<!-- more -->\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int> > rotateMatrix(vector<vector<int> > mat, int n) {\n        //水平翻转\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                swap(mat[i][j], mat[n - 1 - i][j]);\n            }\n        }\n\n        //对角线翻转\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                swap(mat[i][j], mat[j][i]);\n            }\n        }\n\n        return mat;\n    }\n};\n```\n","categories":["数据结构与算法"]},{"title":"最大括号长度","url":"/backend_knowledge_architecture/structure_algorithm/structures/stack/max_kh_len.html","content":"\n给出一个长度为 n 的，仅包含字符 '(' 和 ')' 的字符串，计算最长的格式正确的括号子串的长度。\n\n例1: 对于字符串 \"(()\" 来说，最长的格式正确的子串是 \"()\" ，长度为 2 .\n例2：对于字符串 \")()())\" , 来说, 最长的格式正确的子串是 \"()()\" ，长度为 4 .\n\n<!-- more -->\n\n```cpp\nclass Solution {\npublic:\n    int longestValidParentheses(string str) {\n        stack<int> s;\n        s.push(-1); \n        int res = 0;\n\n        for (int i = 0; i < str.length(); ++i) {\n            if (str[i] == '(') {\n                s.push(i);\n            } else { //')'\n                s.pop();\n                if (s.empty()) { //新的开始, 不匹配的“)”\n                    s.push(i);\n                } else {\n                    res = max(res, i - s.top());\n                }\n            }\n        }\n\n        return res;\n    }\n};\n```","tags":["字节跳动"],"categories":["数据结构与算法"]},{"title":"获取丢失的数字","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/getMissingNumber.html","content":"\n## 题目描述\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。\n\n在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n样例\n输入：[0,1,2,4]\n\n输出：3\n\n## 实现思路\n\n根据题目描述容易得到：如果把miss的数字补齐，那么我们可以得到序列：$1,2,3,...n$\n\n递增，数组，容易想到是否可以用二分查找。\n\n## 代码实现\n\n```cpp\nclass Solution {\npublic:\n   int getMissingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int sum = 0;\n        for (auto x: nums) {\n            sum += x;\n        }  \n        return (n * (n + 1) >> 1) - sum;\n    }\n};\n\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int j = nums.size();\n        int i = 0;\n        while (i < j) {\n            int  m = (i + j) >> 1;\n            if (m < nums.size() && nums[m] == m) { //如果是合法的，说明需要往后find.\n                i = m + 1;\n            } else {\n                j = m;\n            }\n        }\n        \n        return i;\n    }\n};\n\n```\n\n相关题目\n\n### 寻找重复\n\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。\n\n假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。\n\n1.不能更改原数组（假设数组是只读的）。\n2.只能使用额外的 O(1) 的空间。\n3.时间复杂度小于 O(n2) 。\n4.数组中只有一个重复的数字，但它可能不止重复出现一次\n\n思路：\n\n该题目约束比较多，不能更改原数组，意味着不可以使用数组自hash或者原地交换；\n\n限制了空间，意味着不可以使用某些排序算法或者使用hash map。\n\n可以选择的时间复杂度: $O(n)$、$O(n * lgn)$\n\n可以考虑二分，二分的话有两种：二分数组、二分答案\n\n显然我们的数组并没有排序，所以更有可以是二分答案。\n\n```cpp\nclass Solution\npublic: \n    int findDuplicate(vectorzint>&nums){\n    int n=nums.size();\n    int l=1,r=n-1,ans=-1;\n    while(l<=r)\n    {\n            int mid=(l+r)/2;int cnt=0;\n            for(int i=0;i<n;i++){\n                cnt=cnt+(nums [i]<=mid)\n            }\n            if(cnt<=mid)\n                l=mid+1;\n            else {\n                r=mid-1;\n                ans=mid\n            }\n    }\n    return ans\n}\n```","tags":["二分"],"categories":["数据结构与算法"]},{"title":"二分-局部最小","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/binary/local_min.html","content":"\n寻找数组局部最小值\n\n解答思路：\n\n只要有最小值，那我就可以找到。\n\na[0] <= a[1], 则a0就是极小值；\na[n - 2] >=  a[n - 1], 则a[n-1]就是极小值\n\n否则，就如图(一定有最小值）：\n\n![](https://img-blog.csdnimg.cn/a05469ef1d94408cbba43e2562274c07.png)\n"},{"title":"双指针-集合交集","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/intersect.html","content":"\n两个集合的交集\n\n（1）排序 + 双指针\n（2）hashmap + counter\n\n如果内存放不下如何办？\n\n通过归并外排将两个数组排序后再使用排序双指针查找\n\n最终，集合1和集合2的交集，是x与y与z的并集，即集合{3,5,7,30,50,70}。\n\n画外音：多线程、水平切分都是常见的优化手段。\n\nskiplist 跳表来维护有序结构，搜索引擎如此做\n"},{"title":"二叉搜索树遍历-获取第k个节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/tree/binary_tree/kthNode.html","content":"\n## 题目描述\n\n给定一棵二叉搜索树，请找出其中的第k小的结点。\n\n你可以假设树和k都存在，并且1≤k≤树的总结点数。\n\n样例\n输入：root = [2, 1, 3, null, null, null, null] k = 3\n\n输出：3\n\n## 实现思路\n\n首先，我们需要有一个认知：二叉搜索树等同于一个有序数组。\n\n然后基于上面的认知去思考：我如何在一个有序数组中找到第k小的元素。\n\n所以，我们需要中序遍历BST，在遍历过程中对访问的元素进行计数即可，当计数到k时，便是我们要找的元素。\n\n这里科普一个常识：**对于BST，我们一定是中序遍历**！否则就浪费了BST有序的特性了。\n\n## 代码实现\n\n``` cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int k;\n    TreeNode* dfs(TreeNode* root) {\n        if (root->left) {\n            auto r = dfs(root->left);\n            if (r) return r;\n        }\n        if (--k == 0) return root;\n\n        if (root->right) return dfs(root->right);\n        return nullptr;\n    }\n\n    TreeNode* kthNode(TreeNode* root, int _k) {\n        k = _k;\n        return dfs(root);    \n    }\n};\n```\n","tags":["二叉树"],"categories":["数据结构与算法"]},{"title":"操作系统之文件系统介绍","url":"/backend_knowledge_architecture/os/fs.html","content":"\n![fd-inode](https://img-blog.csdnimg.cn/img_convert/b7691ff4fedc7a7abf5c35ba1869e550.png)\n\nlinux内核会为每一个进程创建一个task_truct结构体来维护进程信息，称之为 进程描述符，该结构体中 指针\n\nstruct files_struct *files\n\n\n指向一个名称为file_struct的结构体，该结构体即 进程级别的文件描述表。\n\n它的每一个条目记录的是单个文件描述符的相关信息\n\n---\n\n系统级别的文件描述符表\n内核对系统中所有打开的文件维护了一个描述符表，也被称之为 【打开文件表】，表格中的每一项被称之为 【打开文件句柄】，一个【打开文件句柄】 描述了一个打开文件的全部信息。\n主要包括：\n\n当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）\n打开文件时所使用的状态标识（即，open()的flags参数）\n文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）\n与信号驱动相关的设置\n对该文件i-node对象的引用\n文件类型（例如：常规文件、套接字或FIFO）和访问权限\n一个指针，指向该文件所持有的锁列表\n文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳\n\n---\n\nInode表\n每个文件系统会为存储于其上的所有文件(包括目录)维护一个i-node表，单个i-node包含以下信息：\n\n文件类型(file type)，可以是常规文件、目录、套接字或FIFO\n访问权限\n文件锁列表(file locks)\n文件大小\n等等\ni-node存储在磁盘设备上，内核在内存中维护了一个副本，这里的i-node表为后者。副本除了原有信息，还包括：引用计数(从打开文件描述体)、所在设备号以及一些临时属性，例如文件锁。\n\n---\n\n为什么inode中没有文件名？\n\n目录，也是文件。 文件内容是一个列表，列表项为：文件名 + inode\n"},{"title":"java语言-gc","url":"/backend_knowledge_architecture/language/java/gc.html","content":"\n在Java语言中，可作为GC Roots的对象包含以下几种：\n\n虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象)\n方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象)\n方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象)\n本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象)\n\n可以理解为:\n\n(1)首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。\n\n(2)第二种是我们在类中定义了全局的静态的对象，也就是使用了static关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。\n\n(3)第三种便是常量引用，就是使用了static final关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。最后一种是在使用JNI技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用native方法，jvm内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。\n\n先通过gc-root可达性分析给对象标记，然后执行finalize() 再给对象一次机会。\n\n---\n\n1、CMS\n\nCMS(Concurrent Mark Sweep)，我们可以轻易地从命名上看出，它是一个并发的，然后是基于标记——清理的垃圾回收器，它清理垃圾的步骤大致分为四步：\n\n初始标记（标记GCRoot能够关联到的对象）\n并发标记（\n重新标记\n并发清理(会产生浮动垃圾)\n\n\n初始标记只要是找到GC Roots，所以是一个很快的过程，并发标记和用户线程一起，通过GC Roots找到存活的对象，重新标记主要是修复在并发标记阶段的发生了改变的对象，这个阶段会Stop the World；\n\n并发清理则是保留上一步骤标记出的存活对象，清理掉其他对象，正因为采用并发清理，所以在清理的过程中用户线程又会产生垃圾，而导致浮动垃圾，只能通过下次垃圾回收进行处理；\n\n因为cms采用的是标记清理，所以会导致内存空间不连续，从而产生内存碎片\n\n此处要清楚，CMS的垃圾回收的内存模型还是以我们常用的新生代，老年代的结构，如下图所示：\n\n2.G1\n\nG1(Garbage-First)，以分而治之的思想将堆内存分为若干个等大的Region块，虽然还是保留了新生代，老年代的概念，但是G1主要是以Region为单位进行垃圾回收，G1的分块大体结果如下图所示：\n\n\nG1垃圾回收器的它清理垃圾的步骤大致分为四步：\n\n初始标记\n并发标记\n最终标记\n复制回收\n\n\n初始标记和并发标记和CMS的过程是差不多的，最后的筛选回收会首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划\n\n因为采用的标记——整理的算法，所以不会产生内存碎片，最终的回收是STW的，所以也不会有浮动垃圾，Region的区域大小是固定的，所以回收Region的时间也是可控的\n\n同时G1 使用了Remembered Set来避免全堆扫描，G1中每个Region都有一个与之对应的RememberedSet ，在各个 Region 上记录自家的对象被外面对象引用的情况。当进行内存回收时，在GC根节点的枚举范围中加入RememberedSet 即可保证不对全堆扫描也不会有遗漏。\n","tags":["java"],"categories":["编程语言"]},{"title":"回溯系列-组合排列","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/back_tracking/combination_permutation.html","content":"\n## N选K组合（无重复版）\n\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n### N选K组合解题思路\n\n状态：第i个\n\n选择: n-i个选择\n\n路径：path选择\n\n结果集：列表\n\n结束条件： 找到所有的组合； path路径到了k\n\n```cpp\n\n// u 没有实际作用，可以通过path来替代；\nvector<int> path;\nvoid dfs(int u, int start_idx) {\n    if (u == k) {\n        //path\n        return;\n    }\n\n    //未剪枝版\n    for (int i = start_idx; i <= n; ++i) {\n        path.push_back(i);\n        dfs(u + 1, i + 1) ; //注意i+1\n        path.pop_back();\n    }\n\n    //带剪枝版(如果i过大的话，剩下的元素会不足k个)\n    for (int i = start_idx; i <= n - (k - path.size()); ++i) {\n        path.push_back(i);\n        dfs(u + 1, i + 1);\n        path.pop_back();\n    }\n\n}\n\ndfs(0, 0);\n```\n\n## 和为n的K个数的组合\n\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n### N选K组合的和解题思路\n\n状态：第i个\n\n选择: 9-i个选择\n\n路径：path选择\n\n结果集：列表\n\n结束条件： 找到所有的组合； path路径到了k，sum ok\n\n```cpp\n\nvector<int> path;\nvoid dfs(int u, int sum, int start) {\n    if (sum > n) {return;}\n    if (u == k) {\n        if (sum == 0) {\n            res.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= 9 - (k - path.size()) + 1; i++) {\n        path.push_back(i);\n        dfs(u + 1, sum - i, i + 1);\n        path.pop_back();\n    }\n}\n\ndfs(0, n, 0);\n```\n\n## 和为N的组合（无限选取版）\n\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n\n解集不能包含重复的组合。\n\n### candidates找和为target解题思路\n\n状态：第i个\n\n选择: 每次都有N个选择\n\n路径：path选择\n\n结果集：列表\n\n结束条件： 找到所有的组合； path路径到了k，sum ok\n\n```cpp\n    //如果是一个集合来求组合的话，就需要startIndex\n    void dfs(vector<int>& d, int u, int sum, int start) {\n        if (sum > target) {return;}\n        if (sum == target) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = start; i < n; ++i) {\n            path.push_back(d[i]);\n            dfs(d, u + 1, sum + d[i], i); //可以重复使用,\n            path.pop_back();\n        }\n    }\n\n    //剪枝优化： 排序(从大到小排序），提前终止，判定条件\n    void dfs(vector<int>& d, int u, int sum, int start) {\n        if (sum > target) {return;}\n        if (sum == target) {\n            res.push_back(path);\n            return;\n        }\n\n        //排序后，可以剪枝，提前终止本层（因为后面的更小了，只要i不可以，后面的更不可以，可以提前终止）\n        for (int i = start; i < n && sum+d[i] <= target; ++i) {\n            path.push_back(d[i]);\n            dfs(d, u + 1, sum + d[i], i); //可以重复使用\n            path.pop_back();\n        }\n    }\n```\n\n## 和为N的组合（有重复，仅用一次）\n\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n所有数字（包括目标数）都是正整数。解集不能包含重复的组合。\n\n//需要进行排序预处理，从大到小\n\n```cpp\nvoid dfs(vector<int>& d, int u, int sum, int start_index) {\n        if (sum > target) {return;}\n        if (sum == target) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = start_index; i < n && sum + d[i] <= target; ++i) {\n            //在同一层次上，相同的元素不重复选取（因为前面的已经处理过了）\n            if (i >= 1 && d[i] == d[i - 1] && used[i - 1] == false) {continue;}\n            path.push_back(d[i]);\n            used[i] = true;\n            dfs(d, u + 1, sum + d[i], i + 1);\n            used[i] = false;\n            path.pop_back();\n        }\n    }\n```\n\n## 所有数字的排列（无重复版）\n\n给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。\n\n### 解法1 给坑u找元素i\n\n```cpp\n    void dfs(vector<int>& d, int u) {\n        if (u == n) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = 0; i < n; ++i ) {\n            if (used[i]) continue;\n            path.push_back(d[i]);\n            //path[u] = nums[i]; 这样子其实也可以，这样子反而不需要还原现场；因为u的设置顺序是从大到小\n            used[i] = true;\n            dfs(d, u + 1);\n            used[i] =false;\n            path.pop_back();\n        }\n    }\n```\n\n### 解法2: 特定元素(u)选择坑位（i)\n\n//后面可以选择的坑原来越少了； u是第一个元素；\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> path;\n    \n    void dfs(vector<int>& nums, int u, int state) {\n        if (u == int(nums.size())) {\n            res.push_back(path);\n            return;\n        }\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            if (!(state >> i & 1)) {\n                //这一步骤是关键，为第u号元素找可以选择的坑位\n                path[i]= nums[u];\n                dfs(nums, u + 1, state + (1 << i));\n            }\n        }\n    }\n    \n    vector<vector<int>> permutation(vector<int>& nums) {\n        path.resize(nums.size());\n        sort(nums.begin(), nums.end());\n        dfs(nums, 0, 0, 0);\n        return res;\n    }\n};\n\n注意到前面的state与path的配合使用，有两个目的：保存当前坑位存了哪些元素了，保存坑位的使用情况。\n有没有什么手段呢？ path可以d来替代；d的前半部分作为坑使用，后半部分保持原功能； 但是坑占用之前，需要保存其原值，一举两得。所以就有了下面这种解法。\n\n    //u代表元素。\n    void dfs(vector<int>& d, int u) {\n        if (u == n) {\n            res.push_back(d);\n            return;\n        }\n\n        //这一步骤是关键，为第u号元素找可以选择的坑位\n        for (int i = u; i < n; ++i ) {\n            swap(d[u], d[i]);   //将u元素放入i号坑。\n            dfs(d, u + 1);  \n            swap(d[u], d[i]);\n        }\n    }\n\n```\n\n## 所有数字的排列（数字重复）\n\n输入一组数字（可能包含重复数字），输出其所有的排列方式。\n\n样例\n输入：[1,2,3]\n\n输出：\n      [\n        [1,2,3],\n        [1,3,2],\n        [2,1,3],\n        [2,3,1],\n        [3,1,2],\n        [3,2,1]\n      ]\n\n### 为坑（u）选择合适的元素（i）\n\n```cpp\n    //sort first\n    void dfs(int u) {\n        if (u == nums.size()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (i > 0 &&  nums[i] == nums[i - 1] && !used[i - 1]) continue; //两次访问，第一次访问是used[i-1]=true,会加到path中; 第二次访问used[i-1]=false，会被跳过。\n            if (used[i]) continue;\n            used[i] = true;\n            //为新的坑，选择了一个新的元素\n            path.push_back(nums[i]);\n            dfs(u + 1);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\n```\n\n### 特定元素(u)选择坑位（i)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> path;\n    \n    void dfs(vector<int>& nums, int u, int start, int state) {\n        if (u == int(nums.size())) {\n            res.push_back(path);\n            return;\n        }\n        \n        //对于重复元素，则放在前面的元素后面；否则从0开始\n        if (!u || nums[u] != nums[u - 1]) start = 0;\n                \n        for (int i = start; i < nums.size(); ++i) {\n            if (!(state >> i & 1)) {\n                //这一步骤是关键，为第u号元素找可以选择的坑位[i]\n                path[i]= nums[u];\n                dfs(nums, u + 1, i + 1, state + (1 << i));\n            }\n        }\n    }\n    \n    vector<vector<int>> permutation(vector<int>& nums) {\n        path.resize(nums.size());\n        sort(nums.begin(), nums.end());\n        dfs(nums, 0, 0, 0);\n        return res;\n    }\n};\n```\n\n## 所有递增子序列\n\n给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。\n\n示例:\n\n输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n\n说明:\n\n给定数组的长度不会超过15。\n数组中的整数范围是 [-100,100]。\n给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。\n\n### 解题思路\n\n1. 因为找到是递增子序列，所以不能排序；也就不能通过排序来去重了\n2. 可以考虑用hash_map来做去重。\n\n```cpp\n void dfs(int u, int start) {\n        if (u >= 2) {\n            res.push_back(path);\n            //这里是不可以return的\n        }\n\n        unordered_set<int> iset;\n        for (int i = start; i < d.size(); i++) {\n            if (iset.count(d[i])) continue;\n            if (path.size() && path.back() > d[i]) continue;\n\n            iset.insert(d[i]);\n            path.push_back(d[i]);\n            dfs(u + 1, i + 1);\n            path.pop_back();\n        }\n    }\n```\n\nhttps://zhuanlan.zhihu.com/p/339849416\n","tags":["回溯"],"categories":["数据结构与算法"]},{"title":"选择问题","url":"/backend_knowledge_architecture/structure_algorithm/problem/ selection/index.html","content":"\n### 选择问题\n\n从n个元素的集合中选择第i个顺序统计量的问题形式化地归结为“选择问题”。\n\n#### 中位数和顺序统计量\n\n1）顺序统计量：在一个由n个元素组成的集合中，第i个顺序统计量(order statistic)是该集合中的第i小的元素。如：在一个元素集合中，最小值是第1个顺序统计量（i=1）；最大值是第n个顺序统计量（i=n）\n\n2）中位数：对一个有n个元素的集合，将数据排序后，位置在最中间的数称为该集合的中位数。\n\n#### 最大值最小值\n\n针对一个序列取得最大和最小值均需要n-1次比较。这是一个下限，确定最大值或者最小值的算法可以看作各个元素之间一场锦标赛，每次比较都是一场比赛，两个元素中较小的或者较大的获胜，除了最终的最大值和最小值，所有其他元素都需要输一次，所以n-1次是必须的。\n\n接下来是一些比较有意思的问题，比如同时找出最小值和最大值，当然可以n-1次比较找出最大值，然后n-2次比较找出最小值，不过还是有比这个更好一点的算法，把元素两两分组，然后比较产生一个较大的值和较小的值，然后较大的值中产生最大值，较小的值中产生最小值，此时需要比较操作的次数至多3|_n/2_|。\n\n#### 最大与次大问题\n\n还有一个比较问题是同时找出最大、第二大或者最次小元素的比较次数，简单的当然是2n-3，不过也有一个分组的方法能够达到$n+lgn-2$的比较次数。比较方法如下：\n\n上面已经说明了，找出最值最少的比较次数n-1，所以上面寻找的方法也是n-1次，不信可以累计求和，不过这样求最值的过程中最值上来的时候有一条路径被记录，这条路径的长度为lgn，找出次大值或者次小值直接在这个路径上寻找就只需要lgn-1的比较次数。(但是这种算法不适用于存在重复元素的情况)\n\n原理：锦标赛算法，分组，两两比较；次大值一定跟最大值PK过。\n","tags":["线性选择"],"categories":["数据结构与算法"]},{"title":"选择问题-最少次数求最大与最小值","url":"/backend_knowledge_architecture/structure_algorithm/problem/ selection/max_min.html","content":"\nMaximum and minimum of an array using minimum number of comparisons\nWrite a C function to return minimum and maximum in an array. You program should make minimum number of comparisons.\n\n解答思路：\n\n法1: Pair Compare\n目标：尽可能的减少比较，如何确定a[i]是不是最小值或者最大值呢？\n\n基于比较，消除不确定性\na[i]跟a[i+1] 比较之后？\na[i] 如果比 a[i+1] 则a[i]才有可能跟max比较；a[i+1] 才有可能跟min比较；\n\n结论：3次比较消除了2个元素的的不确定性；\n\na[i]跟min, max比较；\na[i+1]跟min, max比较；\n结论：4次比较，完成了2个元素的确定性；\n\n法2: Divide and Conquer\n如果有两个元素？ 怎么选择最大值最小值？\n如果有一个元素，怎么选择最大值最小值？\n左半部分已经有了最大值，最小值；右半部分已经有了最小值最大值： 如何确定merge之后的最小值最大值？\n","tags":["线性选择"],"categories":["数据结构与算法"]},{"title":"第k大元素","url":"/backend_knowledge_architecture/structure_algorithm/problem/ selection/problem_kth.html","content":"\n输入n个整数，找出其中最小的k个数。\n\n注意：\n\n数据保证k一定小于等于输入数组的长度;\n输出数组内元素请按从小到大顺序排序;\n样例\n输入：[1,2,3,4,5,6,7,8] , k=4\n\n输出：[1,2,3,4]\n\n常见解法：\n\n* 排序\n* 借助堆: 借助大小为K的堆，从而实现快速比较。\n* 线性选择（快排思想） --普通：最坏的时间复杂度$O(lgn)$\n* 线性选择（快排思想） --基于中位数的select升级：借助基于中位数的select算法来选择枢点，可以尽可能的2分问题，从而使得最坏的时间复杂度控制在$O(n)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> getLeastNumbers_Solution(vector<int> input, int k) {\n        priority_queue<int, vector<int>, less<int>> q; //大顶堆\n        \n        for (int i = 0; i < input.size(); ++i) {\n            if (q.size() < k) {\n                q.push(input[i]);\n            }\n            else {\n                if (input[i] < q.top()) {\n                    q.pop();\n                    q.push(input[i]);\n                }\n            }\n        }\n        \n        vector<int> res;\n        \n        while (q.size()) {\n            res.push_back(q.top());\n            q.pop();\n        }\n        \n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n","tags":["一题多解","线性选择"],"categories":["数据结构与算法"]},{"title":"桶排序思想经典题目","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/bucket_sort/bucket_sort.html","content":"\nhttps://www.jianshu.com/p/45f4c5f74c8e\n\n问题：\n\n最大间隙问题。给定 n 个实数，求这n个实数在数轴上相邻2个数之间的最大差值，设计解最大间隙问题的线性时间算法。\n\n分析：\n\n该问题最先想到可能就是排序后计算，但排序的时间复杂度最少为O(nlongn)，不能满足题意的线性时间算法。\n\n所以有一个解决该问题的算法，筒排序。\n\n该算法的思想为，将n个数的最大值、最小值找到，在[ min ,max ]区间内，分成n-1个等大的区间，每个区间的大小为\n\nlen = （max - min）/（n-1），然后将n个数字填入到这n-1个区间中，并根据填入的数，找到该区间内数字的最大值与最小值。除去两边的最大值和最小值，只需要将n-2 个数字填入到 n-1个区间中，根据抽屉原理，那至少有一个空的区间，所以，最大间隙一定产生在两个不同区间之间。\n\n为什么从$O(nlgn)$可以优化到$O(n)$?\n\n对数据进行处理之后，在对处理之后的序列进行相关操作，这是一种很常见的解决问题的思路。\n\n其中，第一步的处理包括：排序、对数据合理的分组等; 借助第一步的预处理，然后再根据一些数学特性去排除一些肯定不可能成为答案的解，从而提到算法效率。\n\n```cpp\nconst int N = 100010;\nstruct Bucket {\n    bool used;\n    int minv;\n    int maxv;\n} buckets [N];\n\n\n\nclass Solution {\npublic:\n\n    int maximumGap(vector<int>& nums) {\n        memset(buckets, 0, sizeof(buckets));\n        if (nums.size() < 2) return 0;\n        //桶排序 + 鸽巢原理\n        int minv = 0x3f3f3f3f, maxv = 0, n = nums.size();\n        for (auto x : nums) {\n            if (x <= minv)  minv = x;\n            if (x >= maxv) maxv = x;\n        }\n\n        int gap = max(1, (maxv - minv) / (n - 1));\n        int gap_cnt = (maxv -minv) / gap + 1;\n\n        for (auto x : nums) {\n            int i = (x - minv) / gap;\n            cout << i  << \" \"<< x << \" \"<< gap<< endl;\n\n            if (!buckets[i].used) {\n                buckets[i].used = true;\n                buckets[i].minv = 0x3f3f3f3f;\n                buckets[i].maxv = 0;\n            }\n            buckets[i].minv = min(buckets[i].minv, x);\n            buckets[i].maxv = max(buckets[i].maxv, x);\n        }  \n\n        int res = 0;\n        int pre = minv;\n        for (int i = 0; i < gap_cnt; ++i) {\n            if (!buckets[i].used) continue;\n            res = max(buckets[i].minv - pre, res);\n            pre = buckets[i].maxv;\n        }\n\n        return res;\n    }\n};\n```\n","tags":["排序","桶排序"],"categories":["数据结构与算法","经典题目"]},{"title":"第一个不重复的字符系列","url":"/backend_knowledge_architecture/structure_algorithm/problem/first_no_repeat.html","content":"\n在字符串中找出第一个只出现一次的字符。\n\n如输入\"abaccdeff\"，则输出b。\n\n如果字符串中不存在只出现一次的字符，返回#字符。\n\n样例：\n输入：\"abaccdeff\"\n\n输出：'b'\n\n```cpp\nclass Solution {\npublic:\n    char firstNotRepeatingChar(string s) {\n        map<char, int> counter;\n        for (auto x: s) {\n            counter[x]++;\n        }\n        for (auto x: s) {\n            if (counter[x] == 1) {\n                return x;\n            }\n        }\n\n        return '#';\n    }\n};\n```\n\n请实现一个函数用来找出字符流中第一个只出现一次的字符。\n\n例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。\n\n当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。\n\n如果当前字符流没有存在出现一次的字符，返回#字符。\n\n样例\n输入：\"gabcdgle\"\n\n输出：\"ggg#ll\"\n\n解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。\n\n解题思路：\n\n第一个只出现一次，表示顺序，需要有队列。 谁，什么时候入队列？什么时候出队列？\n通过map记录次数\n\ngoo\n","tags":["哈希"],"categories":["数据结构与算法","剑指Offer"]},{"title":"动态规划系列-子数组最大和","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/sub_array_sum_max.html","content":"\n## 子数组最大和--题目描述\n\n输入一个 非空 整型数组，数组里的数可能为正，也可能为负。\n\n数组中一个或连续的多个整数组成一个子数组。\n\n求所有子数组的和的最大值。\n\n要求时间复杂度为O(n)。\n\n样例\n输入：[1, -2, 3, 10, -4, 7, 2, -5]\n\n输出：18\n\n## 子数组最大和--思路\n\n子数组的最大值，这是一个求最值问题，十有八九使用动态规划。【这个是我们的经验-求最值问题，十有八九使用动态规划】\n\n拿到一个问题，我们首先要去思考他的解空间有多大？又或者说，计算机用最笨的方法去枚举的话，最多需要枚举多少次。\n\n所有的子数组和的最大值，我需要枚举start, end, 解空间有$n^2$\n\n接着我们再来回答我们接下来要做什么？ 我们需要去检查这一组解是否是最优解。\n如何判断呢？ 这个是一个判定问题。\n\n对这个题目而言，我们的解决步骤如下：\n从start到end累加得到一个数，累加的时间复杂度是$O(N)$\n\n最终的时间复杂度是$O(n^3)$\n\n动态规划思路\n\n|  一维最大子数组和 |最大子数组和系列 |\n|  ----  | ----  |\n| 问题描述   | 给定一个整数数组 nums 计作$A_i$，找到一个具有最大和的子数组（子数组最少包含一个元素），返回其最大和|\n| 状态表示  |F[i]表示利用以$A_i$结尾的子数组的最大和|\n| 转移方程 |$F[i]=\\begin{cases}F[i-1]+A[i] & \\text{if } F[i-1] \\gt 0 \\\\ A[i] & \\text{if } F[i-1] \\le 0 \\end{cases}$|\n| 边界  | F[0]=0|\n| 目标  | F[N]|\n| 空间压缩 | 由于仅与前一项有关，所以可以用一个变量来代替|\n\n## 子数组最大和--代码\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        /*\n        dp[i] = num[i] if dp[i - 1] < 0; \n        dp[i] = dp[i - 1] + num[i]; if dp[i - 1] >= 0\n        表示以A[i]结尾的子数组的子数组最大和。\n        最终的结果，一定是dp[i]中选择一个最大的。\n        */\n        \n        int sum = 0;\n        int res = INT_MIN;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (sum < 0) {\n                sum = nums[i];\n            }\n            else {\n                sum += nums[i];\n            }\n            \n            res = max(res, sum);\n        }\n        \n        return res;\n    }\n};\n```\n","tags":["动态规划"],"categories":["数据结构与算法","剑指Offer"]},{"title":"数据流中位数","url":"/backend_knowledge_architecture/structure_algorithm/structures/heap/mid_data_stream.html","content":"\n## 题目描述\n\n如何得到一个数据流中的中位数？\n\n如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。\n\n如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n样例\n输入：1, 2, 3, 4\n\n输出：1,1.5,2,2.5\n\n解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。\n\n## 思路\n\n算法实现时，一个蛮重要的点在每次都要往某一个某一个堆中添加元素（即使不应该插入，也要先插入另一个，再移动元素过去）。\n\n按照刚才提到的步骤来操作，可以大幅减少过多的分支判断，让你的思路更加清晰。\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    priority_queue<int, vector<int>, less<int>> sh; //大根堆，存最小的一半\n    priority_queue<int, vector<int>, greater<int>> bh;//小根对，存最大的一半\n    \n    void insert(int num){\n        //总会向大的一半中新增一个。\n        if (bh.empty() || num > bh.top()) {\n            bh.push(num);\n        }\n        else { \n            sh.push(num);\n            bh.push(sh.top());\n            sh.pop();\n        }\n        \n        //如果已经失调，则进行调整\n        if (bh.size() == sh.size() + 2) {\n            sh.push(bh.top());\n            bh.pop();\n        }\n    }\n\n    double getMedian(){\n        if ((bh.size() + sh.size()) & 1) {\n            return bh.top();\n        }\n        else {\n            return (bh.top() + sh.top()) / 2.0;\n        }\n    }\n};\n```\n","tags":["堆","中位数"],"categories":["数据结构与算法","剑指Offer"]},{"title":"扫描线","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/line_sweep/index.html","content":"\n扫描线是一条想象中的向右扫过平面的竖直线。也因此，以此思想为基础的算法也被称为平面扫描算法(Plane Sweep Algorithm)，我们以某些事件为基础扫描我们思考的问题以使扫描离散化。\n\n这些事件都是以我们思考的问题为基础，我们将在下面讨论的算法中看见。除去这些事件以外，我们需要维护一些数据结构来储存以y坐标为顺序排列的点（这一顺序有时可能会改变）以助益于在扫描到某些事件时进行操作。在一些情况，该数据结构只储存活动事件。\n\n另一个需要注意的事情是，这种算法的效率取决于我们选用的数据结构。一般地，我们可以用C++中的set，但有时可能我们需要储存更多东西，所以我们可能采用平衡二叉树。\n","categories":["数据结构与算法"]},{"title":"双指针技巧","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/double_pointer/double_pointer.html","content":"\n一类是「快慢指针」，另一类是「左右指针」\n\n前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。\n\n双指针类 （数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数 两种思路：双指针、借助于栈）\n\n盛水做多的容器\n\n<!-- more -->\n\nin place 的更新数组，需要一个index记录更新之后的数组，另一个index跑遍原来的数组；\n\n还有就是找到数组里面的N个数使得这几个数满足一定的条件（如几个数之和必须为某一个特定的数）；还有就是一类特殊的问题雨水储存问题\n\n首先数组是否排序，根据信息论的看法或者能量守恒的原理，数组是否排序与墒有关，\n\n墒的本质就是描述事物有序程度的度量，换句话说事物越有序墒的值越低，并且本质是墒会自然的会增大在无外力干扰的状况下，也就是事物总是向着无序发展的。\n\n而怎样让事物变的有序呢，那么就需要外力能量的输入来使得墒变小或者变的有序。那么在数组是否有序的问题上，我们希望它是有序的，如果不是那么就需要花费“能量”让他的墒变小，\n\n这样复杂度O(nlogn)就上去了，这里复杂度可以看作为外作用力的体现。\n\n其次双指针问题的本质其实是由于有两个或者多个元素有相互作用或者相关联，因此在改变其中一个元素的同时其他几个元素也需要跟着改变，\n\n因此双指针问题一般是在满足几个元素关系不变的情况之下，改变一个元素的同时，寻找其他几个元素满足现有的关系情况。\n\nhttps://www.jianshu.com/p/b5f9ac6de184\n\n常见问题分类：\n    (1) 对于一个序列，用两个指针维护一段区间\n    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n","tags":["双指针"],"categories":["数据结构与算法"]},{"title":"逆序数计算系列","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/merge_sort/reverse_cnt.html","content":"\n在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。\n\n输入一个数组，求出这个数组中的逆序对的总数。\n\n样例\n输入：[1,2,3,4,5,6,0]\n\n输出：6\n\n```cpp\nclass Solution {\npublic:\n    vector<int> nums;\n    vector<int> cp;\n    int cnt;\n\n    void merge(int l, int m, int r) {\n        int k = l;\n        while (k <= r) {\n            cp[k] = nums[k];\n            k++;\n        }\n\n        int i = l;\n        int j = m + 1;\n        k = l;\n\n        while (i <= m && j <= r) {\n            if (cp[i] <= cp[j]) \n            {\n                nums[k++] = cp[i++];\n            }\n            else {\n                cnt += (m - i + 1);\n                nums[k++] = cp[j++];\n            }\n        }\n\n        while (i <= m) {\n            nums[k++] = cp[i++];\n        }\n        while (j <= r) {\n            nums[k++] = cp[j++];\n        }\n    }\n\n    void dfs(int l, int r) {\n        if (l == r) return;\n        int mid = l + r >> 1;\n        dfs(l, mid);\n        dfs(mid + 1, r);\n        merge(l, mid, r);\n    }\n\n    int inversePairs(vector<int>& _nums) {\n        if (_nums.empty()) return 0;\n        nums = _nums;\n        cnt = 0;\n        cp.resize(nums.size());\n        dfs(0, nums.size() - 1);\n        return cnt;\n    }\n};\n```\n","tags":["归并"],"categories":["数据结构与算法","剑指Offer"]},{"title":"链表第一个公共节点","url":"/backend_knowledge_architecture/structure_algorithm/structures/linked_list/slow_fast_pointer/findFirstCommonNode.html","content":"\n输入两个链表，找出它们的第一个公共结点。\n\n当不存在公共节点时，返回空节点。\n\n样例\n给出两个链表如下所示：\nA：        a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗\nB:     b1 → b2 → b3\n\n输出第一个公共节点c1\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *findFirstCommonNode(ListNode *h1, ListNode *h2) {\n        int c1 = 0, c2 = 0;\n       for (auto p = h1; p; p = p->next) c1++;\n       for (auto p = h2; p; p = p->next) c2++;\n       \n       auto p1 = h1;\n       auto p2 = h2;\n        while (c2 < c1) {\n            p1 = h1 = h1->next;\n            c2++;\n        }\n        while (c1 < c2) {\n            p2 = h2 = h2->next;\n            c1++;\n        }\n\n       while (p1 && p2 && p1 != p2) {\n           p1 = p1->next;\n           p2 = p2->next;\n       }\n\n       return p1;\n    }\n};\n```\n","tags":["链表","快慢指针"],"categories":["数据结构与算法","剑指Offer"]},{"title":"数据结构与算法-概览","url":"/backend_knowledge_architecture/structure_algorithm/index.html","content":"\n建立秩序，省却搜索。--德国谚语\n\n计算机解决问题，就靠搜索。 而通过建立秩序，可以让计算机更聪明的完成搜索。\n\n而这里的建立秩序，就包括：\n\n1. 为具体场景设计更合适的数据结构。这一块对应数据结构。\n2. 为具体场景设计更好的搜索策略。 这一块对应算法。\n\n两大类存储引擎：\n\n日志结构（log-structured） 的存储引擎，以及面向页面（page-oriented） 的存储引擎（例如B树）。\n\nSSTable\n\n排序字符串表（Sorted String Table）\n\n参考：https://vonng.gitbooks.io/ddia-cn/content/glossary.html"},{"title":"时空复杂度分析","url":"/backend_knowledge_architecture/structure_algorithm/time_space.html","content":"\n一般ACM或者笔试题的时间限制是1秒或2秒。\n\n在这种情况下，C++代码中的操作次数控制在 $10^7$ 为最佳。\n\n下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：\n\nn≤30 => 指数级别, dfs+剪枝，状态压缩dp\n\nn≤100 => $O(n^3)$，floyd，dp，高斯消元\n\nn≤1000 => $O(n^2),O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford\n\nn≤10000 => $O(n*\\sqrt{n})$，块状链表、分块、莫队\n\nn≤100000  => $O(nlogn)$ => 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分\n\nn≤1000000  => $O(n)$, 以及常数较小的 $O(nlogn)$ 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa\n\nn≤10000000 => $O(n)$，  双指针扫描、kmp、AC自动机、线性筛素数\n\nn≤$10^9$ => $O(\\sqrt{n})$， 判断质数\n\nn≤$10^{18}$ => $O(logn)$，  最大公约数，快速幂\n\nn≤$10^{1000}$ => $O((logn)^2)$，    高精度加减乘除\n\nn≤$10^{100000}$  => $O(logk×loglogk)$，k表示位数，  高精度加减、FFT/NTT\n"},{"title":"贪心算法-区间问题","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/greedy/interval.html","content":"\n## 区间大类的常见套路\n\n猜出一般步骤\n\n1. 对区间进行排序（按照左端点、右端点）\n2. 挨个对区间进行进行枚举，选择局部最优解\n\n证明选择的策略是否是正确的\n\n## 经典题目\n\n### 区间选点问题\n\n问题描述：给定N个区间[a,b]，取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以重复）\n\n本质：取尽可能的点，使他们可以穿过所有的区间。\n\n解法：\n\n1. 按照右端点排序\n\n2. 枚举区间，选择区间的右端点作为候选集（显然最右边是局部最优解）\n\n```cpp\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i ++ ) scanf(\"%d%d\", &range[i].l, &range[i].r);\n\n    sort(range, range + n);\n\n    int res = 0, ed = -2e9;\n    for (int i = 0; i < n; i ++ )\n        if (ed < range[i].l)\n        {\n            res ++ ;\n            ed = range[i].r;\n        }\n\n    printf(\"%d\\n\", res);\n\n    return 0;\n}\n\n```\n\n### 最大不相交区间数量\n\n类似于选课，课程有交集，我们需要选择最多的课程，使得课程之间没有时间冲突。\n\n本质：选择尽可能多的区间，使他们没有任何重合。\n\n1. 按照右端点排序\n\n2. 枚举区间，选择区间的右端点作为候选集（显然最右边是局部最优解）\n\n如果我多选择一个区间，就会出现相交；\n\n```cpp\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>eg[i].l>>eg[i].r;\n\n    }\n    sort(eg, eg+n);\n    int res=0, ed=-2e9;\n    for(int i=0;i<n;i++){\n        if(ed<eg[i].l) {\n            res++, ed=eg[i].r;\n        }else{\n\n        }\n    }\n    cout<<res;\n}\n```\n\n### 区间分组\n\n给定N个闭区间，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。 输出最小组数。\n\n本质：对区间进行分组，组内无交；极限思考：每一个区间一组是满足条件，但是组数太多；\n\n例题：\n\n主持人调度（每一个主持人不能主持两场节目，使主持人最少）\n\n排序 + 利用**小根堆**来动态维护最大值（max_r)\n\ntop()返回最小的最大值，既然最小的都有交集，更大的就更不用说啦。\n\n1. 按照左边排序\n2. 枚举区间，能否将该区间加入到当前分组中（L[i] > Max_r）\n   1. 如果不存在这样子的组，则开新组\n   2. 加入到当前组中，更新max_r\n\n```cpp\n\nbool cmd(const PII& a, const PII& b) {\n    return a.first < b.first;\n}\n\nsort(a, a+n, cmp);\n\npriority_queue<int, vector<int>, greater<int>> q;\n\nq.push(a[0].second);\nfor (int i = 1; i < n; ++i) {\n    int ed = q.top();\n    if (a[i].first > ed) {\n        q.pop(); //先pop，再push，相当于更新了该分组的max_r\n    }\n    q.push(a[i].second);\n}\n\nreturn q.size();\n\n```\n\n### 区间覆盖\n\n给定 N 个闭区间 [ai,bi] 以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。\n输出最少区间数，如果无法完全覆盖则输出 −1。\n\n本质：多个区间都能够覆盖某个start位置，我应该选择哪一个呢？\n\n1. 左端点从小到大排序\n2. 从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新为右端点的最大值。\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\ntypedef pair<int, int> PII;\n\nconst int N = 1e5 + 10;\nPII a[N];\n\nbool cmp(const PII& a, const PII& b) {\n    return a.first < b.first;\n}\n\nint main() {\n    int res = 0, i = 0;\n    bool success = false;\n    for (i = 0; i < n; ) {\n        int max_r = -INF;\n        while (i < n && a[i].first <= lr) {\n            max_r = max(max_r, a[i].second);\n            i++;\n        }\n        \n        if (max_r == -INF) { //没有找到任何能够覆盖start的区间\n            res = -1;\n            break;\n        }\n        \n        res++;\n        if (max_r >= rr) {\n            success = true;\n            break;\n        } \n        lr = max_r;\n    }\n    \n    if (!success) res = -1;\n}\n```\n\n### 合并区间\n\n1. 首先对区间按照起始端点（左断点）进行升序排序，\n2. 然后逐个判断当前区间是否与前一个区间重叠，如果不重叠的话将当前区间直接加入结果集，反之如果重叠的话，就将当前区间与前一个区间进行合并。\n\n```cpp\ntypedef pair<int, int> PII;\nconst int inf = 0x3f3f3f3f;\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<PII> d(intervals.size());\n        vector<vector<int>> res;\n        int n = intervals.size();\n        for (int i = 0; i < n; ++i) {\n            d[i].first = intervals[i][0];\n            d[i].second = intervals[i][1];\n        }\n        sort(d.begin(), d.end());\n        int st = 0, ed = -inf;\n        for (int i = 0; i < n; ++i) {\n            if (d[i].first > ed) {\n                if (ed != -inf) {\n                    vector<int> t = {st, ed};\n                    res.push_back(t);\n                } \n                //把当前区间扩充一下\n                st = d[i].first, ed = d[i].second;\n            }\n            else {\n                ed = max(ed, d[i].second);\n            }\n        }\n\n        vector<int> t = {st, max(ed, d.back().second)};\n        res.push_back(t);\n\n        return res;\n    }\n};\n```\n","tags":["贪心"],"categories":["数据结构与算法"]},{"title":"找递增序列下标数字","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/formula/digitAtIndex.html","content":"\n数字以0123456789101112131415…的格式序列化到一个字符序列中。\n\n在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。\n\n请写一个函数求任意位对应的数字。\n\n样例\n输入：13\n\n输出：1\n\n```cpp\n\nclass Solution {\npublic:\n    int digitAtIndex(int n) {\n        if(n<=9){\n            return n;\n        }\n        int len = 1;\n        long count = 9;\n        int start = 1;\n        while(n>len*count){\n            n-=len*count;\n            len+=1;\n            count*=10;\n            start *= 10;\n        }\n        start += (n-1)/len;\n        string str = to_string(start);\n        return str[(n-1)%len]-48;\n    }\n};\n\n```","categories":["数据结构与算法","剑指Offer"]},{"title":"圆圈中最后剩下的数字","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/formula/lastRemaining.html","content":"\n## 题目描述\n\n0, 1, …, n-1这n个数字(n>0)排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。\n\n求出这个圆圈里剩下的最后一个数字。\n\n样例\n输入：n=5 , m=3\n\n输出：3\n\n## 思路\n\n1. 递归\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastRemaining(int n, int m){\n        if (n == 1) return 0;\n        return (lastRemaining(n - 1, m) + m) % n;\n    }\n};\n```\n","tags":["递归"],"categories":["数据结构与算法","剑指Offer"]},{"title":"推公式系列-字典序第K大数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/formula/theKthNum.html","content":"\n给定n，将1,2，，n按字典序排列，求第k大的数\n","tags":["递归"],"categories":["数据结构与算法","剑指Offer"]},{"title":"幂次方","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/divide_conquer/power.html","content":"\n实现函数double Power(double base, int exponent)，求base的 exponent次方。\n\n不得使用库函数，同时不需要考虑大数问题。\n\n注意：\n\n不会出现底数和指数同为0的情况\n当底数为0时，指数一定为正\n样例1\n输入：10 ，2\n\n输出：100\n样例2\n输入：10 ，-2  \n\n输出：0.01\n\n```cpp\nclass Solution {\npublic:\n    double Power(double base, int e) {\n        if (e < 0) {\n            return 1.0 / Power(base, -e); \n        }\n        \n        double res = 1.0;\n        double t = base;\n        while (e) {\n            if (e & 1) res = res * t;\n            t = t * t;\n            e >>= 1; //执行次数是1不同于e = e & (e - 1)\n            \n        }\n        \n        /*\n        double res = 1.0;\n        for (int i = 0; i < e; ++i) {\n            res *= base;\n        }\n        */\n        return res;\n    }\n    \n};\n\n```","tags":["分治"],"categories":["数据结构与算法","剑指Offer"]},{"title":"杂题系列-字符串转换成整数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/misc/atoi.html","content":"\n## 题目描述\n\n请你写一个函数StrToInt，实现把字符串转换成整数这个功能。\n\n当然，不能使用atoi或者其他类似的库函数。\n\n样例\n输入：\"123\"\n\n输出：123\n注意:\n\n你的函数应满足下列条件：\n\n忽略所有行首空格，找到第一个非空格字符，可以是 ‘+/−’ 表示是正数或者负数，紧随其后找到最长的一串连续数字，将其解析成一个整数；\n整数后可能有任意非数字字符，请将其忽略；\n如果整数长度为0，则返回0；\n如果整数大于INT_MAX(2^31 − 1)，请返回INT_MAX；如果整数小于INT_MIN(−2^31) ，请返回INT_MIN；\n\n## 常规解法\n\n我们先遍历一遍，找到字符串的长度，从而得出最高位的权重(10的几次方？)\n然后再遍历一遍，进行累加计算。\n时间复杂度：$O(2n)$\n\n## 优化思路\n\n我们可以在一遍搞定，每遍历到一个新的元素，需要做的步骤是：\n\n(1) sum *= 10\n\n(2) sum += NewElement\n\n新的时间复杂度：$O(n)$\n\n该题目其他部分无非就是模拟了，做模拟题目的时候切记思路清晰。\n\n## 优化版代码\n\n```cpp\nclass Solution {\npublic:\n    int strToInt(string s) {\n        int i = 0;\n        int sign = 1;\n        bool has_num = false;\n        long long val = 0;\n        while (s[i]) {\n            if (s[i] == ' ') {}\n            else if (s[i] == '+'  || s[i] == '-') {\n                if (!has_num) {\n                    sign = s[i] == '+' ? 1 : -1;\n                }\n            } else if (s[i] >= '0' && s[i] <= '9') {\n                has_num = true;\n                val = val * 10 + (s[i] - '0');\n                if (sign * val > INT_MAX) {return INT_MAX;}\n                if (sign * val < INT_MIN) {return INT_MIN;}\n            }\n            else {\n                if (!has_num) {\n                    return 0;\n                }\n            }\n            i++;\n        }\n        \n        return sign * val;\n    }\n    \n};\n```\n"},{"title":"杂题系列-打印最小数字","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/misc/print_min_num.html","content":"\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。\n\n样例\n输入：[3, 32, 321]\n\n输出：321323\n注意：输出数字的格式为字符串。\n\n```cpp\nclass Solution {\npublic:\n    \n    static int compare(int a, int b) {\n        string ab = to_string(a) + to_string(b);\n        string ba = to_string(b) + to_string(a);\n        return ab < ba;\n    }\n    \n    string printMinNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end(), compare);   \n        \n        string res;\n        for (auto x : nums) {\n            res += to_string(x);\n        }\n        return res;\n    }\n};\n```\n"},{"title":"杂题系列-空格替换","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/misc/replaceSpaces.html","content":"\n请实现一个函数，把字符串中的每个空格替换成\"%20\"。\n\n你可以假定输入字符串的长度最大是1000。\n注意输出字符串的长度可能大于1000。\n\n样例\n输入：\"We are happy.\"\n\n输出：\"We%20are%20happy.\"\n\n考察点： 从后往前遍历，逆向思维。\n\n与之类似的题目： memcpy实现。\n\n```cpp\nclass Solution {\npublic:\n    string replaceSpaces(string &str) {\n        string r;\n        for (auto x : str) {\n            if (x != ' ') r += x;\n            else r += \"%20\";\n        }\n        return r;\n    }\n};\n```"},{"title":"搜索系列-概览","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/search/index.html","content":"\n\n#### DFS\n\n#### BFS\n\n#### A*算法\n\nf(i)估价函数 = g(i)原路径长度 + h(i)启发函数\n\n到达目标就终止\n"},{"title":"扑克牌的顺子","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/sort/isContinuous.html","content":"\n## 题目描述\n\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。\n\n2～10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看做任意数字。\n\n为了方便，大小王均以0来表示，并且假设这副牌中大小王均有两张。\n\n样例1\n输入：[8,9,10,11,12]\n\n输出：true\n样例2\n输入：[0,8,9,11,12]\n\n输出：true\n\n## 思路\n\n1. 排序，移除0，确保相邻元素不相同\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    bool isContinuous( vector<int> nums ) {\n        if (nums.empty()) return false;\n        sort(nums.begin(), nums.end());\n        int k = 0;\n        while (!nums[k]) k++;\n        \n        for (int i = k + 1; i < nums.size(); ++i) {\n            if (nums[i] == nums[i - 1])\n                return false;\n        }\n        \n        return nums.back() - nums[k] <= 4;\n    }\n};\n```\n","tags":["排序"],"categories":["数据结构与算法","剑指Offer"]},{"title":"字符串匹配算法","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/string_match/index.html","content":"\n字符串匹配算法\n\n### 单模匹配\n\n#### BruteForce\n\n暴力匹配算法\n\n#### Rabin-Karp\n\nP进制Hash算法 O(N)时间复杂度\n\n#### Boyer-Moore\n\nBM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，\n\n以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，坏字符规则和好后缀规则。\n\n好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法\n\n#### KMP\n\nKMP算法借鉴BM算法的思想，可以总结成好前缀规则\n\n### 多模匹配\n\n#### Trie\n\n可以对Trie进行内存优化，有序数组、平衡数、跳表等\n\n#### AC自动机\n","tags":["字符串"],"categories":["数据结构与算法"]},{"title":"前缀和系列-不使用除法的特殊累乘","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/skills/prefix_sum/multiply_no_div.html","content":"\n## 题目描述\n\n给定一个数组A[0, 1, …, n-1]，请构建一个数组B[0, 1, …, n-1]，其中B中的元素B[i]=A[0]×A[1]×… ×A[i-1]×A[i+1]×…×A[n-1]。\n\n不能使用除法。\n\n## 暴力做法\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：除结果数组外，$O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> multiply(const vector<int>& A) {\n        vector<int> res(A.size(), 1);\n        \n        //i表示要计算的B数组的下标\n        for (int i = 0; i < A.size(); ++i) {\n            int multi = 1;\n            //j表示A数组的下标，下面的循环是做累乘\n            for (int j = 0; j < A.size(); j++ ) {\n                if (i != i) {\n                    multi *= A[i];\n                }\n            }\n            res[i] = multi;\n        }        \n        return res;\n    }\n};\n```\n\n## 优化思路\n\n**前缀和思想**:当需要多次计算从i到j的累加和时，我们可以考虑计算序列的前缀和序列，把i到j的累加和转换为前缀和序列中i,j下标的元素之差。\n\n**重复计算必可优化原则**：当一套解法中存在重复计算时，我们总是可以依照**空间换时间**原则，将可能存在重复的计算结果存下来。存下来之后，算法的执行效率便提升了。\n\n注意到，前面的暴力解法中，对于i与i+1两个下标的计算，总是会重复计算A[1]到A[i]，我们是否可以仅计算一次呢？\n\n## 时间优化版代码\n\n时间复杂度：$O(n)$\n\n空间复杂度：除结果数组外，$O(n)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> multiply(const vector<int>& A) {\n        vector<int> res(A.size(), 1);\n        \n        vector<int> pre_part(A.size(), 1); //前半部分的累乘结果\n        for (int i = 1; i < A.size(); ++i) {\n            pre_part[i] = pre_part[i - 1] * A[i - 1];\n        }\n\n        vector<int> post_part(A.size(), 1); //后半部分的累乘结果\n        for (int i = A.size() - 2; i >= 0; --i) {\n            post_part[i] = post_part[i + 1] * A[i + 1];\n        }\n\n         //i表示要计算的B数组的下标\n        for (int i = 0; i < A.size(); ++i) {\n            res[i] = pre_part[i - 1] * post_part[i + 1];\n        }   \n        \n        return res;\n    }\n};\n```\n\n## 进一步优化思路\n\n考虑上面代码中的第3步，res[i]的计算仅与pre_part数组中的i - 1项有关，我们是否可以把pre_part的计算结果存放在res中呢？\n\n如果把第3步的迭代顺序反一下，那么第2部分与第3部分的迭代顺序就一致了。并且post_part[i]仅与前一项有关，我们可以做**空间压缩**（动态规划背包问题的常见套路），仅使用一个变量即可。\n\n## 空间优化版代码\n\n时间复杂度：$O(n)$\n\n空间复杂度：除结果数组外，$O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> multiply(const vector<int>& A) {\n        vector<int> res(A.size(), 1);\n        \n        //先将前半部分的计算结果存起来\n        for (int i = 1; i < A.size(); ++i) {\n            res[i] = res[i - 1] * A[i - 1];\n        }\n\n        //逆序遍历，只用一个变量multi来存储后半部分的计算结果。\n        for (int i = A.size() - 2; i >= 0; --i) {\n            multi = multi * A[i + 1];\n            res[i] = res[i - 1] * multi;\n        }\n \n        return res;\n    }\n};\n```\n","tags":["前缀和"],"categories":["数据结构与算法"]},{"title":"骰子的点数","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/num_of_slices.html","content":"\n## 题目描述\n\n将一个骰子投掷n次，获得的总点数为s，s的可能范围为n~6n。\n\n掷出某一点数，可能有多种掷法，例如投掷2次，掷出3点，共有[1,2],[2,1]两种掷法。\n\n请求出投掷n次，掷出n~6n点分别有多少种掷法。\n\n样例1\n输入：n=1\n\n输出：[1, 1, 1, 1, 1, 1]\n\n解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。\n样例2\n输入：n=2\n\n输出：[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]\n\n解释：投掷2次，可能出现的点数为2-12，共计11种。每种点数可能掷法数目分别为1,2,3,4,5,6,5,4,3,2,1。\n\n所以输出[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]。\n\n## 思路\n\n1. DFS\n2. 因为有很多重复计算，所以考虑用DP来优化，状态转移方程：\n   $$f[i][j] = \\sum\\limits_{k=1}^{6}f[i-1][j-k]$$\n\n表示i次骰子透出j的投法数量。\n\n## DFS代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> path;\n    vector<int> res;\n\n    void dfs(int n, int sum) {\n        if (n == 0) {\n            res[sum]++;\n            return;\n        }\n\n        for (int i = 1; i <= 6; ++i) {\n            dfs(n - 1, sum + i);\n        }\n    }\n\n    vector<int> numberOfDice(int n) {\n        res.resize(6 * n + 1);\n        dfs(n, 0);\n\n        vector<int> ret;\n        for (auto x : res) {\n            if (x > 0) ret.push_back(x);\n        }\n\n        return ret;\n    }\n};\n```\n","tags":["动态规划"],"categories":["数据结构与算法","剑指Offer"]},{"title":"字符串正则匹配","url":"/backend_knowledge_architecture/structure_algorithm/algorithm/dp/reg_match.html","content":"\n请实现一个函数用来匹配包括'.'和'*'的正则表达式。\n\n模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。\n\n在本题中，匹配是指字符串的所有字符匹配整个模式。\n\n例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但是与\"aa.a\"和\"ab*a\"均不匹配。\n\n样例\n输入：\n\ns=\"aa\"\np=\"a*\"\n\n输出:true\n\n动态规则\nf(i,j)表示字符串a从i到结尾是否匹配字符串b从j到结尾\nf(m,n) => f(0,0)\n","tags":["动态规划"],"categories":["数据结构与算法","剑指Offer"]},{"title":"单调队列系列-滑动窗口的最大值","url":"/backend_knowledge_architecture/structure_algorithm/structures/queue/mono_queue/slding_window_max.html","content":"\n## 题目描述\n\n给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。\n\n例如，如果输入数组[2, 3, 4, 2, 6, 2, 5, 1]及滑动窗口的大小3,那么一共存在6个滑动窗口，它们的最大值分别为[4, 4, 6, 6, 6, 5]。\n\n注意：\n\n数据保证k大于0，且k小于等于数组长度。\n样例\n输入：[2, 3, 4, 2, 6, 2, 5, 1] , k=3\n\n输出: [4, 4, 6, 6, 6, 5]\n\n## 思路\n\n1. 借助单调队列\n2. 从队头到队尾，元素依次变小，所以称之为单调队列。\n3. 队列中存放数组元素下标\n\n## 代码\n```cpp\nclass Solution {\n  public:\n    vector<int> maxInWindows(vector<int>& nums, int k) {\n        deque<int> dq; //双端队列\n        vector<int> res;\n        for (int i = 0; i < nums.size(); ++i) {\n            while (dq.size() && dq.back() - dq.front() >= k - 1) dq.pop_front();\n            while (dq.size() && nums[i] >= nums[dq.back()]) dq.pop_back();\n            dq.push_back(i);\n            if (i >= k - 1) {\n                res.push_back(nums[dq.front()]);\n            }\n        }\n\n        return res;\n    }\n};\n```","tags":["队列","滑动窗口","单调队列"],"categories":["数据结构与算法"]},{"title":"聊聊后端程序员的知识体系-第一篇","url":"/backend_knowledge_architecture/knowledge.html","content":"\n## 0xFF 写在前面\n\n之前总有一些年轻人问我，我应该了解哪些知识才能像某某某那么牛B。\n这句话的意思其实就是：他们特别困惑，想知道一个后端程序员的知识体系，想知道从哪开始学起。\n\n关于这个问题，琢磨了好久，我不想简单的一句话就敷衍过去了，这个问题我要深思熟虑去回答。\n因为如果 10 年前有人告诉我这个问题的答案，现在的我将少走很多的弯路，技术水平也会更上一层楼。\n\n简单说一下全文的结构，全文一共分为四大部分。第一部分，主要从硬件、操作系统、网络、数据结构&算法等几个方面跟大家聊一下计算机科学相关的基础知识。第二部分，讲一下设计一款高性能的服务框架，应该从哪些方面着手；第三部分，讲一下平常工作中使用最频繁的知识-数据库、缓存以及一些相关的经典问题；最后第四部分，讲述的侧重点从第二部分的微观转到相对宏观的内容，跟大家聊一下分布式系统、大型架构设计等相关知识。\n\n引用古人的一句话，来开始我们的征程！\n> “路漫漫其修远兮，吾将上下而求索！”\n\n<!-- more -->\n\n## 0x00 计算机科学基础知识\n\n### 0x01 硬件相关\n\n首先思考这个问题：我又不是搞硬件的，为什么我需要了解计算机硬件？ 在我看来，有这么几个原因：\n\n第一，“爱美之心，人皆有之！” 计算机硬件中很多设计非常优美，这些优美的设计自然会吸引人们去追逐它。例如，计算机如何表示一个负数、浮点数等。\n第二，只有充分了解了硬件，才能设计出足够高性能的程序。试想，如果你不知晓CPU缓存一致性协议，甚至不知晓L1、L2缓存，怎么可能写出高性能并发程序？\n第三，计算机硬件的许多设计思想，对我们平常设计系统大有裨益。举个例子：稀疏索引跟CPU缓存与主寸的组相联映射的设计思想便十分相似。\n\n![20201211221553](http://cdn.b5mang.com/20201211221553.png)\n\n我这边尽量罗列一些跟我们平常工作相关的硬件知识，供各位参考。\n\n- 计算机如何表示一个数，包括正整数、负数、浮点数等；\n  \n  负数：通过补码来表示，反码 + 1（~N + 1）\n\n  浮点数：对于双精度浮点：符号位（1位） + 阶码（11位） + 尾数（52位）\n\n- CPU的组成以及了解各个寄存器如何协作完成一次完整的函数调用；\n\n  下面这篇文章很详细的介绍了CPU的寄存器\n  https://blog.csdn.net/zhangdaisylove/article/details/47804165\n\n  下面这篇文章很好的介绍了函数调用\n  https://blog.csdn.net/it_10/article/details/52986350\n\n  ![2020121203937](http://cdn.b5mang.com/2020121203937.png)\n\n  如何实现协程切换？\n\n- CPU L1/L2缓存作用以及缓存一致性协议MESI；\n- 计算机访问时间金字塔；\n- 中断：包括常见的硬件中断、软中断；\n- CPU是如何访问主存（By总线），外存（DMA）的；\n\n| 设备   | 访问延迟 | 每秒钟吞吐量 |\n|  ----  | ----  | ---- |\n| execute typical instruction  | 1ns | 10^9 = 1G|\n| 寄存器  | ？？ns | 10^9 = 1G|\n| fetch from **L1 cache** memory  | 0.5ns | 2G |\n| branch misprediction  | 5ns | 200M |\n| fetch from **L2 cache** memory  | 7ns | |\n| mutex lock/unlock  | 25ns | |\n| fetch from **main memory**  | 100ns ||\n| Compress 1KB wth Zippy  | 2微秒 ||\n| SSD random read  | 16微秒 |500MB/s|\n| send 2K bytes over **1Gbps network**  | 20微秒 ||\n| read 1MB sequentially from memory  | 0.25ms|ddr4 17G/s|\n| fetch from new **disk** location (seek)  | 8ms（7200转 盘片旋转(半圈时间) + 磁盘寻道（固定为8ms) + 数据传输（传输数据大小/传输速率） | 机械磁盘 130M/s |\n| read 1MB **sequentially** from disk  | 20ms | |\n| send packet US to Europe and back  | 150ms（距离/光速）地球半径6600km| |\n\n参考：\n\n  https://blog.csdn.net/aijia7039/article/details/101261797?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control\n  \n  https://colin-scott.github.io/personal_website/research/interactive_latency.html \n\n  http://norvig.com/21-days.html#answers\n\n### 0x02 操作系统相关\n\n操作系统是计算机学科必学科目，其重要性不言自明，不再赘述。同样罗列下比较实用的操作系统相关知识点：\n\n1. 进程与线程的本质，进程调度的原理；\n\n   进程：一个静态程序的执行过程；线程：操作系统调度的基本单位；\n\n   进程调度：多级反馈队列调度算法，既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。具体原理我们可以了解一下：\n\n   1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。\n   2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，当且仅当在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。\n   3、对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列末尾，直至完成。\n   4、在最后一个队列QN中的各个进程，按照时间片轮转分配时间片调度。\n   5、在低优先级的队列中的进程在运行时，又有新到达的作业，此时须立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。换而言之，任何时刻，只有当第1~i-1队列全部为空时，才会去执行第i队列的进程（抢占式）。特别说明，当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。\n\n2. OS如何管理物理内存、虚拟内存，OS是如何跟硬件配合完成虚拟内存到物理内存的转换的；\n   TLB: 虚拟地址到物理地址的查询结果的高速缓存；\nhttps://www.cnblogs.com/east1203/p/11572500.html\nhttps://zhuanlan.zhihu.com/p/108425561?utm_source=wechat_timeline\n![20201211235531](http://cdn.b5mang.com/20201211235531.png)\n3. OS是如何运行一个可执行程序的？ 虚拟内存空间构成如何？\n   ![20201215133748](http://cdn.b5mang.com/20201215133748.png)\n   操作系统的用户态、内核态\n4. 进程同步原理与思想；\n   从底层看待锁的实现：锁总线（锁定总线，禁止他人访问内存）、禁止中断（对于单核有效）\n   应用层面有哪些同步手段：锁（mutex、rw_lock、semphore、condition variable）、无锁（原子变量、不超过字长的内存访问的不可分割性）\n5. OS如何管理磁盘（Bitmap)、文件系统；\n   ![2020121514011](http://cdn.b5mang.com/2020121514011.png)\n   ![文件系统层次图](http://cdn.b5mang.com/2021320103635.png)\n   page cache: 加速加速磁盘的写入；在现代计算机系统中，CPU，RAM，DISK的速度不相同。CPU与RAM之间，RAM与DISK之间的速度差异常常是指数级。为了在速度和容量上折中，在CPU与RAM之间使用CPU cache以提高访存速度，在RAM与磁盘之间，操作系统使用page cache提高系统对文件的访问速度。\n6. OS是如何支持系统调用的，系统调用与库函数有何区别？\n   ![2020121514231](http://cdn.b5mang.com/2020121514231.png)\n\n### 0x03 网络相关\n\n网络相关知识中，最重要的有两块：\n\n第一、TCP协议\n\nTCP协议在平常工作中非常重要，如果熟悉tcp协议，那么一个合格的后端程序员借助于tcpdump输出的结果，搭上眼一看便应该可以知道\n出现的问题是Client端还是Server端的问题。\n\n1. 最基本的三次握手、四次挥手以及其中涉及的种种状态（不要仅限于知道这个知识点，要去考虑为什么这么设计，而不那么设计。）\n   ![2020121516134](http://cdn.b5mang.com/2020121516134.png)\n   ![202012151621](http://cdn.b5mang.com/202012151621.png)\n   主动关闭端：ESTB, FIN_WAIT1, FIN_WAIT2, TIME_WAIT, CLOSED; 被动关闭端：ESTB, CLOSE_WAIT, LAST_ACK, CLOSED\n   需要可以解释time_wait的存在性：\n   （1）确认对方收到自己发送的最后一个ACK（如果提前关闭了，对方重传的FIN会无法响应）\n   （2）确认前连接在网络上的分组消失（客户端随机分配的端口与前一次重复，并且seqno发生回环）\n   https://www.cnblogs.com/rexcheny/p/11143128.html\n2. TCP协议设计原理，包括窗口控制（滑动窗口思想）、拥塞控制等\n   慢开始阶段（发送窗口指数放大）、拥塞避免阶段（发送窗口线性放大）、快重传\n   ![20201215163425](http://cdn.b5mang.com/20201215163425.png)\n   ![20201215164530](http://cdn.b5mang.com/20201215164530.png)\n    https://blog.csdn.net/qq_41431406/article/details/97926927\n3. TCP协议流量控制\n\n第二、Http协议\n\n平常工作中，会遇到个别同学搞不定Tcp协议与Http协议，这样子是非常不应该的。关于Http协议你不需要了解太多，但是你最起码应该要知道这些：\n\n1. Http协议大概长什么样（Header、Body）\n2. 5XX， 3XX等各种Code的含义\n   500，服务器内部错误\n   504，服务器执行超过\n   502，Bad Gateway\n   301，永久重定向\n   302, 临时重定向\n   304，内容未改变\n3. Post跟GET的区别，以及有多少种**POST**数据的方式？\n   application/x-www-form-urlencoded 类似于GET，对query params进行url编码\n   multipart/form-data 可上传FILE\n4. 了解http2.0的设计原理，并在平常工作中借鉴使用。https://www.cnblogs.com/barrywxx/p/8570006.html\n\n  双向流、消息头压缩、单TCP的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；\n\n### 0x04 数据结构与算法\n\n这一块水很深，做一个简单的罗列，希望同学们多刷刷leetcode练练手！\n\n#### 0x041 掌握最基本的算法思想\n\n首先，我们需要掌握最基本的算法思想，包括但不限于：位运算、前缀与差分、**二分**、双指针（对撞、快满、滑动窗口）、排序（离散化、中位数）、**倍增**、贪心等\n\n第一，位运算。\n\n第一个需要掌握的技巧是**n & (n - 1)**，通过该操作我们可以让n的**最后一个1变为0**。\n第二个需要掌握的技巧是**lowbit(n) = n & (-n)** ,lowbit操作可以让我们获取到n的低位。\n第三个需要知道的是**二进制表示下不进位**，例如：XOR又称作不进位加法。\n第四个技巧在于 **n XOR 1**成对变换。\n最后，掌握二进制位状态压缩的常见操作\n\n| 操作   | 运算 | 说明\n|  ----  | ----  | ----\n| 取出n的第k位   | n & (1 << k) | n & (00010000)\n| 取出n的后k位   | n & (1 << k) - 1 |n & (00011111)\n| n的第k位取反   | n xor (1 << k) | n xor 00010000\n| n的第k位置1  | n &#124; (1 << k) | n &#124; 000010000\n| n的第k位置0  | n & ~(1 << k) | n & 1111101111\n\n第二，前缀与差分\n\n这里我们了解**前缀和序列**和**差分序列**可以帮我们做什么？\n\n借助前缀和，我们可以把在原序列上的O(N)的累加操作转换为在前缀和序列上O(1)的相减操作。\n而借助差分，我们可以把在原序列O(N)的区间操作转换为在差分序列上O(1)的双端操作。\n\n第三，二分\n\n二分的关键点在于我们是否可以找到一个特性，这个特性在一半满足，而在另一半不满足。\n整数二分边界判定容易出错，附上模版：\n(1) l + r >> 1, [l, mid], [mid + 1, r]\n(2) l + r + 1 >> 1 [l, mid - 1], [mid, r]\n\n二分思想简单，而难点在于我们能否找到那种特性。用于二分的对象也不尽相同，具体包括：\n（1）二分下标：在一个有序数组（该条件可以适当放宽）中查找目标元素的下标。\n（2）二分答案：我们找的是一个整数，并且这个整数我们知道它可能的最小值和最大值。此时，我们可以考虑使用二分查找算法找到这个目标值\n（3）借助二分将最优化问题转判定问题\n\n第四，双指针（对撞、快慢、滑动窗口）\n\n首先我们把双指针问题分为两大类：双序列、单序列。\n先说双序列，一般情况下，我们会分别维护每一个序列的头指针，头指针按照某条件分别移动，直到完成序列的遍历。这种模式的经典案例便是合并排序。\n再说单序列，单序列我们又可以细分为对撞指针、快慢指针，其中滑动窗口是一类特别重要的快慢指针。\n\n这里讨论一个特别重要的问题，双指针是做什么用的？ 一般来讲，他主要用来做时间复杂度优化的（将$O(n^2)$优化到$O(n)$\n\n那么双指针为什么可以把时间复杂度优化掉呢？我们考虑两个指针:$i, j$，如果$j$的取值伴随$i$的取值是单调变化的，那么通过双指针算法我们可以让$j$的搜索空间大幅减少，从而起到了优化时间复杂度的功效。\n\n![20201223184728](http://cdn.b5mang.com/20201223184728.png)\n\n第五，排序与离散化\n\n首先，我们应该牢记各种排序算法的时间复杂度以及应用场合。\n其次，我们需要了解每一次排序算法背后的思想。\n\n![sort-1](http://cdn.b5mang.com/2021321151334.png)\n![sort-2](http://cdn.b5mang.com/2021321152050.png)\n|算法|思想|衍生问题|\n|----|----|----|\n|quick sort|分治思想，借助双指针在$O(n)$时间内完成partition|线性第k大，线性求中位数|\n|merge sort|分治思想，双指针（稳定的）|逆序数|\n|heap sort|借助容器来实现排序，还有类似的BST中序遍历|topK问题|\n|counting sort|空间换时间，非比较；通过扫描min/max来支持负数，通过**累加和+倒序遍历来保持稳定**||\n|bucket sort|抽屉原理，稳定排序，适合元素值集合较小的情况，特别适合外部排序|排序后最大间隔问题、大整数文件取中位数问题|\n|radix sort|稳定子排序算法（计数排序、桶排序来实现）对数字进行k遍排序||\n|shell sort|分块思想，缩小增量排序，一种特殊的插入排序；递减序列的选择很重要|适用于基本有序序列|\n|insertion sort|减治思想，扑克牌|适用于基本有序序列\n|Bubble sort|稳定|\n\n最后，了解排序的用途，借助于排序，我们可以：\n\n1. 离散化：对序列进行保序处理\n2. 中位数\n\n第六，概率相关题目\n\n[概率相关问题](../_posts/algorithm/possibility.html)\n\n最后，倍增（成倍增长）\n\n我们在进行递推时，如果状态空间很大，那么常规的线性递推无法满足时空复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在2的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个2的次幂项的和”这一性质，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求**我们递推的问题的状态空间关于2的次幂具有可划分性**\n\n#### 0x042 最基本的数据结构\n\n掌握最基本的数据结构，包括但不限于：栈（**单调栈**思想解决NextSmaller问题）、队列（**单调队列**解决窗口最值问题）、链表、Hash、字符串（**P进制哈希**、KMP）、Trie、堆、并查集等\n\n第一、最基本的链表（单链表、双向链表、XOR链表）\n\n与链表相关的常见技巧：递归往往可以让你的链表程序变得更加简单、快慢指针\n\n第二、Hash\n\nHash如何解决冲突：拉链法、开放定址法\n\n第三、字符串\n\n字符串的P进制Hash、KMP算法、字符串后缀数组\n\n第四、Trie\n\n借助Trie我们可以在$O(k)$的时间复杂度内找到集合中的字串，其中$k$是字串长度，与集合大小无关；但是Trie的空间复杂度较高，是一种典型的空间换时间的数据结构。特别提一下，前面提到的字串不应该局限于字母，还有可能是组成整数的0/1比特位。比如寻找最大XOR值题目中，我们用Trie数来维护所有的整数，字串便是0/1。借助Trie，我们便能够在线性时间复杂度($O(32)$)内找到target elment。\n\n第五、栈与单调栈\n\n栈的基本特性：后进先出。\n重点说一下技巧性更强的单调栈。例如经典的Next Bigger Element问题，我们从后往前遍历序列并实时维护一个低大顶小的单调栈，每次访问到一个元素时，与栈顶元素挨个比较，如果栈顶元素比当前元素小，就直接出栈（为什么呢？用大白话是说，要找后面更大的元素，如果某个元素A后面的元素比A都小的话，那么A后面的元素是永远不可能成为备选集的。）如果栈顶元素更大，那么栈顶元素就是NextBiggerElement，同时把当前元素入栈。\n\n第六、队列与单调队列\n\n队列的基本特性：新进新出。\n这里同样也讲一下技巧性很强的单调队列。通常我们利用单调队列来解决滑动窗口求最值问题。其核心思想在于每来一个新的窗口元素，我们需要从队列中依次取元素出来，并与之比较，如果队列中的元素更小，就直接出队。（为什么呢？ 新进来的元素比老元素更大，并且生命周期更长，显然老元素应该被淘汰掉）最后，再把新的元素放入队列。\n\n除此，队列最主要的用途就是辅助完成图或者树的BFS，比较经典的问题包括：拓扑排序、分层打印等。\n\n第七、堆与优先队列\n\n我们需要知道堆的最重要特性：能够在$O(1)$时间复杂度内取得最小值。\n鉴于此，堆有几大用途：利用堆来排序、利用堆来求解TopK问题、利用堆来求解贪心问题（例如，利用堆去优化dijkstra算法）\n\n还有一点，我们可以$O(n)$的时间复杂度内完成堆的初始化（我们只需要从$i/2$开始往0遍历，并up堆化即可）\n\n第八、并查集\n\n并查集是一个代码很简单、但技巧性极强的数据结构，我们需要知道并查集的最重要特性：能够在近乎$O(1)$的时间复杂度内完成元素归属集合以及元素合并的操作。\n通常我们利用数组来实现并查集，并经常会通过路径压缩技巧来进行性能优化。\n我们在图的连通性判定、最小生成树-kraskal等问题中可以看到常规并查集的应用。另外，我们有时候需要额外维护size、distance等额外属性去解决更多的问题。这种技巧也需要掌握。\n\n#### 0x043 常见搜索思想\n\n我们需要掌握计算机解决问题的唯一办法--搜索。我们需要了解计算机除了搜索，无他。我们平时听到的递归、递推、分治、BFS、DFS等，其无一不是在搜索。\n我们前面提到的各种数据结构也只是让我们能够更加有效的组织信息，从而让搜索变得更加有效率而已。\n\n为什么解决同一个问题，某些算法却比别的算法跑的更快？究其根本，我觉得有两点：第一，更好的算法避免了很多重复计算；第二，更好的算法避免了很多不可能成为解的无效计算。\n\n让我们对计算机解决的问题做一下分类：\n判定类问题：判定这个答案是不是问题的解\n最值问题：求解满足XXX条件的最大值、最小值，一般解法\n排序问题：对序列元素进行调整使之满足一定次序\n查找问题：找到某一个符合条件的答案\n\n程序遍历“状态空间”的两种基本方式：递归、递推。一般情况下，我们需要采用递归对方式来暴力枚举某一问题的状态空间。按照规模从大到小，有以下几种常见的方式：\n多项式（$n^k$，循环、递推）、指数($k^n$，递归、位运算)、排列($n!$、递归)、组合(${n \\choose m}$、递归+剪枝)\n\n接下来我们聊一下分治、回溯、DFS三者的区别。\n\n递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。\n\n回溯的思路基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。\n回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。\n选择 (Options)，限制 (Restraints)，结束条件 (Termination)\n\n回溯法的基本思想：\n在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n\n回溯法，一般可以解决如下几种问题：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n排列问题：N个数按一定规则全排列，有几种排列方式\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n棋盘问题：N皇后，解数独等等\n\n「回溯法解决的问题**都**可以抽象为树形结构」，是的，我指的是所有回溯法的问题都可以抽象为树形结构！\n\n因为回溯法解决的都是在集合中递归查找子集，「集合的大小就构成了树的宽度，递归的深度，都构成的树的深度」。\n\n递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。\n\n算法模版：\n\n回溯函数模板返回值以及参数, 返回值一般为void,参数要看具体的问题, 签名如下：\n\n  ``` cpp\n  void backtracking(参数) \n  ```\n\n回溯函数终止条件： 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 代码入下：\n\n  ```cpp\n  if (终止条件) {\n    存放结果;\n    return;\n  }\n  ```\n\n回溯搜索的遍历过程\n\n```cpp\n    void backtracking(参数) {\n      if (终止条件) {\n          存放结果;\n          return;\n      }\n\n      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n          处理节点;\n          backtracking(路径，选择列表); // 递归\n          回溯，撤销处理结果\n      }\n  }\n```\n\n#### 0x044 动态规划\n\n第四、掌握动态规划思想，具体包括：线性DP、**背包问题**、区间DP、树形DP、数位统计DP、状态压缩DP、倍增优化DP等\n\n动态规划的本质：计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。\n列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。\n备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门\n\n动态规划：求最值问题\n动态规划三要素：最优子结构、重复子问题、状态转移方程\n明确**状态**、明确**选择**、确定**状态转移方程**\n\n借助**备忘录**或者**dp table**，来解决子问题重复计算问题。\n因为每次状态转移仅依赖dp table的一部分，所以通过**状态压缩**来缩小dp table\n\n这里有更详细的介绍[动态规划](../_posts/dp/index.html)\n\n#### 0x045 图论算法\n\n第五、图论，能够将具体的问题转化为图的几类问题（最短路、最小生成树、**二分图匹配**、网络最大流等）\n\n最短路问题的解法：\n\n  | 算法  | 解决的问题 | 算法原理 | 时间复杂度 |\n  |  ----  | ----  | ---- | ---- |\n  | dijkstra| 单源最短路，稠密图， 正权 | 找到最小距离，用找到的最小距离更新剩余距离 |O(N^2) N为图点的数量|\n  | 堆优化版dijkstra| 单源最短路，稀疏图，正权 | 借助堆来优化dijkstra算法中的查找最小值操作 |O(N^2) N为图点的数量|\n  | bellman-ford| 单源最短路，负边权，限制步数的情形 | 迭代k次，每次找最小距离 |O(N^2) N为图点的数量|\n  | SPFA| 单源最短路，负边权，判定有没有负环 | 队列优化 |O(N^2) N为图点的数量|\n  | floyd| 多源汇最短路 | 动态规划思想，三角不等式 |O(N^3) N为图点的数量|\n\n最小生成树问题的解法：\n\n| 算法  | 解决的问题 | 算法原理 | 时间复杂度 |\n|  ----  | ----  | ---- | ---- |\n| prim算法| 单源最短路，稠密图， 正权 | 找到最小距离，用找到的最小距离更新剩余距离 |O(N^2) N为图点的数量|\n| kraskal算法| 单源最短路，稀疏图，正权 | 并查集 |O(N^2) N为图点的数量|\n\n如何判定图是不是二分图：DFS遍历，奇数环\n\n二分图匹配：匈牙利算法\n\n第六，了解一些经典算法题目，尤其是一题多解的那种。\n\n- 序列分割问题（两部分、三部分）\n  \n  考察点：快排思想\n\n- 第K大问题\n\n    $O(nLgn)$ => 考察点：分治、快排 / 小顶堆\n\n    $O(n)$ => 考察点：分组中位数\n  \n- 中位数相关\n\n  动态维护序列中位数 => 考察点：双堆\n\n  货仓选址问题（中位数）\n\n- 均分纸牌问题\n\n    考察点：贪心、前缀和\n\n- 环形均分纸牌\n\n    考察点：前缀和、中位数、减去平均值的技巧\n\n- 逆序对问题\n\n    考察点：归并排序、平衡树、*树状数组、*线段树\n\n- 高精度计算\n\n    考察点：大数的存储：数组，从0到N，分别对应低位到高位； 方便进位\n\n- 最大子数组和（积）\n\n- 环形最大子数组和\n\n  考察点：滑动窗口最值（单调队列）、两次Kadane算法（一次最大值，一次最小值）\n\n最后，掌握一些常见有用思想与技巧、性质\n\n要从暴力、爆搜开始思考，然后再进一步思考怎么去优化复杂度。常见的思考方向如下：\n\n常见的枚举可以看一看枚举的范围是否有序，可以考虑用二分；\n\n双重循环看一看是否可以用双指针；\n\n一些要查找的O(n)复杂度的部分是否可以用map、set;\n\n括号、回文之类可以思考一下能否用栈;\n\n一些暴力搜索的部分看一看是否存在根本不可能到达的状态可以考虑剪枝;\n\n暴力搜索时看看是否有可重复利用的状态用map或数组把状态存起来（记忆化搜索），然后再看看是否可以用动态规划;\n\n一些枚举的范围很大一看就知道不可能ac可能思考一下是否可以直接推出结论或数学公式（贪心的思考方向）;\n\n一些感觉是动态规划的题目貌似，貌似每一个状态都是有规律的可以尝试用打表这种比较赖皮的方法;\n\n一些需要反复计算的部分如果是固定的，可以考虑先计算好然后把它存起来，下次直接拿来用（前缀和思想）;\n\n一些题目的条件和经典题型很像的可以考虑直接套用经典题型（例如01背包模型，完全背包模型）;\n\n一些常见的操作可以看看有没有现成的类或方法可以直接拿来用（例如java大数、排序、字符串反转、拼接等常见操作）;\n\n一些数字的操作可以看看是否涉及到二进制，可以尝试下异或、&这些操作;\n\n动态规划的题目看一看这一次的状态和上一步的状态是否离得很近，如果离得很近可以考虑状态压缩，降低空间复杂度（例如斐波那契，每一次的状态只和前面两步状态有关）;\n\n- 正难则反：广泛应用于各种问题。答案不容易求、不容易划分，利用全集减去补集从而求出答案。\n字典序最小的方案：结合性质5，倒序处理\n- 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数\n- 凹凸性（二阶导数）：凸壳优化\n- 对称性：优化枚举顺序、减少计算量\n- “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于\n例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于\n- 试填法、字典序\n\n参考：\n\nhttps://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews?aff=K7qB\n\nhttps://www.educative.io/courses/grokking-the-coding-interview?aff=K7qB\n\n## 0x10 高性能服务器设计\n\n说完第一部分，可能会有人问了，“这些基础知识有啥用呢，平常工作中又用不着！”  下来让我们借助第二部分要讲的内容，来尝试着回答下这个问题。\n\n服务器是做什么的？ 服务器是用来处理客户端请求的；我们的目标当然是希望服务器程序可以尽可能**高吞吐**的完成客户端的请求，那么一般而言高手会从哪些方面去考虑呢？ 这里说一下我的一些想法。\n\n影响 RPC 框架性能的三个核心要素如下：\n\nI/O 模型：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能；\n协议：采用什么样的通信协议，Rest+ JSON 或者基于 TCP 的私有二进制协议，协议的选择不同，性能模型也不同，相比于公有协议，内部私有二进制协议的性能通常可以被设计的更优；\n线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，通信线程模型的不同，对性能的影响也非常大。\n\n![RPC性能三要素](http://cdn.b5mang.com/2021319131824.png)\n\n首先、事件处理模型是怎样的？ 可以从以下几个维度来考虑：多进程 OR 多线程、阻塞 OR 非阻塞、同步 OR 异步、Reactor模式 OR Proactor模式；提几个难点：如何避免**惊群效应**、如何避免worker饿死、如何做到Lock free等。\n\nIO模型有哪几种：阻塞IO 非阻塞IO 多路复用IO 异步IO 信号驱动IO\n\nBIO 线程模型主要存在如下三个问题：\n\n性能问题：一连接一线程模型导致服务端的并发接入数和系统吞吐量受到极大限制；\n\n可靠性问题：由于 I/O 操作采用同步阻塞模式，当网络拥塞或者通信对端处理缓慢会导致 I/O 线程被挂住，阻塞时间无法预测；\n\n可维护性问题：I/O 线程数无法有效控制、资源无法有效共享（多线程并发问题），系统可维护性差。\n\n![BIO](http://cdn.b5mang.com/2021319131623.png)\n\n为了解决同步阻塞 I/O 面临的一个链路需要一个线程处理的问题，通常会对它的线程模型进行优化，后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数 \"M\" 与线程池最大线程数 \"N\" 的比例关系，其中 M 可以远远大于 N，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽，它的工作原理如下所示：\n\n![BIO+ThreadPool](http://cdn.b5mang.com/2021319131553.png)\n\n通常一个 I/O 线程会聚合一个 Selector，一个 Selector 可以同时注册 N 个 Channel, 这样单个 I/O 线程就可以同时并发处理多个客户端连接。另外，由于 I/O 操作是非阻塞的，因此也不会受限于网络速度和对方端点的处理时延，可靠性和效率都得到了很大提升。\n\n典型的 NIO 线程模型（Reactor 模式）如下所示：\n\n![NIO](http://cdn.b5mang.com/202131913172.png)\n\n对于IO模型，我们还需要进行网络参数的调优：\n\n（1）tcp_nodelay(发送端 Nagle算法 + 接收端启用DelayedAck)\n\n（2）backlog\n\n（3）snd buffer / recv buffer\n\n![在这里插入图片描述](https://images.gitbook.cn/64cd3430-a0eb-11ea-925f-c3d0464abd84)\n\n第二、如何对资源进行管理？\n\n服务运行过程中，会利用到很多的资源，包括但不限于：内存、连接、线程、协程；其实，答案蛮简单，就是**“池子”的思想**，具体到特定的资源，也就变成了我们经常听到的“内存池”、“连接池”、“对象池”等。\n\n取决于不同资源的访问特点，我们需要用不同的数据结构去管理我们的资源。例如，有一种经典的“内存池”管理算法叫做**Buddy分配**算法，它的主要思想就是倍增，数据结构的话主要是利用了双向链表；\n\n再举一个例子，Nginx借助红黑树来高效管理超时时间。\n\n![在这里插入图片描述](https://images.gitbook.cn/12895410-a0eb-11ea-8705-c338ee6eeef7)\n\n第三、如何管理超时事件？\n\n服务器程序有很多工作要借助于定时器来完成，例如连接多少时间内不活跃就断开连接、最多花多少时间去处理请求超时则终止处理等等。\n\n既然如此，如何去设计一款**高性能的定时器**算法就至关重要了。这里提几个主要思路：有序双向链表、优先队列、红黑树、**时间轮**。\n\n![在这里插入图片描述](https://images.gitbook.cn/b7a55a80-a0ea-11ea-a506-f32f5295a5a9)\n\n第四、如何进行并发控制？\n\n当然最好的情况是没有并发，借助于TLS，每一个线程仅访问自己的资源；如果真的无法避免，我们需要尽量减少锁的粒度；更进一步，在更高的并发下，是不是需要追求**Lock free**等等。\n\n前面四点讲的是对极致性能的追求，讲的是我的程序如何“活的更好”。\n\n最后还有一点特别重要，这一点要考虑的问题在于如何让我的程序在极端恶劣的情况下“能够活下去”。\n\n这里极端恶劣的情况一般分为两种：一种是上游流量徒增、另外一种是下游耗时陡增。如果程序无法很好的应对这种情况，很容易发生**雪崩**，导致程序死掉。这也就是大家经常听到的**过载保护**概念，\n\n具体做法的话，最起码有**限流**和**熔断**吧。这些概念后面谈分布式系统时还会提及，所以在此不再赘述。\n\n除了限流和熔断，我们有时候需要在宏观的业务层面，做主动的降级处理，牺牲一定程度的用户体验去让系统更好的活着。\n\n## 0x20 数据库与缓存\n\n一开始的时候已提到，数据库与缓存这块的知识，在平常工作中使用非常频繁，所以希望每一个有理想的程序员都应该尝试的了解更深一点，而不要仅浮于表面。\n\n### 0x21 MySQL基础知识\n\n关于MySQL数据库的基础知识，我认为有以下几点特别重要：\n\n第一、了解数据库索引相关知识，包括但不限于：\n\n1. Mysql 数据库有哪些索引以及他们各自的特点？InnoDB为什么选择用B+树作为索引，而不用B树？  \n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| hash索引  | 散列表实现，等值查询效率高，不能排序,不能进行范围查询 | 不需要范围查询，仅需等值查询时，可以考虑使用|\n| BTree索引  | B+树实现，支持范围查询 |默认|\n| RTree索引  | 仅支持地理位置类型，RTree空间树实现，相比Btree有更好的范围查询性能 |有按照地理位置检索需要的场景|\n| FullText索引  | 分词加倒排索引实现 |有类似like的全文检索类型的查询|\n\n2. 索引匹配原则：左前缀匹配原则\n\n3. 聚簇索引、非聚簇索引是怎么回事？\n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| 聚簇索引  | 数据按照索引顺序存储，叶子节点存储真实的数据 | InnoDB索引|\n| 非聚簇索引  | 叶子节点存储指向真正数据行的指针 |MyISAM|\n\n4. 数据库回表是怎么回事？如何避免？\n   在查询辅助索引时，如果要查询的字段已经全部在索引中了，那么就不需要额外再查询主索引了；反之，如果要查询的字段当前索引无法覆盖，那么Mysql需要额外查询主索引去获取要查询的字段，访问索引的次数多了一次，我们称刚才的过程为回表。我们通过增加全覆盖索引可以避免回表。\n5. 出现慢查询时会用explain来定位解决\n6. 索引为什么要用B+树来实现？\n    首先，相比红黑树、AVL等二叉平衡树，B+树更加矮胖，这样子索引查找便能够更好的访问磁盘IO，从而有更好的查询性能；另外相比B树，B+树在叶子节点之间维护了一根链表，借助该链表，范围查找性能更加稳定。\n7. InnoDB索引与MyISAM索引的区别\n\n|  索引   | 特点 | 使用场景 |\n|  ----  | ----  | ---- |\n| InnoDB索引  | InnoDB的主索引的叶子节点就是数据本身，而辅助索引的叶子节点是主键ID| InnoDB索引|\n| MyISAM索引  | InnoDB的主索引与辅助索引没有区别，叶子节点存储都是指向真实数据行的指针|MyISAM|\n\n8. 两种存储引擎区别与各自使用场景\n  \n|  存储引擎   | 特点  | 使用场景|\n|  ----  | ----  | ---- |\n| MyISAM  | 不支持外键，表锁，插入数据时锁定整个表，查表的总行数不需要扫表，索引与数据分开 | 不需要支持事务，绝大多数请求为读操作，系统崩溃后数据丢失可接受|\n| InnoDB  | 支持外键，行级锁，事务，查表的总行数时需要扫表，必须有唯一索引，索引与数据在一个文件中 |需要支持事务，读写相当，不可接受数据丢失|\n\n![MysqlB+树索引展示](https://images.gitbook.cn/b480a130-a1b6-11ea-97df-0d0e3bd6b465)\n\n第二、了解数据库的那几把锁是怎么回事\n\n 1. 悲观锁 VS 乐观锁（其实是两种思想）\n    首先悲观锁、乐观锁并不是两种锁，而是两种思想，两种用于实现并发控制的思想。其中，悲观锁指的是对数据被外界修改持悲观态度，认为数据大概率会被他人修改，所以在我准备修改数据时，我会对该数据加锁以避免其他人对该数据进行并发访问。而乐观锁指的是对外部修改数据持乐观态度，认为数据不会修改，所以我会直接对数据进行修改，在修改的以后再进行冲突的检查。如果修改失败了，我再决定如何去做。悲观锁适合写多读少的场景，而乐观锁适合读多写少的场景。悲观锁一般通过数据库锁来实现，而乐观锁一般是通过CAS来实现。\n 2. 意向锁是什么？ 为什么需要意向锁？\n   意向锁是实现多粒度锁的一种方式，是表锁，分为意向排他锁、意向共享锁，意向锁之间是兼容的；意向锁与表级别的共享锁、拍他锁是可能互斥的；意向锁与行级的互斥锁、共享锁是兼容的；实现意向锁的目的有两个：第一，让多粒度锁共存；第二，加快是否可以加锁的判定效率。\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 意向共享锁  | 兼容 | 兼容|\n|  意向互斥锁 | 兼容|兼容|\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 表级共享锁  | 兼容 | 互斥|\n|  表级互斥锁 | 互斥|互斥|\n\n|   | 意向共享锁  | 意向互斥锁|\n|  ----  | ----  | ---- |\n| 行级共享锁  | 兼容 | 兼容|\n|  行级互斥锁 | 兼容|兼容|\n\n 3. Record lock、gap lock、next-key lock\n    record lock, 行锁， 锁直接加在索引记录上面，锁住的是key。\n    gap lock, 间隙锁，用来解决幻读问题\n    next-key lock， gap lock + reocrd lock\n    关于next-key lock的两个原则、两个优化、一个bug:\n    原则1: 加锁的基本单位是next-key lock, 前开后闭区间\n    原则2: 查找过程中遇到的对象才会加锁\n    优化1: 索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁\n    优化2: 索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock退化为gap lock\n    bug: 唯一索引的范围查找会访问到不满足条件的第一个值为止。\n\n    https://blog.csdn.net/zwx900102/article/details/106544634\n\n![数据库锁](https://images.gitbook.cn/c347e4d0-a1b6-11ea-97df-0d0e3bd6b465)\n\n第三、了解事务特性、各种隔离级别以及相应的问题\n\n  事务的特性：\n\n  A 原子性，要么执行要么不执行\n  C 一致性，事务前后，数据总额一致\n  I 隔离型，所有操作全部执行完以前其它会话不能看到过程\n  D 持久性，一旦事务提交，对数据的改变就是永久的\n\n  可能出现的问题：\n\n  脏读，事务B读到事务A还没有提交的数据\n  不可重复读，一行被SELECT两次，返回的结果不一样\n  幻读，两次读取返回的集合不一样\n\n  四种隔离级别：\n\n  读未提交，在该隔离级别，会出现脏读、不可重复读、幻读等问题。\n  读已提交，该隔离级别解决了脏读的问题，依旧会出现不可重复读、幻读问题。\n  可重复读，该隔离解决进一步解决了不可重复读的问题，会出现幻读问题。（但是对于InnoDB存储引擎，通过间隙锁解决了该问题，不会出现幻度现象）\n  串行，该隔离级别把所有操作都串行化了，没有并发访问，解决了以上所有问题。\n\n![数据库各隔离级别会出现的问题](https://images.gitbook.cn/d9fd08e0-a1b6-11ea-bf38-950ba54cfedc)\n\n虽说希望你了解，但是友情提示一波：线上高并发应用，尽量不要用事务！\n\n第四、了解InnoDB存储引擎的几个概念\n\nRedo log: 是什么？ 通过它解决了什么问题？redo log是InnoDB存储引擎为了解决事务持久性而引入的WAL技术。借助redo log，InnoDB存储引擎将事务的commit提交简化为一次内存操作与一次磁盘写入操作。\n如果磁盘页中的数据发生了丢失，也就是在崩溃恢复过程中，存储引擎会通过重做redo log中的操作来进行数据恢复。\n\nbinlog: 又是什么？他是干什么用的？ 了解主从同步原理。binlog是Mysql server层为了解决主从数据同步而引入的一套日志系统。binlog中记录的是一个数据行发生了什么操作。\n\nLBCC，基于锁的并发控制，英文全称Lock Based Concurrency Control。这种方案比较简单粗暴，就是一个事务去读取一条数据的时候，就上锁，不允许其他事务来操作(当然这个锁的实现也比较重要，如果我们只锁定当前一条数据依然无法解决幻读问题)。\n\nMVCC: 什么是MVCC、它的作用、他的大致实现；MVCC是InnoDB存储引擎为了实现事务的隔离级别而引入的一种乐观锁机制。\n\n快照读、锁定读：了解这两种读取方式的发生时机以及如何实现的？\n一致性读视图包括：视图数组（活跃的事务） + 高水位（已经创建过的事务ID + 1）\n如果是可重复读，那么事务开启时创建一次访问视图，\n如果是读已提交，那么事务每一个语句执行前都会重新计算出新的视图。\n\nhttps://www.cnblogs.com/leeeeemz/p/12586815.html\n\nUndo log: 是什么？ 通过它解决了什么问题？ 数据的多个版本，临时写在undo log中，并通过链表管理起来。\n\nInnoDB的几个关键特性：insert buffer、double write、自适应hash索引、异步写等\n\nRedo Log与binlog的两阶段提交\n（1）prepare阶段，先写入rede log（状态为准备中）\n（3）写入binlog（状态为已提交）--- TX_ID\n（2)commit阶段，写入redo log（状态为已提交）\n\n### 0x22 Redis基础知识\n\n首先，对Redis本身足够了解：\n\n1. 如何评价redis的高性能？为何要把Redis设计成单线程？\n\n   redis全内存，单线程，无锁。\n   redis Rehash 渐进式hash,双缓冲 + 分而治之思想\n\n2. Redis提供了哪些数据结构；每一种数据结构的使用场景、大致实现（编码方式、内存占用、时间复杂度）\n\n    十种编码方式：\n    RAW, INT, EMBSTR,\n    ZIPLIST(压缩列表，连续内存，内存利用率高，增删改查效率低下；当hash、zset、list元素少且内容不大时使用该编码),\n    QUICK_LIST（list元素较多时使用）\n    INTSET(整数集合，当set元素较少时，使用该编码,从小到大的顺序存储),\n    HASH（hash元素较多时使用） 渐进式扩容缩容策略\n    SKIPLIST（跳表，zset元素多时使用）\n\n|  数据结构 | 紧凑实现 | 大致实现 |\n|  ----  | ----  | ---- |\n|  string | INT(仅限long类型的string), EMBSTR(字符串比较短) |RAW（普通字符串）|\n|  hash | ZIPLIST（元素较少，成员较小）|HASH|\n|  zset | ZIPLIST（元素较少，成员较小）|SKIPLIST|\n|  set | INTSET（集合元素不多）|HASH|\n|  list | ZIPLIST（元素较少，成员较小）|QUICK_LIST|\n\n数据结构持久化问题，两种策略：\n（1）保留原有的存储格式，例如散列表\n（2）仅保留数据，而清理存储格式，例如redis\n\n![在这里插入图片描述](https://images.gitbook.cn/0bc2bef0-a343-11ea-a506-f32f5295a5a9)\n\n3. redis是如何实现可靠存储的：真的可靠吗？ AOF、RDB有啥区别？ 分别适用于什么场景？\n\n  借助AOF、RDB可以一定程度上减少数据的损失，但是都无法做到数据的100%。\n\n  RDB，定期fork一个子进程，通过copy on write技术，来进行内存的dump，成本相对AOF较高，所以不可能很短时间内就dump一次，所以如果内存中的数据还没有来得及dump到RDB，那么会丢失比较多的数据，好处是借助RDB恢复数据比较快。\n\n  AOF，定期（通常是s级别）append 写操作命令到文件中，只是简单的写一次磁盘，所以性能较好，如果新的命令append到aof之间发生宕机，丢失的数据也比较少。缺点是每次基于AOF恢复数据会比较慢。\n\n4. redis tw代理模式与cluster集群模式分别是如何工作的？ 哪一种模式使用了一致性Hash?\n\n   客户端通过tw代理模式访问redis集群，数据分片使用了一致性hash，以尽可能减少某台redis机器不可用造成的影响；\n   官方的cluster集群方案是由客户端sdk来维护slot分布，数据分片分片是通过CRC32(key)%16834来实现。无中心化，node之间通过gossip协议来进行通信，选主等。\n   使用TW来解决\n   Redis哨兵模式：只能解决高可用的问题，但是无法解决数据太大的问题；\n\n5. 如何通过Redis实现一个“可靠”的分布式锁？\n\n    分布式锁的特性：排他性、无死锁、高可用。\n    先说加锁，setnx命令，支持cas操作，并且支持设置超时时间。通过设置超时时间这个功能点，可以避免加锁后进程挂掉造成的锁没法释放的问题。但是这种加锁方案还有一个缺点，那就是超时时间很难设置的很合理，设置过短可能会引起加锁时间内不足以完成业务逻辑；设置过长又导致宕机恢复时间过长。这种情况下，我们可以额外启动一个WATCH-dog线程来监视这些锁，如果锁快要到期了，就调用expire命令对锁进行续期；业务完成时禁用watch-dog即可。\n    再说解锁，理想情况下，解锁时只要通过del命令来把锁定的key删除即可。但是实际情况可能会更复杂一些。第一个问题，如果删除的key不是加的锁怎么办？ 容易想到，加锁时，设置key的value为一个unique id。 解锁删除时，先get一下key，看看key对应的value是不是跟预期的id相符，如果相符，del；否则，noop，说明我正准备删除别人加的锁。但是刚才的方案，还有一个缺陷那就是get跟del两个操作不是一个原子的，中途可能会被打断。如果真的被打断，还是会出现误解锁的过程。此时我们可以借助lua脚本将刚才的两个步骤原子化。至此，解锁操作才算基本完成。\n\n    最后再提一下，除了redis可以实现分布式锁，还可以通过mysql数据库（version乐观锁，for update悲观锁），zookeeper等来实现分布式锁。\n\n再次，Redis与其他缓存的区别？做设计时如何选择？\n\n### 0x23 数据库的可扩展、高可用、高性能\n\n首先，考虑**高性能**。\n\n突破单数据库表的性能上限， 破解之道在于：**拆分**；而拆分带来的问题在于：**扩展、迁移、负载均衡寻址**不够方便； 如何拆分大致有如下两种方式：\n\n1. 分库分表\n\n垂直拆分、水平拆分\n\n{UID%100}\n\n策略1: range:  主键id / 单库单表限制（例如2000w)\n\n  优点：简单，容易扩展\n\n  缺点：各库压力不均（新号段更活跃）\n\n策略2: Hash:  主键id % N （分库分表数）\n\n  优点：简单，数据均衡，负载均匀\n  缺点：迁移麻烦（2库扩3库数据要迁移）\n\n策略3: Router-config-server ：将路由规则通过配置server统一管理，每次访问db前额外请求一次\n  \n  优点：灵活性强，业务与路由算法解耦\n  缺点：每次访问数据库前多一次查询\n\n分库分表后，业务ID不唯一了，如何解决？[ID生成器](system_design/uniq_id.html)\n\n1. replication\n\n主从同步，在使用主从同步策略来提升性能时，需要提前考虑主从同步延迟对系统一致性可能带来的影响。\n\n（1）主从延迟/数据丢失\n\n  如何缓解数据延迟：通过消息队列冗余、使用缓存（适合比较简单的写操作：新增，而不适合复杂的写入，时序）、访问主库\n\n（2）业务如何访问主库或者从库（感知了细节）\n\n第二，考虑**高可用**。\n\n高可用的唯一思路：**冗余，并且尽可能无状态** （数据、服务、站点、机房）；冗余带来的问题： **一致性**问题\n\n数据库读 高可用带来的副作用：**主从延迟带来的不一致**\n\n![读取到可能还没有同步完成的数据](https://images.gitbook.cn/21b3b330-a344-11ea-a506-f32f5295a5a9)\n\n数据库 高可用保证： 多写\n\n![复杂多写](https://images.gitbook.cn/2fb81c00-a344-11ea-bb3c-b158fe1ceeda)\n\n多写带来的副作用：自增ID数据冲突， 如何解决：\n\n1. 不同初始值，自增步长设置为2\n2. ID生成器生成主键id\n\n双主，但只有一个主提供服务（读+写），另一个主是“shadow-master”，只用来保证高可用，平时不提供服务。\n\nmaster挂了，shadow-master顶上（vip漂移，对业务层透明，不需要人工介入）\n\n最后，**可扩展性**。\n\n如果数据量变大，扩展性比较好的方案有：\n\n1. 基于偶数倍扩容\n2. 基于时间来扩容\n3. 基于数据量来扩容\n\n如果需要扩展新的列，可以考虑：\n\n1. 通过扩展行的方式来扩展属性\n2. 新增一个垂直表，使用时JOIN多张垂直表\n3. 在线表结构表更   “新表+触发器+迁移数据+rename”方案（pt-online-schema-change）\n\n数据库的迁移\n\n![双写迁移方案](http://cdn.b5mang.com/2021320225317.png)\n\n### 0x24 数据库、缓存的其他常见问题\n\n先说最重要的数据库、缓存一致性问题，关于该问题，有以下几点需要考虑：\n\n1. 当DB数据发生变更时，是删除缓存还是修改缓存？\n\n   答案是删除缓存。相比修改缓存，删除缓存是幂等性操作。删除缓存可以避免出现双写并发问题。\n\n2. 先写DB还是先写缓存？\n\n   答案是先操作DB。结合case1, 在读多写少的高并发场景下，如果先删缓存再操作DB，有一个很明显的逻辑错误，使得有极高的概率出现读写并发问题。虽然先db后缓存的方式也无法完全避免这类问题，但是出现的概率极低。\n\n3. 高并发下，关于缓存的一致性会出现什么问题？\n\n   case1, case2中提到了在高并发的情况下，会出现某种并发逻辑错误，导致数据不一致。\n\n4. 是否听说过订阅数据库binlog变更去清理缓存的方法？这个方法的使用场景是啥？\n\n   通过binlog变更的方式去清理缓存，有两个好处：第一，无业务侵入型；第二，支持无限重试。\n\nCacheAside模式，一定是最佳的吗？不一定，具体场景具体分析：\n\n（1）新用户注册场景，同时数据库主从延迟1s\n\n解决方案：新建数据库 + 新建缓存（避免读取到延迟的数据结果）\n\n（2）写入特别频繁的场景，而我们对命中率有一定的要求\n\n  解决方案：\n\n  1. updateDB + updateCache(With Lock)\n  2. updateDB + updateCache(with TTL)\n\nWrite/Read Through模式\n\n两种应对write miss的办法：\n\n  （1）write-allocate 写cache，再由cache更新db\n  （2）no write allocate 直接更新db\n\nwrite back模式\n\n![write-back模式的读](http://cdn.b5mang.com/2021320144254.png)\n\n![write-back模式的写](http://cdn.b5mang.com/2021320144312.png)\n\n变种：在允许数据丢失的情况下，写入时只写缓存，而异步写入存储\n\n再说缓存穿透问题。\n\n首先明确什么是缓存穿透问题？考虑在很高的读并发下，如果某一个redis key突然过期，会发生什么？如果真的发生这种情况，并且我们没有任何预防措施，按照cache aside模式，程序会read from db，然后set cache。但是由于并发很高，所有的线程同时去请求db，造成db过载不可用。我们称这种现象就缓存穿透。通过分布式锁来控制仅一个线程去read db，而其他线程等待，可以一定程度上避免缓存穿透问题。\n\n还有一种情况，如果请求的某一个key在db中也不存在，我们需要设置一个拥有较短TTL的空缓存来避免每次请求都穿透到db。\n\n回种空值---缺点在于：会占用很大的内存来存储好多无用请求，需要评估内存是否OK\n\n布隆过滤器---在写入DB时，额外写一份数据到布隆过滤器，查询时优先访问过滤器\n\n缓存并发穿透（狗桩效应）：极热点缓存失效，大量请求穿透到DB，造成DB瞬时压力过大\n\n最后谈一下缓存雪崩。\n\n同样先搞清楚什么是缓存雪崩。由于某些系统设计不合理，缓存会设置为相同的过期时间或者很接近。这样子在某个时间点，缓存便会近乎同时失效，造成业务请求全部回源db,造成db过载，我们称这种情况为缓存雪崩。一般情况下，我们需要有意的设置key的过期时间，让他们随机过期，从而解决缓存同时过期导致的缓存雪崩问题。\n\n## 0x30 分布式系统\n\n什么是分布式系统？\n> Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers - usually, because the problem no longer fits on a single computer.\n\n分布式系统牵扯甚广，主要分两部分来跟大家聊：\n首先，你应该了解最基本的分布式理论，了解为什么不可能设计出一个完美的分布式系统？\n第二，你应该去了解尽可能多的分布式系统\n\n### 0x31 分布式理论\n\n首先澄清一点，对于这些理论知识不求全部掌握，只是了解个大概即可。\n\n- CAP理论 / BASE理论\n  CAP：一致性，可用性，分区容错性三者不可兼得，只得取其二。\n  BASE: 基本可用、软状态、最终一致性\n- 一致性模型：强一致性、弱一致性、**最终一致性**\n  强一致性：对于分布式系统，一般通过paxos、raft等一致性协议来保证\n- Quorum的NWR模型、时钟向量（clock-vector）\n  NWR模型中，N代表数据的副本数量，W表示更新操作至少W份写入成功，R表示读操作至少R份读取成功。当W+R>N时，整个系统对于客户端而言是强一致的。NWR模型的写入策略会让某些节点上的数据不是最新的，但是却进行了最新的写入操作。这个问题要如何解决呢？ 我们可以引入数据版本的概念，有点类似乐观锁的思想。有了数据版本，自然也就会出现版本冲突的问题。那么又如何解决版本冲突的问题呢？我们可以借助时钟向量把冲突的解决问题交给客户端。系统只是负责把读到的每一个node上的数据以及数据版本返回给客户端，剩下的工作由client自行搞定。\n- lease机制\n  lease是什么？从更深层次上讲，lease是一种带超时时间的分布式锁。如果没有lease,那么分布式环境中的锁可能会因为锁拥有者的失败而导致死锁。而有了lease, 死锁会被控制在一定超时间内。\n- 一致性Hash、虚拟一致性hash\n  一致性hash为了解决什么问题：为了解决常规hash算法中节点数变更会导致数据访问全部失效的问题，解决一致性hash使得节点变更后仅会影响小范围的数据反问。\n  算法原理：计算key的hash值，计算每一个节点的hash值，放置在一个ring上，每次进行顺时针查找\n  虚拟一致性hash: 节点负载不均衡的问题\n- 2PC/3PC：分布式事务\n  2PC，事务分为两个阶段。第一阶段，prepare；第二阶段，commit阶段。\n  这里可以结合mysql redo log/binlog的二阶段写入来举例。\n  prepare阶段：redo写入prepare\n  commit阶段：binlog写入，redo写入commit\n- 一致性协议（Paxos、Raft)\n  RAFT是一个分布式协议，用于完成三件事：leader选举、成员变更通知、日志复制。\n  paxos协议：协议中规定了三种角色：提议者，接受者，学习者；\n- Paxos/Raft等一致性协议与2PC的关系？\n  2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据分片在多个副本的一致性；二者是互补关系，而不是替代关系。\n- 去中心化- Gossip协议\n  redis cluster集群通过gossip协议来完成去中心化的消息传递。\n\n### 0x25 其他常见系统架构组件\n\n#### CDN\n\n静态资源的加速，就近访问\n\nCDN  DNS + 本地缓存\n\n就近访问\n\n![GSLB](http://cdn.b5mang.com/2021320154252.png)\n\n#### 消息队列\n\n消息队列：削峰填谷、异步化、解除耦合\n\n放入队列中，尽快让用户看到结果（用在秒杀中）\n\n异步处理，来简化请求中的业务逻辑\n\n![异步+消息队列](http://cdn.b5mang.com/2021320154944.png)\n\n如何确保消息仅仅被消费一次\n\n生产时：失败重试\n消息队列本身：集群部署，多副本（以防止机器断电造成的消息丢失）\n\nLeader, Follwer, ISR (in-sync replicas)\n\n1. 一条都不能丢（建议：ack=all)\n2. 允许一定丢失（ack=leader, 异步复制给follower)\n\n消费时（接收消息、处理消息、更新进度）\n\n一定要确保正确的处理消息后，才可以更新进度；如此可以保证不丢，但是会造成重复消息。\n\n生产幂等性：kafka维护一个生产者ID+消息ID的映射\n\n消费幂等性：\n\n消费之前，根据消息ID是否处理过，如果处理过了，则直接忽略。\n如果没消费过，则进行消费处理，消费完之后，（注意此处有一个GAP）将消费这个事实，存储到DB中，然后提交进度。\n\n但是如果GAP发生了呢？还是会重复。此处需要进行分布式事务处理。\n\n显然比较复杂，更为简单的是，在业务层进行处理，例如借助乐观锁。\n例如，数据处理是修改数据库，那么我可以在消息内容中加一个版本号；在更新时，进行版本号的添加。\n\n监控队列长度\n\n业务应用层：增加消费能力\n（1）增加消费者的数量-受限于Kafka分区\n（2）提升消费者的消费能力--多线程并行消费--乱序问题\n\n组件本身：\n（1）选择高性能的数据存储方式（磁盘+pageCache)\n（2）配合zero拷贝技术\n\n### 0x32 常见分布式系统\n\n大家思考一下，如果你的公司打算用分布式的方式来构建一个大规模系统，那么这个时候会涉及哪些技术问题？\n\n- 分布式（单机、数据并行、任务并行）\n- 分布式系统指标（性能、资源、可用性与可扩展性）\n\n- 分布式服务框架\n  这里先简单罗列下一款完整的分布式框架应该有哪些功能，具体实现思路放到第三部分。一般而言，常见分布式框架要支持以下功能：统一接入、服务注册与发现、配置中心、消息队列、负载均衡、限流、负载均衡等。\n- 分布式锁\n  基于redis实现的分布式锁前面已经提过，除此以外我们还可以借助**mysql的唯一主键**冲突、**zk的临时节点**来实现，总之实现一款完美的分布式锁并不容易。\n- 分布式缓存\n  通过tw访问的redis集群、redis cluster等，最主要的技术点还是如何做shard\n- 分布式数据库\n  现在比较流行的是tidb,我们需要了解的是这些系统的核心技术点。\n  先说存储TiKV。tidb使用rocksdb来存储kv数据，使用raft协议来做数据复制，借助region来进行数据的分散管理。\n  关于数据分散，一般有两种方案。第一种是按照key进行hash, redis cluster就是这么做的。第二种就是按照key range, 将连续的key分在一组中。\n  使用MVCC来进行数据的并发访问控制，也就是说把key-value变为key-version-value。\n  最后是事务，总体是通过乐观锁来保证事务，具体不表。\n  再说计算。关于计算有两块，第一主要涉及关系型模型到KV模型的转换，第二主要主要设计SQL语句的分布式执行，以及计算下推到存储层。\n- 分布式消息队列\n  消息队列的实现思路大同小异，这里以kafka为例，从高性能、高可用两个角度来看：\n  先说高性能：借助sendfile直接实现从磁盘到网卡的zero-copy快速传输、磁盘的顺序写入、每一个partition分为多个segment，并为segment建立稀疏索引、**批量发送**\n  再说高可用：ISR(in-sync replications) leader维护的一个follower列表，在这个列表中的集合同步进度拉后不会太多。\n\n- 分布式文件系统\n  以HDFS为例，通常分为namenode与datanode, 将一个大文件切分为block来存储，而一个文件由哪些block来组成以及这些block存放在哪台dtanode中是由namenode来维护的。\n\n  多副本：写入多份；\n  一致性：客户端比对checksum\n\n  ![20201215231511](http://cdn.b5mang.com/20201215231511.png)\n\n  https://blog.csdn.net/scl323/article/details/106507192\n  \n- 分布式KV存储\n  一般而言，RocksDB + Raft一致性协议 + 分区（Range, Hash) + PlaceDriver Node(全局管理节点)\n\n  https://blog.csdn.net/weixin_34080951/article/details/87948196\n\n  https://github.com/youzan/ZanRedisDB\n\n  https://blog.csdn.net/u010454030/article/details/90414063\n\n  redis、mc kv缓存\n\n  hbase, cassandra 列式存储，适用于离线统计\n\n  mongodb 文档数据库 schema free\n\n  noSQL的写入性能：\n  Log-Structured Merge Tree 基于LSM树的存储：hbase、cassandra、levelDB\n\n  加速：memtable 有序的容器--底层是skiplist\n  \n  持久化：write ahead log\n\n  但是内存有限，所以需要定期将memtable dump到磁盘上 sstable(sorted string table)\n  当sstable太多的时候，将sstable合并（因为有序，所以合并很快）\n\n  ![LSM-Tree](http://cdn.b5mang.com/202132014200.png)\n\n  noSQL:\n  性能更好：顺序写=》随机写\n  功能可能更强大：ES倒排索引\n  扩展性好：天然支持副本与shard\n\n  一致性hash\n  （1）缓存节点在圆环上分布不均匀（虚拟节点）\n  （2）脏数据（节点不可用之后，又再次恢复，会造成数据是历史数据）\n  可以考虑设置TTL，确保缓存被动过期\n\n- 分布式计算框架（MapReduce思想）\n  MapReduce框架，主要是利用分而治之的思想，将要处理的数据抽象为键值对，将数据的处理过程抽象为Map映射、Reduce简化两个操作。不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算！\n\n- 分布式消息系统\n  ![20201216233741](http://cdn.b5mang.com/20201216233741.png)\n\n  ![20201216235051](http://cdn.b5mang.com/20201216235051.png)\n\n  https://zhuanlan.zhihu.com/p/65892918\n\n  TimeLine模型：消息存储库（用于新设备的数据漫游）、消息同步库（读扩散、**写扩散**）、准实时构建的消息索引库（文本检索、消息类型、消息接受者等）\n\n- 推送Push系统\n\n- 分布式搜索系统\n\n 倒排索引\n  \n- 分布式配置中心、分布式日志中心、分布式监控告警中心\n\n### 0x33 分布式服务框架\n\n#### 0x331 服务注册与发现\n\n集成：在服务提供端或者调用端，如何集成注册中心？应用内 OR 应用外\n测活：服务注册之后，如何对服务进行测活以保证服务的可用性\n负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？\n运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？\n可用性：如何保证注册中心本身的可用性，特别是消除单点故障？\n\n状态获取：（1）主动探测（2）心跳上报\n\n一些可能问题：\n（1）保护机制：如果短时间内摘除的节点数量超过集群的40%，则停止摘除节点\n（2）通知风暴问题（准备更多的注册中心节点；精简通知内容）\n\n目前比较流行的解决方案包括：\n\n|  对比维度 | euraka|consul   |ZK|\n|  ----  | ---- |----  |----  |\n|实现思路 | 去中心化，通过复制来同步数据，但不保证一致性。只要有一个节点可用，系统整体就可用。| 内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案 |使用ZK节点临时节点来维护服务器列表,ZK支持watch节点变更通知机制 |\n|测活     | 客户端心跳  |  TCP/HTTP/gRPC/Cmd |自研-客户端心跳|\n|负载均衡  | Ribbon  |    Fabio |自研-负载均衡|\n|雪崩保护 | 有，灾难态进入自我保护模式  |    无 |自研|\n|自动注销实例 | 支持  |  支持 |进程不可用，临时节点自动销毁|\n|访问协议     | HTTP  |    HTTP/DNS |自研|\n|监听支持     | 支持  |    支持 |WATCH NODE变更|\n|多数据中心     | 支持  |    支持 |不支持|\n|跨注册中心同步  | 支持  |    支持 |不支持|\n|框架集成     | SpingCloud继承  |  Spring、k8s集成 |无|\n|优点     | 去中心化，高可用  |  功能相对完善 |简单容易实现，适用于初创期|\n|不足     | 一致性差  |    可用性无保证 |服务可用性无保障<br>ZK跨机房集群支持不佳|\n|CAP     | AP               |CP          |CP     |\n|一致性协议 | 仅复制，非强一致  |raft|zab，一种类paxos协议|\n\n![20201222213947](http://cdn.b5mang.com/20201222213947.png)\n\n#### 0x332 过载保护：降级、熔断与限流\n\n降级：放弃非核心功能或者服务，保证整体可用的一种方案\n熔断、限流、开关等都是降级的不同类型\n\n常见降级策略：\n（1）读取数据：降级时，不再读取数据库中的数据，而只用缓存数据或者固定数据\n（2）轮询：降级时，把轮询的间隔从10s调大10min中\n（3）写入数据：同步写入改为异步写入，放弃数据强一致\n\n先说限流，限流是过载保护的手段之一，目的在于保护系统不被超过服务吞吐能力的流量（或突发）打死。常见的限流手段有固定窗口、滑动窗口、令牌桶、漏桶、BBR、brpc自适应限流等。下面挨个介绍每一种限流算法的原理以及优缺点。\n\n第一，固定窗口\n原理：维护一个窗口的两个信息：窗口开始时间、经过窗口的请求数。如果窗口内超出限制数则拒绝。如果已经进入新的窗口，则reset计数。\n不足：存在临界点（窗口reset前后的瞬时）的qps会飙高，从而打死系统。\n\n第二，滑动窗口\n原理：将总的时间窗口划分为N个小格，并单独维护每一个小格的计数。通过这种方式，可以把过去一段时间内的计数信息也用上，从而让限流的统计更精确一些。\n不足：窗口不可能无限划分\n\n第三，漏桶\n原理：漏桶具有固定容量，出水速率是固定常量（流出请求）如果桶是空的，则不需流出水滴。可以以任意速率流入水滴到漏桶（流入请求）如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）\n不足：无法应对突发流量\n![20201222223148](http://cdn.b5mang.com/20201222223148.png)\n\n第四，令牌桶\n原理：假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中。假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃。当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络。如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外。算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。\n![20201222223820](http://cdn.b5mang.com/20201222223820.png)\n\n上面的几种算法，一定程度上确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。具体有如下几个弊端：\n\n1. 集群增加机器或者减少机器限流阈值是否要重新设置?\n2. 设置限流阈值的依据是什么?\n3. 人力运维成本是否过高?\n4. 当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义？\n  \n针对以上\n\n第五，BBR限流\n\nhttp://www.mianshigee.com/tutorial/incubator-brpc/1778a50865eb3518.md\n\ncpu > 800 && inflight >  rt * max_qps 则启用限流\n\nlittile's raw定律：并发 = rt * qps\n\n再说熔断，\n\nhystrix中的熔断器模式：半开、全开、关闭（基于错误数到基于超时率）\n\ngoogle sre\n\n正常时，accepts = requests\n当 requests >= K * accepts 开始熔断，丢弃部分请求，按照概率，具体的概率为：\n\nmax(0, (request - K * accepts) / (request + 1)\n\n![google SRE熔断器丢弃概率](http://cdn.b5mang.com/20201230223626.png)\n\nbrpc的熔断\n可选的熔断由CircuitBreaker实现，在开启了熔断之后，CircuitBreaker会记录每一个请求的处理结果，并维护一个累计出错时长，记为acc_error_cost，当acc_error_cost > max_error_cost时，熔断该节点。\n\n#### 0x333 负载均衡\n\n如何探活？心跳机制\n\n大的分类：\n（1）代理类负载均衡\n4层LVS + 7层Nginx相结合\nLVS： 性能好，但是遗憾的是工作在TCP层，并且不能感知下游存货状态\nNginx: 性能差一些，但是能够代理http请求，能够感知下游存活。\n\n（2）客户端类负载均衡\n\n**静态策略**：RR、WeightedRR、HashByKey、一致性hash\n\nWeighted Round Robin， 权重需要人为配置\n无法快速摘除有问题的节点、无法均衡后端负载、无法降低整体延迟\n\n一致性哈希，与简单hash的不同之处在于增加或删除机器时不会使分桶结果剧烈变化，特别适合cache类服务。\n\n**动态策略**（从调用房的角度出发，选择负载最小、最空闲的下游来调用）\n\n- best of two random choice\n\nrepsonse中附带cpu使用率，信息滞后造成了严重的羊群效应\n\n计算权重分数，每次请求来时我们都会更新延迟，并且把之前获得的时间延迟进行权重的衰减，新获得的时间提高权重，这样就实现了滚动更新\n\n![带系数的滑动平均值](http://cdn.b5mang.com/2020123022446.png)\n时间衰减系数的滑动平均值：伴随时间，老的均值，权重越来越小，新的response time，越来越高\n\n- locality-aware，优先选择延时低的下游，直到其延时高于其他机器，无需其他设置\n\n需要有一个最小权重，否则某一个节点就没有流量了，也就无法探测她的接口耗时了\n![Locality-aware](http://cdn.b5mang.com/2021320183422.png)\n\nweight = qps / 耗时;\nweight经常变化，需要用double buffer data + weight\n\n传统的经验告诉我们，不能把所有鸡蛋放一个篮子里，而按延时优化不可避免地会把很多流量送到同一个节点，如果这个节点出问题了，我们如何尽快知道并绕开它。\n对吞吐和延时的统计都需要统计窗口，窗口越大数据越可信，噪声越少，但反应也慢了，一个异常的请求可能对统计值造不成什么影响，等我们看到统计值有显著变化时可能已经太晚了。\n我们也不能只统计已经回来的，还得盯着路上的请求，否则我们可能会向一个已经出问题（总是不回）的节点傻傻地浪费请求。\n”按权值分流”听上去好简单，但你能写出多线程和可能修改节点的前提下，在O(logN)时间内尽量不互斥的查找算法吗？\n\nDoubleBufferData TLS + 双缓冲\n\nhttps://github.com/apache/incubator-brpc/blob/master/docs/cn/lalb.md\n\n#### 0x334 链路追踪\n\ntrace_id + span_id来标识链路的调用关系\n对trace_id采样，而不要随机采样。\n\n#### 0x335 配置中心\n\n不同的配置类型：节点类型 》机房类型 》 全局配置\n\n配置项的读取-变更推送如何实现：\n轮询 + 摘要 （简单，实时性略差）\n长轮询 + 版本号（复杂，实时性好一些）\n\n配置项的存储-配置系统的高可用\n一个小原则：配置系统的旁路化，不要因为配置系统挂了，你的程序启动不了；\n可以做两层缓存：内存缓存、文件保存\n\n核心指标在于可用性！！！5个9？\n\n#### 0x336 日志系统\n\n#### 0x337 API网关\n\n入口网关：隔离客户端与微服务，协议转换、安全策略、认证、限流、熔断等\n出口网关：调用外部API，统一认证，授权、授权、访问控制等\n\nAPI设计要点：性能、扩展性（责任链模式）\n性能：IO多路复用、异步非阻塞、线程池\n隔离性：针对接口对线程池进行分类\n\n#### 0x338 Service Mesh\n\n解决了哪些问题：屏蔽服务化系统的服务治理细节（跨语言无法享用框架微服务能力的问题）、中间件升级难的问题\n\n控制平面（服务治理策略的植入）、数据平面（sidecar,负责数据传输）\nsidecar两种植入方式：iptables、轻量级客户端\n\n入口网关：隔离客户端与微服务，协议转换、安全策略、认证、限流、熔断等\n出口网关：调用外部API，统一认证，授权、授权、访问控制等\n\nAPI设计要点：性能、扩展性（责任链模式）\n性能：IO多路复用、异步非阻塞、线程池\n隔离性：针对接口对线程池进行分类\n\n#### 0x339 监控系统\n\n![监控哪些内容](http://cdn.b5mang.com/2021320212041.png)\n\n![监控系统架构](http://cdn.b5mang.com/2021320212155.png)\n\nAPM：端到端的监控体系\n\n如何防止消息被篡改：对消息体 + 消息头 进行加密，生成一个签名\n如何对数据进行加密：\n\n使用非对称加密的公钥对 “对称加密的私钥-OriginPrivate“ 进行加密，得到SecretPrivate\n然后服务端利用非对称加密的私钥，对 SecretPrivate进行解密，得到OriginPrivate\n\n然后再使用OriginPrivate对加密之后的消息体（SecretContext)进行解密，得到Contenxt\n\n监控哪些东西：网络卡顿率、做某件事情的失败率等\n\n考虑暂存 + retry来应对网络状况不佳的情况\n\n#### 0x33A 自动化全链路压测系统\n\n压测的原则-尽量模拟真实情况；压测的注意点：\n（1）使用线上数据与线上数据\n（2）使用线上流量（流量拷贝）\n（3）流量应该从尽量靠近用户的CDN发起\n\n如何搭建：\n（1）流量的隔离（区分压测流量与正式流量）\n（2）风险控制（尽量避免压测对正常用户的影响）\n\n![自动化全链路压测系统](http://cdn.b5mang.com/2021320214129.png)\n\n压测数据的产生：\n  拷贝真实流量（可以从访问日志、可以抓取某个端口的数据等）\n  打上压测标签\n  放在合适的机房（尽量接近用户）\n数据隔离：\n  针对读请求，针对某些不能压测（例如推荐、数据分析等）的组件进行mock\n  对于写请求，把流量产生的数据写入影子库（数据库-拷贝一份库表和数据；缓存-加压测前缀；ES-多搞一份索引）\n压力测试的实施\n  持续放大，做好系统过载的识别（例如超时率、resp time等）\n\n### 0x34 常见系统设计\n\n系统设计一般会经过几步：\n\n第一，了解业务要实现的功能以及DAU状况（除了需求功能，还要考虑高性能、高扩展性、高可用性）\n\n第二，根据第一步了解的信息，进行初略估计：\n\n（1）估计系统的QPS\n\n（2）估计系统对数据库的QPS以及是否需要缓存\n\n（3）估计系统每天产生的数据量以及累计总量，决定是否需要额外存储\n\n（4）根据以上3点去估计需要几种类型的机器以及每种类型的机器数量。\n\n以上第（4）点提到的估计需要我们对系统的吞吐率比较了解，我们可以看下面的例子：\n\n> 服务器配置\nCPU：Intel(R) Xeon(R) CPU 1.60GHz\n内存：4GB\n硬盘转速：15k/min\n\n![20201225231454](http://cdn.b5mang.com/20201225231454.png)\n\n第三，输出系统整体架构以及每个模块的单独设计\n\n首先，我们要罗列出系统中应该要有哪些模块，每一个模块需要哪些数据，存储的数据访问以及存储特点。不同的特点对应着不同的存储：关系型数据库、KV数据库、KV缓存、分布式数据库、ClickHouse、HBase等（这里我们需要知道尽可能多的存储类型以及各自的优缺点）\n\n其次，这些模块对外提供哪些功能，这些功能提供给谁。搞清楚各模块之间的调用关系，注意不要出现环形依赖。如果有必要的话，是否可以借助消息队列来解除耦合。\n\n最后，模块提供的接口QPS是多少？这些QPS是读还是写？支撑读的话是否需要缓存？支撑写的话是否需要队列？\n\n第四，对架构进行进一步优化\n\n（1）业务逻辑上的优化：是不是可以调整业务逻辑来让系统支撑更高的吞吐？\n\n（2）架构优化：性能瓶颈、单点故障、是否可扩展、监控是否到位\n\n以上内容可以参考： https://www.codercto.com/a/72987.html\n\n下面的表格汇总了一些我遇到的常见系统设计题目，供参考。\n\n| 题目       | 核心考察点 |\n| :--------- | :-- |\n| [唯一ID生成器](system_design/uniq_id.html) | 先号段后ID、雪花算法  |\n| [短网址](system_design/tiny_url.html) | 基于自增ID来生成url |\n| [秒杀系统](system_design/second_kill.html)  | 防止超卖、异步扣库存  ｜\n| [抽奖系统](system_design/lottery.html) |  概率、蓄水池采样  ｜\n| [PUSH系统](system_design/push.html)  | 长链接、队列  |\n| [消息系统](system_design/im.html) | TimeLine ｜\n| [微博系统](system_design/feed.html)  |  TimeLine  ｜\n| [定时任务调度系统](system_design/task_scheduler.html) |  定时器  ｜\n| [分布式日志系统](system_design/distributed_log.html)|  倒排  ｜\n| [网站用户在线统计](system_design/online_stat.html)|  hash  ｜\n| [用户积分排名系统](system_design/val_rank.html)|  树形分区、排名数组  ｜\n\n## 0x40 计算机方法论\n\n### 批量处理 Batch\n\n在处理网络、磁盘等高耗时请求时，通过合并一些频繁请求的小资源可以获得更快的加载速度。\n\n### 预处理 (Pre process)\n\n当某一次计算特别慢时，可以提前算吗？ 算好了之后把它存起来，下次访问就快了。\n\ncheckpoint 检查点\n\n快速恢复存储系统 + log\n\n### 懒惰思想\n\n延后计算，最终一致。\n\n#### 乐观锁\n\nMVCC\n\n#### 池化\n\n例如：内存池、线程池、连接池。池化实际上是预处理和延后处理的一种应用场景，通过池子将各类资源的创建提前和销毁延后。\n\n#### Copy On Write\n\n零拷贝（mmap、sendfile)\n\n关于Trade Off\n\n说明：没有对错、只有是否适合场景\n\n### 一致性换性能\n\n#### buffer 写入\n\n并不是每次都把请求打到底层的慢速存储，\n\nPageCache\n\n#### 同步访问变异步访问\n\n同步变异步，追求更好的性能。\n\n### 空间换时间\n\n#### 双缓冲\n\ndouble buffer\n\n#### 索引\n\nbitmap(磁盘文件管理)、radix tree、红黑树、倒排索引\n\n#### 多级索引\n\npage table\n\n#### 线程局部存储\n\n线程局部分析\n\nthread local\n\n### 提升复杂度，提高性能\n\n#### 随机读写转顺序读写\n\n##### WAL （write ahead log）\n\nbinlog\n\nLSM tree\n\n### 局部性原理\n\n#### 缓存\n\nsplay tree 将最近访问的节点尽量移向根节点。\n\n### 正交\n\n各个概念之间可以独立变化\n\n### 分层\n\n操作系统：硬件 --> 操作系统--> 应用程序--> 应用程序的通信、调用\n计算机网络：ISO七层\nMVC：Model层--> View层--> Control\n\n","tags":["知识体系"]},{"title":"用户留存","url":"/core/运营力/user_keep.html","content":"\nhttp://www.woshipm.com/u/236250/page/3"},{"title":"产品埋点","url":"/core/product/burying_point.html","content":"\n## 两类埋点类型\n\n### 前端（客户端）埋点\n\n使用场景：\n第一，产品运营初期阶段，产品功能相对简单\n第二，需要分析与后端无关的前端用户行为等，例如用户点击、鼠标移动等\n\n### 服务端埋点\n\n使用场景：\n第一，追求精细化运营，需要进行多维数据分析的企业\n第二，包含用户资产数据、用户账户体系相关数据、风控辅助数据等重要业务数据的网站或APP的企业\n第三，对数据安全要求比较高的企业\n\n## 哪种埋点更科学\n\n总结下来：\n第一，没有任何一种通用数据采集方式，是适合所有企业业务诉求的。\n第二，结合行业特性、自身实际需求，设定特定的数据采集方案。\n"},{"title":"吴军老师的《阅读与写作30讲》读书心得","url":"/通用软技能/read_write.html","content":"\n### 发刊词：理解他人表达自己是一张王牌\n\n吴军老师告诉我们的有如下几点：\n第一，阅读与写作对他个人大有帮助。\n第二，相比美国，阅读与写作在中国不太熟重视（或者教学方法不对）。\n第三，阅读与写作是有方法论的，吴军老师会在本课程中给我们一一道来。\n第四，阅读与写作能力的提升，除了方法论以外，还需要大量的时间。\n\n<!-- more -->\n\n### 理解他人\n\n什么是合格的阅读理解？\n\n第一，不是所有的人都能够做到合格的阅读理解，即使他受过教育，识字。\n第二，阅读理解包括两层：字面意思、隐含信息、作者的内心本意（最高层次）\n第三，什么是阅读理解？ 它是人们通过书面语言学习新知识的途径。站在作者的角度看，他们要把**客观知识**或者自己**主观想法**，用大家**熟悉的概念**讲清楚。\n第四，读懂作者的意思，是阅读。完成形象的重构，是理解。\n\n作者如果想要有效传达自己的想法，必须在内容上提供六个要素：时间、地点、人物、发生、发展、结果\n一个好的作品，尤其是文学作品，通常在结构、描述手法、比喻和暗喻、用词用语、语气等五个方面表现出色。\n\n### 读懂作者的内心\n\n写作分两种：\n第一种，类似公文的被动写作，你的目的在于：把你想说的讲清楚；\n第二种，自由写作，目的往往有两个：\n\n1. 通过写作表达自己的内心\n2. 描绘他们的时代和周围的事件\n\n### 口语表达\n\n好的口头表达，要有侧重点\n\n1. 最重要的主题讲， 其余的不讲（把想讲的内容列一个单子，删除次要的内容，删到最后，如果再删，那么这次讲话就可以取消了，那么删的就差不多了）\n2. 能讲清楚地讲，讲不清楚或者花费太多时间的不讲（大家听明白了你的贡献，而且没有异议，才觉得你牛，即使那个贡献看上去没那么大）\n3. 讲自己独到之处，别人都有的东西不讲（向领导申请资源时，要找别人没有的理由，而不是最重要的理由）\n4. 对自己和朋友有利的话讲，对自己和对方没有好处的话不讲\n\n好的口头表达，要有对象感（要看人，要用听众能听懂的概念去解释）\n\n口头表达，最好还要有吸引力（善用对比和类比）打个比方哈。\n\n### 书面表达\n\n相比口头表达，有四个区别：\n第一，书面用语\n第二，表达结构有多种\n    口头表达，一般而言就是时间顺序，先原因后结果；\n    书面表达，灵活多变，你的表达结构要服务于自己的表达意图；\n第三，信息方向不同\n    口头表达，单方向线性，被动接受信息，一个线索\n    书面表达，多个线索\n第四，逻辑复杂多不同\n    口语表达，三段论\n    书面表达，表达逻辑的两个常用手段：层层递进、剧情反转\n线索\n\n### 阅读品位-如何全面构建自己的知识体系\n\n第一步，进入一个新的领域，从阅读正统文献和作品开始，建立基准线，例如中美两国普遍采用的教科书、名牌大学开的MOOC、得到上的通识课\n金融领域《经济学》 AP课程 McConnell\n全球历史《全球通史》\n\n第二步，读权威的综述文章，基本上把一个领域最近十年的成就概括。5篇左右就够了\n科学类的《科学》\n医学发展《展望》\n工程类《频谱》\n金融领域《巴伦》《经济学人》\n\n第三步，读一些有趣的专注，前提是有自己的基线，不要讲标新立异当作主流观点\n《人类简史》《丝绸之路》等\n\n### 如何提高阅读速度\n\n阅读理解的效果，两个层次：\n第一个，宏观，单篇文章的结构，书籍的结构等，搞明白作者是怎么想的，如何表达的；\n第二个，微观，其实也就是六要素。\n\n有意识的阅读，提高对文章结构与有用信息的敏感度。\n\n### 如何爱好写作\n\n第一步，找个有序新鲜的题材，开始写。\n观察日记 = 手机 + 文字说明 = 什么时候在哪里拍的，拍的什么，为什么拍\n需要让人有这种感觉 “原来如此”、“原来也不过如此”\n\n第二步，让主题画面突出出来\n主题不明 = 拍了照，别人问拍的啥 = 对照片进行裁剪 = 把文章中没有用的东西删除\n\n第三步，形成具有动感的故事\n\n一个完整的故事 = 一组照片"},{"title":"数据与监控","url":"/risk_ctrl/data_monitor.html","content":"\n本文分为两部分。第一部分讲数据，包括数据是如何收集、衍生的。我们需要格外关注数据\n\n## 数据\n\n原始数据\nGaiaEvent\nGaiaReport\n\n衍生数据\n\n## 监控\n\n### 离线打击概览\n\n第一点：呈现出该场景以及该场景下每一条规则的打击情况\n总打击人数，hit_uv\n总人数, total_uv\n总打击次数，hit_pv\n总次数，total_pv\n\nUV整体打击率 total_hit_radio_uv = hit_uv / total_uv\nPV整体打击率 total_hit_radio_pv = hit_pv / total_pv\n\n分规则：对于以上各打击指标，分别按找规则统计一次\n\n<!-- more -->\n\n### 打击准确率如何\n\n第二点：对于以上的每一条规则的打击情况，准确率到底如何呢？\n\n思考：这个问题有一些困难。 我们需要找一个对比基准。 我这边可以可以想到有几种办法：\n第一种，借助于某个权威的第三方。对于我们打击的每一个主体，去调用第三方数据。 （第三方判定是否有风险）\n第二种，建立基于客户投诉的反馈机制。如果某一条打击，被用户投诉反馈，我们需要人工核查，并及时调整自己的规则。 （是否被投诉）\n第三种，建立关于打击结果的人工审核机制。 （最终产出：确认、误伤、待定）\n\n### 漏过检测如何做\n\n第三点：针对某个场景，召回率如何统计呢？ 这个问题非常重要，也非常困难。\n先从定义出发，召回率不够高，说明漏过率很高。什么是漏过呢？ 坏人，我给放行了。\n\n常用的漏过检测机制：\n\n第一种，抽样 + 人工审查。\n优点：简单统一，人工审查结果有能力找出所有漏过\n不足：人工成本较高、有一些漏过即使人工审查也很难发现\n\n第二种，基于某些合理的假设，建立漏过标准\n总体原则：查杀分离\n合理假设一：相比正常用户，漏过的用户N日留存会更低一些\n    具体方案：\n    第一步，分别建立实验组（通过某种活动渠道注册的用户）、对照组（常规注册的用户）的七日留存曲线，\n    第二步，对比分析；如果留存率gap较大，说明“有好多黑产通过这个活动注册了好多新账号，但是我们并没有打击”，也就是发生了漏过\n合理假设二：相比正常趋势，异常流量造成的趋势变化会更大\n    例如：同一时间间隔，无手机号登陆次数应该是稳定的；如果某一时间端的次数发生突变，而我们打击数并未同幅度突变，那么便发生过了漏过\n合理假设三：黑产通过作弊手段，有更高的概率抢到更稀缺的资源。黑产账号拥有更高的库存量，以及出货量。\n    例如：在秒杀活动中，我们假设黑产抢到优质资源的概率是70%。\n    1~100号资源，被N个人抢到，N个人之中多少是黑产呢？ 假设有M个黑产，则漏过率为M/N。\n    我们可以基于账号的历史行为（历史抢购数量、历史赠送数量）来判定账号有多大的概率是黑产账号。\n合理假设四：通常情况下，注册手机号归属与IP地址归属不同的人的占比较少（10%），且稳定\n    例如：如果异省占比有较高变化，而打击未同比变化，则发生漏过。\n\n第三种：抽样（或者全量） + 第三方验证\n\n### 离线打击明细\n\n## 业务监控\n\n每一块业务应该有自己的核心监控指标，用于两个目的：\n第一，衡量风控给业务带去的价值\n第二，发现业务风险\n\n深度思考：对于某一个场景，每识别一次攻击，会给公司挽回多少资金损失，带来多少价值。\n\n将数据存放在某个分布式存储之上。\n例如：阿里云PAI便是将数据写在OSS或者MaxCompute上面，其中：\n使用MaxCompute存储的表结构数据，用于常规算法组件。\n使用OSS存储的结构化或非结构化数据，用于深度学习算法组件。\n"},{"title":"风控系统架构","url":"/risk_ctrl/risk_control_arch.html","content":"\n## 有赞风控系统\n\n![20201021161520](http://cdn.b5mang.com/20201021161520.png)\n\n1. 借助规则评估系统，去评估规则的准确率、召回率。\n2. 引入模型作为业务打击规则的补充，去找回既定规则难以覆盖的case。\n"},{"title":"重塑知识体系","url":"/底层思维/rebuild.html","content":"\n理论课\n\n2019年版\n\n使命：让哲科思维点亮创新者！\n\n用第一性原理，跨越非连续性，实现第二曲线式增长。\n\n第一部分\n\n创新的三个模型：第一曲线、第二曲线、非连续性\n\n三个模型的逻辑关系：第一曲线 + 非连续性 = 第二曲线\n\n生物进化论：遗传变异，自然选择\n创新与进化的完美**类比**\n遗传 （第一曲线）\n变异+选择 （分形创新）\n新物种 （第二曲线）\n\n<!-- more -->\n\n## 第一曲线\n\n第一个问题：为什么要创新？\n\n论点1: 增长（任何企业的首要战略目标）\n\n论点2: 你最渴望的东西，往往也是最制约你的东西。\n增长魔咒\n\n第二个问题：如何才能增长？\n三种增长引擎：创新、红利、管理\nS曲线：技术性创新/连续性创新，Better\n隐含假设：只要努力，就能持续增长。\n\n第三个问题：会持续增长下去吗？\n不会，因为有极限点\n\n第四个问题：为什么会有极限点？\n城市：超线性增长；组织：亚线性增长\n随着规模增加，人均产出在降低\n\n第五个问题：为什么随着规模增加，人均产出在降低\n熵增定律：封闭系统的熵随着时间的推移不断增加，且不可逆。\n\n极限点 挑战 传统的经典战略理论（坚守本业）\n\n遭遇极限点以及由此导致的非连续性断层期，是大公司的第一死因。\n\n第六个问题：如何发现极限点：\n如何发现极限点：单一要素十倍速变坏\n两类曲线：显曲线（收入、利润、市占率），隐曲线（技术、产品、组织）；\n隐藏的能力曲线先于财务曲线遭遇极限点，所以仅仅在财务上判断会有滞后性。\n\n第七个问题：企业增长的宿命如何？\n增长越来越慢，最终导致死亡。\n\n创新 与 管理 是二元对立，相互遏制的\n一线，二点，三阶段\n\n## 第二曲线\n\n第一个问题：什么是两种性质的增长？\n市场级增长、企业级增长；企业增长往往比不过市场；\n连续性 vs 非连续性\n管理和延续 vs 创新与破坏\n封闭式增长  vs 开放式增长\n保护性思维 vs 破坏性思维\n\n第二个问题：什么是第二曲线创新\n只有第二曲线创新，才能带来实质性的增长。\n创新是经济发展的唯一因；\n只有破坏子系统才能让母系统长存。\n\n企业长寿方法论：守正出奇\n管理：尽量延长第一曲线的生命来应对既有市场\n创新：独立启动第二曲线来应对新兴市场\n\n第三个问题：开启第二曲线的最佳时期\n1）第一曲线已过破局点\n2）第一曲线还在增长，但增长加速度开始下降之后\n3）deadline: 第一曲线到达财务极限点之前\n\n基业长青的关键在于：一次又一次的跨越第二曲线bai\n\n## 分形创新\n\n如何打破管理与创新的二元对立？\n两难困境：不创新，等死；创新，找死。\n\n如果小尺度看不清pattern， 把尺度放大一下；\n公司创新 =》 生命进化？\n自然界无飞跃： 尺度变换：生存竞争的主角不是物种之间的竞争，而是同一物种个体之间的竞争。\n变异 + 变异选择 =》 新物种\n\n第二曲线不是布局出来的，而是长出来的。第二曲线绝对不是多元化理论。\n\n创新与进化的同构性底层算法：S曲线这个自相似结构在不同尺度上的无限分形\n\n分形创新\n\n所谓第二曲线创新，不是放弃主营业务，布局新业务；恰恰相反：往主营业务中注入创新，新业务将是自然而然的结果。\n\n分形，一种极其深刻的数学思想： Z = Z^2 + c\n\n复杂系统，可以由简单的几个法则构成。\n\n神性法则，逆熵性；超越S曲线魔咒；\n\n第一性原理打破非连续性，而分形便是其中一个！\n\n更小的尺度进去，大尺度出来\n\n第二部分\n战略的三个模型：组合创新、单一要素、战略杠杆\n\n理论基础：物理原子论、哲学还原论\n三者的逻辑关系，源于物理学的还原论（组合创新）：基本要素（单一要素），重新组合（战略杠杆）\n\n## 组合创新\n\n相关论断：\n创新，并非“无中生有”，而是把不同的事务关联起来，合成新事物。\n                                                    - 乔布斯\n旧要素，新组合。\n组成经济结构的基本要素：技术、产品、市场、资源、组织。\n                                                    - 熊彼特\n供需连模型：供给侧（技术、产品）、需求侧（客户、用户）、连接侧（平台、组织）\n\n两个步骤：\n拆解基本要素（创新基本功）\n    拆解到模块化即可（社会、组织、个体、细胞、分子、原子、质子、夸克）\n重新组合\n\n## 单一要素\n\n组合要素的本质是什么？ 依存条件\n充分条件越多越好，必要条件越少越好。\n\n论断：\n过了破局点，正循环自增长；不过破局点，低水平重复。\n破局点，往往跟风口、周期有关系。\n击破阈值之前，遍地是红海；击破阈值之后，一花一世界。\n单一元素最大化： 聚焦第一曲线的某一个元素，将它最大化为第二曲线的全部\n取胜的系统在追求最大化单一要素和最小化其他要素上，走到近乎荒谬的极端。\n                                                         - 芒格《最大化模型》\n两个问题：\n\n如何识别破局点？\n    单一要素十倍速变化\n\n在企业资源有限的前提下，如何突破破局点？\n    最小切口，力出一孔\n\n## 战略杠杆\n\n好战略就是杠杆作用！\n创新红利，只是切入点；为了打造长期战略，必须定义长线指标。否则，会陷入价值网陷阱。\n\n杠杆模型-战略杠杆四个一\n创新红利：十倍速一\n    供需连模型\n真北指标：长线的一\n\n核心能力：舍九取一\n    技术、产品、市场、组织、运营、模式、资本\n战略支点：不变的一\n    基石假设、第一性原理、使命愿景\n\n战略支点，为什么需要不变的一？\n找到关键要素，将所有力量集中在支点上；\n不变的一，唯一的的一；\n“简一律”\n简一律破二元对立\n\n核心能力，为什么要舍九取一？\n一个好的战略的标准就是：他的对立面也是好的战略。\n战略本身什么要不是，他必须着力于某一个载体才能起作用。\n\n亚马逊：\n长线指标：利润（短期） VS 自由现金流（长期）\n核心运营能力：无限选择、更低的价格、快速配送 （增长飞轮，越。。。越。。。）\n\n第三部分\n竞争\n\n错位竞争，初创企业的第一法则\n颠覆创新，错位竞争的最佳范式\n边缘分化，颠覆创新的底层定律\n\n### 错位竞争\n\n错位竞争：与其更好，不如不同\n\n理论：\n达尔文：性状趋异原则\n\n概念：\n\n生态位：\n\n价值网：一方面供给；一方面禁锢！\n价值网如何而来？\n熊彼特创新的五个基本要素：技术、产品、市场、组织、资源等。\n克里斯坦森简化的价值网模型：供给：技术、需求：市场\n![价值网](http://cdn.b5mang.com/20201021131256.png)\n\n洞见：\n1）技术无所谓颠覆，市场也无所谓颠覆，只有技术与市场的新组合才有颠覆性。\n2）通常把在位企业的生态位看成了全部可能的生存空间。\n3）在位企业有自己的认知边界与隐含假设，又或者被自己所在的价值网束缚。\n4）一旦选择了基本要素并完成组合，企业也就选择了自己的生态位。\n5）错位竞争，不是自感弱小，而是让棋盘变得更大（从平面思维变成分形尺度思维）\n\n方法论：\n王慧文 A/B分类法（横切一刀，纵切一刀，再切一刀）\n\n案例：\n\n1. 酒店旅游， 美团 VS 携程\n2. 团购，美团 VS 阿里聚划算\n\n### 颠覆创新\n\n定义\n\n创造性破坏的一体两面：\n对内：第二曲线创新\n对外：颠覆性创新\n\n概念\n\n技术曲线\n连续性创新：沿着技术曲线持续**改善**， 做的**更好**，定位于主流消费者；但伴随**遏制不住的复杂化**而会遭遇极限点\n连续性技术\n正向非连续性\n反向非连续性：才具有颠覆性\n“右上角迁移力”：颠覆式创新的逻辑奇点（技术进度的速度会超过市场需求的速度）\n![20201021132350](http://cdn.b5mang.com/20201021132350.png)\n\n方法论\n如何进行颠覆性创新？ 两个关键步骤：\n\n1. **需求**：识别未被满足的大众需求（低端、边缘）\n   供给：引入新兴技术和产品（更方便、更便宜）\n2. **供给**：技术和产品连续性迭代进步（护城河）\n\n### 边缘分化\n\n回答的一个问题：为什么创新总来自于边缘？\n偶然现象还是底层原理？\n\n理论基础：王东岳 递弱代偿原理\n\n第四部分\n组织\n\n文化的三要素：\n生存结构、思维方式、遮蔽效应\n\n1. 生存结构：价值网络\n2. 思维方式：组织心智\n3. 打破窘境：破界创新\n\n## 价值网络\n\n价值网依赖理论\n需求侧价值网：客户价值网、资本价值网\n\n真正决定企业未来发展方向的是价值网，而非管理者。管理者只不过扮演了一个象征性的角色而已。\n\n回不去的低端：大企业无法进入小市场，因为满足不了资本的要求。\n\n如何突破价值网，找到真正的主体？\n\n1. 重新定义真北指标（长线）\n2. 重新定义战略支点（不变）\n\n## 组织心智\n\n心智模式自动化\n群体心智模式，一旦形成，很难改变。\n心智模式的作用：解释过去，预测未来。\n心智模式的假设边界：未来不变的连续性假设\n\n生存结构，容易改变；思维方式，很难改变。\n\n每一个人都是自己认知框架的囚徒。\n\n延续性创新，发生在原有体系内；\n突破性创新，用重量级团队方式，改变流程；\n破坏性创新，用独立小机构，改变流程与价值标准。\n\n类比：\n\n新的物种是如何产生的：变异 + 选择 + 隔离（地理隔离 =》 生殖隔离 =》 新物种）\n\n案例：\n百度：搜索、新浪：媒体、联想：贸工技、盛大：运营、苏宁：线下；\n阿里：电商+金融、腾讯：社交+投资\nIBM的衰弱：新的CEO是大型机负责人\n微软的重生：新的CEO是云业务负责人\n\n方法论：\n\n1. 现有核心业务曲线发展到极致（尽其天年而不中道夭）\n2. 带领新组织开辟新的价值曲线网（独立小机构）\n\n## 破界创新\n\n第一性原理 = 逻辑奇点 + 公理演绎\n\n奇点下移\n\n2020年版\n\n## 第二曲线（2020版本）\n\n### 组合创新： 如何在旧要素中发现新机会\n\n### 单点破局： 如何力出一孔十倍速增长\n\n### 错位竞争： 如何做到与其更好不如不同\n\n### 低端颠覆： 新生力量如何逆袭上位\n\n### 组织心智： 如何冲破创新中的内部障碍\n\n### 第二曲线： 如何重启增长持续创新\n\n### 分形创新： 老产品如何长出新生命\n\n### 战略杠杆： 如何系统思考构建长期战略\n\n## 第一性原理\n\n### 第一原理： 什么是顶级智慧的至简之道\n\n### 公理思维： 如何从本质出发构建创新系统\n\n### 破界创新： 如何打破旧认知发现新世界\n\n### 组织刷新： 如何刷新使命驱动战略\n\n### 第一创新： 如何用第一原理引领创新\n\n### 万物至理： 如何超越对立走向整合\n\n### 从众效应： 如何打破群体信念\n\n### 批判思维： 高手是如何发现真相的\n\n## 理念世界\n\n### 理念世界： 存在是一\n\n### 理念世界： 零时空场\n\n### 觉性智慧： 觉性是一\n\n### 觉性智慧： 一个源头\n\n### 临在当下\n\n### 灵感流淌\n\n### 美好作品\n\n### 使命召唤\n"},{"title":"引流","url":"/invest/redirect_money.html","content":"\n## 核心\n\n提供价值\n被动引流\n\n## 方法论\n\n### 微信读书\n\n### 豆瓣\n\n<!-- more -->\n\n百度刷词\n视频裂变 录制视频 放上自己的微信\n\n淘宝客\n评价粉\n地推粉（导购）\n宝妈粉（小孩） 加WX\n快递粉（10000，400人左右 贴海报\n咸鱼\n    主动引流（找到对方是宝妈）\n\n大学生\n\n<!-- more -->\n\n新域名\n老域名\n聚名网  桔子 时光网 \n\n宝塔面板\n织梦程序"},{"title":"风控规则引擎介绍","url":"/risk_ctrl/rule_engine_intro.html","content":"\n如何向大家展示自己的工作成果-风控引擎\n\n风控引擎是什么？\n\n风控引擎需要有哪些功能？\n\n如何评估一款引擎的优劣？\n\n<!-- more -->\n\n业务接入\n规则判定\n执行决策\n\n总体架构\n\n表达式是\n\n规则引擎的应用场景主要包括以下特点：\n流程分支非常复杂，条件判断非常多，常规的（if…else）编码难以实现，维护成本高。\n不确定性需求非常多，频率非常高，随时都可能发生业务变更。\n业务规则变更要求实时生效。\n业务变更不依赖开发人员，可以由相关业务人员直接进行业务变更。\n\nGroovy脚本引擎\n\n选择核心的规则表达语言和规则执行引擎\n\n进行策略的执行顺序：\n\n在资源充足的前提下，一般来说策略的执行都是并行执行的，但是在一些情况下也会要求策略有先后的执行顺序。比如有些策略会依赖一些第三方数据源，这些数据在调用的时候就会产生成本，我们常见的有银行卡四要素、手机三要素等等。\n\n所以有的时候为了节省成本，会将这些策略执行顺序后置，当前面的策略已经足够产出明确的结论时（比如拒绝这次申请/发帖等），就无需执行后续策略。在运算资源上也是同理，会优先执行对运算资源消耗小的策略。\n\nDrools介绍\n\n例子：\n\n事实\n今天12:00，mid为10的用户购买了大会员，当时的IP地址为127.0.0.1\n\n基本概念：\n\n场景\n\n在一个场景（Scene)下，会持续不断的发生风险事件(Event)。\n这些风险事件\n\n风险事件\n\n风险等级\n\n规则\n\n因子\n\n决策\n\n特征（因子）类型\n\n1. 参数因子\n   1. 最\n2. 表达式因子\n   1. 由参数因子以及其他因子衍生而来\n3. 累计因子\n   1. 事件在时间纬度上的聚合\n\n风控的一些基本概念\n\n风控引擎的总体架构\n\n在线打击与离线打击如何协作\n\n执行决策\n\n第二部分 Gaia管理后台展示\n\n系统设计部分\n\n引擎与策略同学的协作流程\n\n有哪些模块，以及模块之间调用关系？\nrule（规则）, factor（因子）\nlib(名单库), finger-job（设备指纹）\ndecisions-job（决策） filter-job（过滤）\ngaia-job （异步）\n\n第三部分 规则&因子的预编译 与 执行\n\n开发期间遇到的问题：\n多个规则并行执行时，如何减少\n\nAST（抽象语法树）\n\n定义：\n   任何一个表达式，都可以解析为一棵AST\n\n生成：\n\n   1. 词法分析（对表达式进行Scan, 切分为Token数组）\n   2. 语法分析（将词法分析出来的Token数组转换成树形结构)\n\n例子：\n\n抽象语法su\n生成：\n\n预编译：将因子表达式处理为叶节点为参数因子的AST数\n\nA = B + 10\nB = C + 10\n\nAST的几种节点类型：\n\n1. identifier符号 （函数 + 变量)\n\n2. 表达式递归展开成为AST\n\n   1. 如果节点为符号,并且符号为变量，则递归\n   2. 否则，后序遍历\n3. AST的递归展开\n4. AST后序遍历，计算Hash值\n5. 将AST转换为DAG\n   1. 顶点：树节点的hash值\n   2. 边：节点与节点之间有依赖关系\n   3. 顶点的入库：该顶点有几个依赖的节点\n\n执行阶段\n基于Hash值的图合并\n合并图的拓扑排序\n图的分层执行与结果缓存\n因子的值获取\n\n累计抽象\n指标计算可以抽象总结出以下几个固有特征：\n时间窗口\n事件\n过滤条件\n主属性\n副属性\n聚合逻辑\n\n第四部分 未来规划\n\n实时数据的拓宽\n\n1. 因子特征的精细化监控\n（1）细化因子的类型\n（2）因子的完整度\n以数据为中心\n\n泰山感知\n\n定期输出各指标的性能、数据量、成本等情况，指导实时指标计算系统优化的方向。对于不再使用的指标，及时进行下线清理。\n\n中长周期累计因子\n挑战：低区分度，长周期，UV类型聚合\n\nFlink...\n\n累计因子超出阈值后的回扫操作\n\n规则优先级\n\n特征获取成本 与 执行耗时 的权衡\n\nhttps://www.jianshu.com/p/f4d4e2a4f88c\n《Scikit-Learn与TensorFlow机器学习实用指南》\n\nhttps://tensorflow.google.cn/tutorials/structured_data/time_series#baselines\ntensorflow教程\n"},{"title":"团队管理","url":"/团队管理能力/tech_lead.html","content":"\n![20201029201557](http://cdn.b5mang.com/20201029201557.png)"},{"title":"通识系列-《刘润商业通识30讲》","url":"/core/商业力/刘润商业通识30讲.html","content":"\n## 刘润商业通识30讲网盘地址\n\n网盘下载链接: https://pan.baidu.com/s/1QLhbBIfMH6iiwxAFXV-zsQ \n\n密码：在文末。\n\n---\n\n> 商业毫不关心你的方向，而你，必须关心商业的方向。\n> 商业进化的方向，到底是什么？ 就是网络密度越来越高，交易成本越来越低。\n\n<!-- more -->\n\n## 《刘润商业通识30讲》提纲\n\n### 商业是什么\n\n#### 交易\n\n产品 (product) 的 交换（exchange) --- 最根本手段\n    定价（Price)\n    营销（promotion)\n    渠道 (Place)\n\n1. 商业不是关于生产的学问，而是关于交换的学问\n2. 劳动创造财富，交换激励创造\n3. 货币切分买卖，商人连接交易\n\n#### 阻力\n\n信息不对称：我知道一些你不知道的事情\n信用不传递：离我越远的人我越不信任\n机灵的商人把“信息不对称”当作朋友，伟大的商人把“信息不对称”当作对手。\n\n### 交易成本\n\n解决问题就是不断的描述问题，直到解决方案显而易见。\n\n交易成本，是指为达成一笔交易所需要花费的全部时间和货币成本；\n交易成本，是为克服交易阻力而付出的代价。\n\n购买前：搜寻成本（淘宝）、比较成本（大众点评）、测试成本（统一评测）\n购买中：协商成本、付款成本\n\n整个社会降低协商成本的方法就是“事后惩罚” 社会信用体系\n因为品牌和声誉可以降低协商成本。\n\n购买后：运输成本、售后成本\n\n#### 商业模式\n\n商业模式，是利益相关者的交易结构。\n交易成本更低的结构，就是更好的交易结构，也就是更好的商业模式。\n伟大的创新，都源于巨大的结构改变。\n\n### 商业为什么进步\n\n推动商业变化的元动力：连接。\n所有伟大的创新，都源于巨大的结构变化。而巨大的结构变化，都源于连接方式的进步。\n\n连接改变世界的两种方式：\n空间折叠（物理连接）\n    铁路的诞生（西尔斯 =》 夫妻店）\n    沃尔玛\n    集装箱的发明\n\n时间坍缩 （信息连接）\n    电报、海底电报、微信\n\n连接对人们的冲击-不进则退\n（1）小人物的愤怒（失业的愤怒，让他们大骂，它们破坏了实体经济）\n（2）领先者的不屑（新的杀毒软件模式-建立了与广告主新的连接，而对用户免费）\n（3）不可能的遮蔽（他不可能做得到的，太复杂了，没有可操作性）\n\n网络密度，从0到无穷大\n交易成本，从无穷大到无限趋近于0\n网络密度=实际连接数/可能连接数\n\n无连接商业、线段型商业、中心型商业、去中心化商业、全连接商业\n\n### 商业从来哪里来\n\n#### 线段型商业\n\n交易成本低的地方，最先被连接。\n\n特征-商人的出现（既不生产，又不消费）、重利轻离别\n\n如何克服信息不对称-信息博弈（讨价还价、跟随出价、货比三家）\n讨价还价的本质：用信息博弈的方式，去克服信息不对称\n\n如何克服信用不对称-信用中介（黑市中间人、德高望重的乡绅）\n\n#### 中心型商业\n\n一个节点 =》 十字节点 =》 米字节点\n\n特征：进化（小区中心<夫妻店>、城镇中心<大润发、家乐福等>、全国中心<淘宝>、世界中心?<还没出来>）\n    互联网（信息流） + 支付（资金流） + 跨境运输（物流）\n\n超级节点（信息不对称、商品不对称）\n信息的超级节点<连接人与信息>：搜索引擎，每一次query之后都隐藏用户的需求，广告\n商品的超级节点<连接人与商品>：电商平台\n人的超级节点<连接人与人>：即时通信\n\n信用中心（银行-资金的交易中心、保险-风险的交易中心、证券-权益的交易中心）\n社会信用的基础设施，连接了借款人与贷款人。\n\n保险：同质风险承担，把那种发生概率特别小，但是发生之后影响很大的风险，找一群人分掉。\n凑份子的本质，就是保险。\n\n证券：股票 公司的经营权与管理权分离\n\n### 商业到哪里去\n\n#### 去中心化商业\n\n特征：人人可以中心\n\n保险赔付率太低的原因在于：集中管理成本比较高。\n\n现在腾讯、阿里等超级节点，会不会基础设施化？\n中国移动、中国电信等又是低一层的基础设施，也是超级节点。\n\n新的P2P应该在腾讯、阿里等这些超级节点基础设施化之后出现。\n\n信息对等：每一个人都是信息的中心\n\nmotif: 就是把那些优秀的、被“盈余”出来的“认知”收集起来，通过P2P对等网络直接提供给彼此，绕过“基金经理”这个中心\nangle list: 股权投资去中心化，把股权在P2P对等网络中零售\npeer cover: P2p保险，万物可保\n\n信用科技：大数据，人工智能搭建的信用基础设施\n\ninsurethebox: 个性化大数据赋能的车险（车险怎么缴：出险次数、年数、公里数、或者说用户的习惯）\n当前保险公司：基于社会统计数据去精算\n\nprogressive: 为每一个人进行个性化保险定价\n\n信用：就是对风险的承诺。用个性化大数据这种“信用科技”，进行更加精准的风险定价，帮助优质节点降低交易成本。\n\ncoin： 投行的人工智能风控\n\n区块链：加密（数学概念）的分布式（网络概念）记账技术（金融概念）\n\n之前用黄金记账，现在用的是账户，中心式记账（风险在于：技术问题、道德风险）\n\n#### 全连接商业\n\n特征：不再需要商人\n\n商品的定倍率约等于1 = 商品价格/生产成本\n\n商业发展，人类财富增加，除了前面提到的交易效率，还需要生产效率的提升：\n\n1. 第一次工业革命（煤炭，生产效率的提升，进一步带动了交易效率的提升<连接>）\n2. 第二次工业革命（电力革命：电、石油 =》 电话）\n3. 第三次工业革命（信息革命：算力、计算资源 =》 互联网）\n4. 第四次工业革命（数据就是大数据时代的能源）\n\n![生产效率带动交易效率]](http://cdn.b5mang.com/202123212738.png)\n\n### 我们如何顺势而为\n\n用护城河，把时代降临的“红利“，守护为丰富的“利润“，避免只拿微薄的“工资”。\n\n红利：短暂的供需失衡（仅仅是因为运气，除了你，别人也会看到。）\n工资：假的利润，社会平均利润。你以为你是在创业，其实你只是在为这个社会“打工”\n利润：真正的利润，来源于没有竞争。\n\n打造自己的护城河：\n（1）防止用户出去，用户的迁移成本\n（2）防止竞争对手进来（无形资产、降低成本、网络效应）\n\n#### 无形资产：无法看见的护城河\n\n许可（将其他竞争者拦截在外）、品牌（消费者的信任、偏爱）\n\n#### 成本优势\n\n管理（其他人学不会） + 规模（弹薄了固定成本）\n\n第一，管理（海底捞你学不会）\n\n第二，成本 = 固定成本  / 销售规模 + 变动成本\n\n按照上面公式，如果要降低成本：\n（1）降低固定成成本\n（2）降低变动成本\n（3）增加销售规模（小米、刘润写专题）\n\n#### 网络效应\n\n网络效应，就是某种产品对一名用户的价值，取决于该产品的其他用户的数量。分为两类：\n（1）用户 -单边网络效应-中国运营商（挟号转网的拖拖拉拉）\n（2）生态-多变网络效应-（滴滴打车）： 资本烧钱到临界点\n\n如何获得利润：资本换速度，快速冲过临界点，挤死其他竞争对手。\n（产品足够好、产品免费、产品补贴、产品补贴比别人快）\n\n#### 退出成本：反向建立护城河，防止用户逃离\n\n（1）用户习惯--用户的使用习惯，习惯锁\n（2）数据 -- 用户在手机或者某个电信服务商的数据，资产锁\n\n四类人：\n劳动者\n中奖者（享受时代带来的红利，然后坐吃山空）\n套利者（打一枪换一个地方）\n取势者（通过红利打造自己的护城河）\n\n网盘下载地址 密码: 1oot\n"},{"title":"吴晓波带你解读影响商业的50本书","url":"/core/商业力/wuxiaobo_jiedushangye50.html","content":"\n## 亚当斯密《国富论》\n\n创作背景:\n\n工业革命初期，蒸汽机的出现与炼钢技艺的提升，导致英国大量工厂出现。\n\n主要洞察：\n\n1. 整个经济活动通常由**劳动**、**土地**、**资本**组成\n2. **看不见的手**：每一个人的自私 VS 利他主义\n   关于人的善恶，东方主张**性善论**，“人之初，性本善”；而西方主张性恶论，人一生下来就有**原罪**，需要用一生去信奉上帝、去赎罪。  \n3. 分工导致工厂效率的提升\n\n<!-- more -->\n\n## 马克思《资本论》\n\n创作背景：工业革命发展到顶峰，压迫\n\n剩余价值 剥削 矛盾\n暴力革命\n\n马克思主义  \n主义的先验性\n\n改变世界 与 解释世界\n\n## 《新教伦理》\n\n## 《竞争优势》\n\n## 《隐形冠军》\n","categories":["经济与商业"]},{"title":"风控要略-互联网业务反欺诈之路","url":"/risk_ctrl/risk_ctrl_summary.html","content":"\n## 背景 业务安全正在崛起\n\n- 注册和登录场景的风控：\n    如何对抗黑产注册虚假账号、养号的行为，\n    如何对抗黑产暴力破解账户密码，\n    如何对抗“撞库”攻击。\n    黑产手中掌握了大量的手机号卡、公民信息和数以亿计的已泄露的互联网账号密码，这对任何一个互联网平台都是致命的威胁。\n- 营销活动风控保护：\n    营销活动发放的红包、游戏点券或其他奖励如何才能够不被黑产团伙“薅羊毛”。\n- APP渠道推广保护：\n    推广APP 装机量投入巨额费用后，如何衡量真实效果。\n    用户每安装激活一个APP，平台需要支付10元甚至20元，黑产通过“手机农场”虚假安装已经是广告行业顽疾。\n- 交易和支付场景风控：\n    盗号支付如何解决、\n    非法聚合支付如何解决、\n    洗钱如何解决，这些合规性问题关乎支付平台和相关业务的生死。\n- 接口安全保护：\n    短信发送接口被坏人用于制作“短信炸弹”是大家都遇到过的场\n- 内容安全：\n    内容安全既包括“入”也包括“出”，\n    “入”是检测用户发布到平台的内容是否包含“色情、反动、赌博和暴恐”等违规信息，\n    “出”则是对抗专业爬虫大量获取网站内容信息\n\n## 洞察黑产\n\n黑产从业人员已达数十万余人，每年给互联网公司造成的经济损失超过百亿元\n\n### 黑产组织结构\n\n黑色产业链结构\n附图\n\n反欺诈词典\n\n- 垃圾注册（产生大规模账号）\n- 薅羊毛\n- 刷单/黄牛\n- 众包\n- 炒信（刷好评、刷热门词等）\n- 套利（黑产与商家的勾结）\n- 空包（代发快递）\n\n### 黑产武器库\n\n- 虚假号码\n\n手机卡商 =》 接码平台 =》 短信验证码代收服务 （产业链上游）\n关键词：手机rom后门、猫池、流量卡和物联网卡、空号注册、接码平台、短信验证码\n\n- 代理IP\n\nIP怎么来的？ 控制更多的肉鸡程序\n\n- 设备伪造工具\n\n改机工具、多开工具、Root/越狱工具、Xposed、Cydia、Frida、硬改、脱机挂、备份/抹机恢复、模拟器、定制浏览器、自动化脚本\n\n- 其他\n群控设备、位置伪造、工具箱\n\n## 黑产打击体系构建\n\n“终端风险识别+云端风险决策+AI”的一体化反欺诈解决方案\n\n### 设备指纹\n\n设备ID 可以用于统计业务运营数据（如DAU、MAU、广告激活），也可以用于用户画像、广告精准营销、Bug 上报等。\n在互联网反欺诈对抗中，设备ID 类规则是防刷单、防薅羊毛、虚假设备识别、反爬虫、账号安全等场景的核心规则。\n\n好的设备指纹产品特性：\n\n准确性-准确率高，不同设备生成的设备指纹保证不会重复，确保设备指纹生成的唯一性。个人的常用设备总是有限的，一段时间内一般不会超过5个以上。\n稳定性-设备系统升级或少量参数变更，设备指纹码不会发生变更。\n生成率-即设备覆盖率，确保各种设备载体都能生成设备指纹唯一码。\n安全性-不会再网络传输中杯篡改、注入导致生成设备伪码。\n\nhttps://zhuanlan.zhihu.com/p/68852244\n\n### 基于用户行为的生物探针\n\n无感认证的基础：\n自然人、机器人的操作行为存在差异。\n每个人都有自己不可复制的行为习惯。\n通过这些差异即可识别用户的身份。\n\n### 智能验证码\n\n对抗生成网络方法的出现基本宣告了字符验证码退出历史舞台\n打码平台\n\n### 风控引擎\n\n所有的规则描述都是基于自然语言的，易于风控运营人员理解和维护。\n\n### 实时指标计算\n\n作用域：针对事件类型、针对事件标志\n\nLamba架构：\n我们把一个时间跨度较长的实时指标计算转化为一个“较短时间窗口的实时指标”加上一个“历史数据的离线指标”的聚合结果\n\n### 风险态势感知系统\n\n原因：专家水平差异性、黑产攻击手法多样性、运营人员操作风险、产品和系统bug\n\n方法：基于统计分析的方法、基于半监督、无监督算法的聚类方法和基于业务情报的方法\n\n前提：\n正常业务具有连续性和稳定性，异常事件具有波动性。\n正常用户总是表现出分布离散性，而黑产总是表现出聚集性\n\n#### 基于统计分析的方法\n\n两类核心统计数据：\n\n1. 核心风险事件数据：主要指风控系统中产生的数据，包括实时决策系统的入参、出参、中间计算结果、决策结果等。\n\nPSI 群体稳定性指标 SUM[(AC - EX) * ln(AC / EX)]\n调用量、拒绝率、拒绝变化率、人审率、人审变化率\n决策结构PSI、规则命中PSI\n字段获取率\n\n2. 核心业务数据：主要指业务自身的核心数据指标，和具体业务场景相关，如电商、O2O、直播等各不相同。\n\n预警业务风险态势需要的数据包括IP 段分布、收货地址分布、商品类目分布及店铺分布等\n\n#### 基于无监督学习的方法\n\n无监督学习方法的步骤一般包括特征抽取、建立连通图、群组聚类等\n通过无监督学习方法发现风险后，可以和实时决策的结果进行比对。\n如果无监督学习方法比实时决策的增益率高，则需要关注当天的数据，业务有被攻击的可能。\n\n#### 基于业务情报的方法\n\n通过**语义分析**可以准确提取情报主体（客户名）、类型（薅羊毛）、手法（新用户抽奖）等信息，及时预警给风控运营人员进行针对性防控。\n\n### 名单系统\n\n首先需要明确哪些数据可以用于建立名单，确定名单数据的主键。\n在互联网反欺诈业务中，常见的几种名单主键是：手机号、身份证、银行卡、IP 和各类设备标识\n\n其次，需要明确标签的类别。\n标签可以指向一种明确的风险，如可以建立一个“刷单”的手机号黑名单，或者一个爬虫的IP 黑名单，这样的标签都直接指向了一种特定风险\n\n### 欺诈情报体系\n\n对一次欺诈事件来说，需要综合各方面进行分析，梳理清楚其来龙去脉：\n黑产团伙为什么这么做？\n黑产团伙是具体如何操作的？\n黑产团伙如何绕过已有的一些风控策略？\n黑产团伙是否使用了比较特殊的欺诈技术或欺诈手段？其原理是什么？\n黑产团伙使用了哪些资源？这些资源是从哪里获取的？\n预计有多少黑产团伙参与这次欺诈事件？\n\n## 实战教程\n\n落地机器算法的工作主要包括：特征工程、模型选择、模型训练、工程化和业务落地。\n\n案例一：黑产设备群控网络挖掘\n总体思路：\n\n1. 对于所有特征，计算两台设备的相似度，如果相似度超过某一阈值，则将两个顶点相连。\n2. 剪枝，连通图算法，进行图划分\n\n案例二：黑产用户行为聚类分析\n\n借用文本的向量空间模型刻画一个用户的动作集合：\n每一个用户的动作集合可以看作是一篇文章，用户的每个动作（包含动作、场景和源场景，这里我们把动作ID、场景、源场景连接构成一个行为特征串）可以看作一个单词，有些动作可能会重复多次，因而可以看作一个单词的多次出现\n"},{"title":"机器学习三要素：模型、策略和算法","url":"/ai/ml_3.html","content":"\n机器学习在干嘛？就是利用已有数据，找到一些合适的数学模型去描述它，然后做一些预测分析，从而优化企业的流程或者提高决策效率。机器学习的核心是：模型、策略和算法\n\n机器学习的目的——模型（Model）\n\n模型就是用来描述客观世界的数学模型，模型是从数据里抽象出来的。在进行数据分析时，我们通常手上只有数据，然后看数据找规律，找到的规律就是模型。就跟我们小时候做猜数字游戏似的，1，4，16...（）...256...括号里面是什么？只有把这串数抽象成模型，我们才能知道括号里面是什么。\n\n再举个例子，购买产品的顾客到达服务台的时间是什么模型？也许是一个泊松分布。股票价格随时间的变化是什么关系？是基于布朗运动的二项随机分布...\n\n模型可以是确定的，也可以是随机的，无所谓，总之用数学可以描述，只要数学可以描述的，就可以进行预测分析。所以，我们的根本目的，是找到一个模型区描述我们已经观测到的数据。\n\n<!-- more -->\n\n如何构造模型——策略（Strategy）\n\n例如，我们想用一个正态分布去描述一组数据，我们就要去构造这个正态分布，实际上就是预测这个分布的参数，例如：均值？方差？...但是，我们需要有一系列的标准去选择合适的模型，模型不是拍脑袋来的。我想用正态分布，理由呢？我想用二项分布，凭啥呢？我想让正态分布的均值为0.5，凭什么0.5比0.2好？所以，需要有一些列标准来证明一个模型比另一个模型好，这就是策略。\n\n不同的策略，对应不同的模型的比较标准和选择标准。就和选班干部一样，选帅的，那就让吴彦祖当班长；选逗比的，也许选出来的是王宝强；选会唱歌的，没准是周杰伦...所以，最终确定的模型是什么，实际上就跟两件事有关，1）我们的数据是什么？ 2）我们选择模型的策略是什么？\n\n说到策略，一般会讲到，经验风险最小化作为常用的标准。经验风险最小指的是，用这个模型，用在已有的观测数据上，基本上是靠谱的。但在已有观测数据不足的情况下，我们也可以采用结构风险最小化作为标准。这也是我们在机器学习的时候用到的准则。经验风险和结构最小化是一个参数优化的过程，我们需要构造一个损失函数来描述经验风险，损失函数可以理解为我们预测一个数据错了给我们带来的代价。每个人对损失函数的定义都不同，所以优化出来的结果也不同，这也导致最终我们学习到的模型会各种各样，解决一个问题的方案有多种多样...\n\n模型的实现——算法（Algorithm）\n\n我们有了数据，有了学习模型的策略，然后就要开始去构造模型了，如果模型的基本形式有了，就是一个优化模型参数的问题了。面对复杂的数学优化问题，我们通常难以通过简单的求导获得最终结果，所以就要构造一系列的算法。\n\n我们的目标是让算法尽量高效，更少的计算机内存代价，更快的运算速度，更有效的参数优化结果...\n\n总结：在进行机器学习时，只要把握住模型、策略和算法这三个要点即可。商业决策的基础是对客观环境进行描述，我们用数学模型去描述预测，所以要采取一定的策略选择合适的模型，而模型的构造本质是数学参数优化问题，在大数据的环境下要构造合适的算法去解决对应的优化问题，这就是整个机器学习的方法构造理念。\n————————————————\n版权声明：本文为CSDN博主「Main_阿闪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Baby_bye/article/details/99626477"},{"title":"如何为Maven配置国内镜像资源","url":"/研发流程/maven_site.html","content":"\n## 为什么需要为Maven配置国内镜像资源\n\nMaven是很流行的项目管理工具，但是由于国外的仓库经常连接不上，即便是连接上，下载速度也很慢。所以，我们需要寻求一个解决方案？\n\n## 解决方案\n\n为Maven配置国内镜像资源\n\n<!-- more -->\n\n## 解决步骤\n\n### 下载Maven, 并配置环境相应的环境变量\n\n1. 下载安装maven\n2. 添加环境变量，并设置使之生效\n\n``` java\nbrew install maven\n```\n\n```sh\nexport MAVEN_HONE=/usr/local/Cellar/maven/3.6.2/\nPATH=$MAVEN_HONE/bin:$PATH:\n```\n\n### 修改maven setting配置\n\n1. 找到配置文件地址：$MAVEN_HONE/libexec/conf/settings.xml\n2. 编辑文件，添加以下内容：\n\n```xml\n     <mirror>\n        <id>alimaven</id>\n        <mirrorOf>central</mirrorOf>\n        <name>aliyun maven</name>\n        <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\n        </mirror>\n```\n\n![file](http://graph.baidu.com/resource/222f02fd6561b69f87ee901589881351.png)\n"},{"title":"推荐系统介绍","url":"/ai/recommend/recommend_intro.html","content":"\n亲爱的读者您好，感谢您在阅读我的文章。\n出于发布渠道的考虑，我可能在各个渠道更新文章不够及时。\n因此，如果您喜欢我的文章，想阅读更多我的文字，\n您可转到我的[个人博客](https://neowei1987.github.io/)或者公众账号阅读文章：\n![file](http://graph.baidu.com/resource/22251103dcfcfc1b2c4cf01589605159.png)\n\n## 推荐系统产生的三个背景\n\n<!-- more -->\n\n1. 服务“标的物”的种类也越来越多样\n2. 个性喜好，“长尾理论”也很好的解释了多样化物品中的非畅销品可以满足人们多样化的需求，这些需求加起来不一定比热门物品产生的销售额小。\n3. 不同于生存需求，面对非生存需求，人们实际上更愿意接受被动推荐的好的物品， 比如给你推荐一部电影，如果符合你的口味，你可能会很喜欢。\n\n## 推荐系统能够解决了什么问题\n\n从本质上讲，推荐系统提升了信息分发和信息获取的效率。\n推荐系统本质上是在用户需求不明确的情况下， 从海量的信息中为用户寻找其感兴趣的信息的技术手段。\n推荐系统结合用户的信息(地域，年龄，性别等)，物品信息(价格，产地等)，以及用户过去对物品的行为(是否购买，是否点击，是否播放等)，利用机器学习技术构建用户兴趣模型，为用户提供精准的个性化推荐。\n推荐系统很好的满足了“标的物”提供方，平台方，用户三方的需求。\n\n## 应用领域\n\n只要存在大量的“供用户消费的商品”的互联网产品，推荐系统就有用武之地！\n\n## 推荐系统的定义\n\n推荐系统是一项工程技术解决方案，通过利用机器学习等技术，在用户使用产品进行浏览交互的过程中，系统主动为用户展示可能会喜欢的物品，从而促进物品的“消费”，节省用户时间，提升用户体验， 做到资源的优化配置。\n\n涉及到大量的工程开发，涉及到日志打点、日志收集、ETL、分布式计算、特征工程、推荐算法建模、数据存储、提供接口服务、UI展示与交互、推荐效果评估等各个方面；\n\n推荐系统是一种为用户提供感兴趣信息的便捷渠道，通过为用户提供信息创造商业价值；推荐系统的本质是通过技术手段将“标的物”与人关联起来，方便人获取对自己有价值的“标的物”。\n\n## 常用推荐算法\n\n1. 基于内容的推荐\n举个例子：系统分析了某个人的浏览记录，发现他对恐怖电影分类比较感兴趣，系统便推荐更多的恐怖电影给用户。\n2. 协同过滤\n基于“物以类聚，人以群分”的朴素思想：\n“人以群分” 基于用户的协同过滤\n拿看电影这个例子来说，如果你喜欢《蝙蝠侠》、《碟中谍》、《星际穿越》、《源代码》等电影，另外有个人也都喜欢这些电影，而且他还喜欢《钢铁侠》，则很有可能你也喜欢《钢铁侠》这部电影。\n所以说，当一个用户 A 需要个性化推荐时，可以先找到和他兴趣相似的用户群体 G，然后把 G 喜欢的、并且 A 没有听说过的物品推荐给 A，这就是基于用户的系统过滤算法。\n具体参考：https://blog.csdn.net/shixiaoguo90/article/details/80253567\n“物以类聚” 基于物品的协同过滤\n当用户表达出对一个物品的喜爱后, 推荐与该物品相似的物品。\n具体参考：https://www.jianshu.com/p/27b1c035b693 https://blog.csdn.net/qq_40006058/article/details/83385324\n3. 基于模型的推荐\n基于用户行为记录，用户相关信息(年龄，性别，地域，消费习惯等)，物品相关信息，构建算法模型，预测用户对物品的偏好，常用的算法有logistic回归，矩阵分解等。\n4. 基于关注关系的推荐\n\n## 推荐系统的挑战\n\n1. 推荐系统推荐精准度的问题？\n\n2. 冷启动问题： 新用户、新物品没有相关行为信息， 这时系统怎么给用户推荐，怎么将新物品推荐出去， 在推荐系统落地过程中都需要做结合业务场景的特殊处理才能达到好的用户体验；\n\n3. 高并发，高可用；\n\n4. 数据缺失的问题：现实场景中一定存在用户或者物品的信息不完善，或者部分信息有误，这些也是在构建推荐算法模型过程中必须考虑和解决的问题；\n\n5. 非结构化的信息：用户和物品相关的信息有可能是非结构化的信息，比如图片，视频，音频，文本等，怎么高效的利用这些信息，为推荐模型提供更多信息输入， 随着深度学习在推荐系统中大规模运用，这类问题可以得到较好的解决；\n\n6. 一些噪音及恶意攻击也会产生大量垃圾数据，对更好的做推荐产生很大的干扰， 怎么很好的保证训练数据的质量，这是ETL和特征工程需要解决的重要问题；\n\n7. 大规模计算与存储：大量的用户和大量的物品，对数据处理和计算造成很大的压力，需要采用分布式技术(如Hadoop，Spark等)来做数据存储，处理，计算等， 所以要很好的落地推荐系统需要企业构建一套高效的大数据分析处理平台；\n\n8. 实时性：为了给用户提供实时的个性化推荐(如今日头条的新闻推荐等)， 需要实时收集处理用户的反馈，做到更及时精准的推荐，为用户提供强感知的服务。对大规模用户做到实时响应，对算法，计算，处理有相当大的挑战。\n\n9. 怎么评估推荐算法的价值：推荐系统怎么服务于业务，怎么衡量推荐系统的价值产出，怎么为推荐系统制定业务指标，通过指标提升推荐系统效果的同时促进业务发展？这些问题都是摆在推荐系统开发人员， 甚至是公司管理者面前的重要问题， 只有很好的度量出推荐系统的价值，才能更好的优化推荐系统，发挥推荐系统的价值。\n"},{"title":"跨界思维-各学科核心理论一览","url":"/底层思维/gap_thinking.html","content":"\n## 物理学\n\n### 守恒定律\n\n### 熵增定律\n\n封闭系统，随着时间熵不断增加，且不可逆；\n\n### 最小作用量原理\n\n### 原子论\n\n自然界可以分割为不可分割的原子。\n\n<!-- more -->\n\n## 系统动力学\n\n### 阈值效应\n\n相变临界点：101% = 1； 99% = 0\n\n## 生物学\n\n### 生物进化论\n\n物竞天择，适者生存；\n遗传变异，自然选择；\n\n性状趋异原则\n\n## 数学\n\n### 分形\n\n任何复杂的系统，由少数几个简单规则组合而成。\n\n### 简一律\n\n奥卡姆剃刀原理\n\n## 哲学\n\n### 还原论\n\n西方认识客观世界的主流哲学观：要素拆分，组合还原；\n原子、比特、基因\n\n## 案例\n\nElon Mask 拆解电动汽车电池\nElon Mask 拆解拆解超级隧道\nElon Mask 拆解拆解火星移民\n总体上，降低成本是解决每一件事情的关键；成本的量化\n"},{"title":"categories","url":"/categories/index.html"},{"title":"friend links","url":"/links/index.html"},{"title":"tags","url":"/tags/index.html"}]